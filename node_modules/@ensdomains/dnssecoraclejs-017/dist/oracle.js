"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Oracle = exports.OutdatedDataError = void 0;
const packet = require("dns-packet");
const types = require("dns-packet/types");
const ethers_1 = require("ethers");
const DNSSEC__factory_1 = require("./typechain/factories/DNSSEC__factory");
const log_1 = require("./log");
class OutdatedDataError extends Error {
    constructor(answer) {
        super(`Oracle has a newer version of the ${answer.signature.data.typeCovered} RRSET on ${answer.signature.name}`);
        this.name = 'OudatedDataError';
        this.answer = answer;
    }
}
exports.OutdatedDataError = OutdatedDataError;
class Oracle {
    constructor(address, provider, now = undefined) {
        this.contract = DNSSEC__factory_1.DNSSEC__factory.connect(address, provider);
        this.now = now || Date.now;
    }
    // Takes a `ProvableAnswer` returned by dnsprovejs and converts it into a blob of proof
    // data for the DNSSEC oracle contract.
    getProofData(answer) {
        return __awaiter(this, void 0, void 0, function* () {
            const allProofs = answer.proofs.concat([answer.answer]);
            for (let i = allProofs.length - 1; i >= 0; i--) {
                if (yield this.knownProof(allProofs[i])) {
                    if (i == allProofs.length - 1) {
                        console.log(`All proofs for ${answer.answer.signature.data.typeCovered} ${answer.answer.signature.name} are already known`);
                        return { data: Buffer.of(), proof: allProofs[allProofs.length - 1].toWire(false) };
                    }
                    log_1.logger.info(`${answer.answer.signature.data.typeCovered} ${answer.answer.signature.name} has ${i + 1} of ${allProofs.length} proofs already known`);
                    return {
                        data: this.encodeProofs(allProofs.slice(i + 1, allProofs.length)),
                        proof: allProofs[i].toWire(false),
                    };
                }
            }
            log_1.logger.info(`${answer.answer.signature.data.typeCovered} ${answer.answer.signature.name} has no proofs already known`);
            return {
                data: this.encodeProofs(allProofs),
                proof: Buffer.from(ethers_1.utils.arrayify(yield this.contract.anchors())),
            };
        });
    }
    knownProof(proof) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = packet.name.encode(proof.signature.name);
            const type = types.toType(proof.signature.data.typeCovered);
            const [inception, inserted, hash] = yield this.contract.rrdata(type, name);
            if (inception > proof.signature.data.inception) {
                throw new OutdatedDataError(proof);
            }
            const expired = inserted.toNumber() + proof.signature.data.originalTTL < this.now() / 1000;
            const proofHash = ethers_1.utils.keccak256(proof.toWire(false)).slice(0, 42);
            return (hash == proofHash) && !expired;
        });
    }
    encodeProofs(proofs) {
        const buffers = new Array(proofs.length);
        for (let i = 0; i < proofs.length; i++) {
            const proof = proofs[i];
            const data = proof.toWire(true);
            const sig = proof.signature.data.signature;
            const buf = Buffer.alloc(data.length + sig.length + 4);
            buf.writeInt16BE(data.length, 0);
            data.copy(buf, 2);
            buf.writeInt16BE(sig.length, data.length + 2);
            sig.copy(buf, data.length + 4);
            buffers[i] = buf;
        }
        return Buffer.concat(buffers);
    }
}
exports.Oracle = Oracle;
