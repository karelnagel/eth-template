var dnssec = artifacts.require("./DNSSEC.sol");
var SolidityUtils = require('truffle-solidity-utils');
var codeutils = require('truffle-code-utils');
var Config = require("truffle-config");
var Sources = require('truffle-contract-sources');
var fs = require('fs');

var txids = ['0x40fd3c838db20376b98af465de1be0aec7f631f65c25ab2f97a4561f620ef531', '0x18e3f7b35866b7757075bad78a3f1f20847a970e1073b61058cc4ad501d6c744', '0x2d2f7d03fe0ee4a357a1d2c70926d509144f256dc846fad9ca1c847c524f80d9', '0x22e526150403bf96b17a1c1d4dbbaaf2b560c75e0414f512f4a19f57c2665373', '0x0537f4e4b878a03e3d443c03032c360950af02682d3f7bc90849cd4d4872cd61', '0x8753a1649d31bf830cf2afc3d88f4581b274cc4f0d8f54e149a964fa6016de13'];


async function getTrace(txHash) {
  return new Promise( (accept, reject) => {
    this.web3.currentProvider.sendAsync({
      jsonrpc: "2.0",
      method: "debug_traceTransaction",
      params: [txHash, {}],
      id: new Date().getTime()
    }, (err, result) => {
      if (err) return reject(err);
      if (result.error) return reject(new Error(result.error.message));
      accept(result.result);
    });
  });
};

function reduceTraceByInstruction(trace, instructions) {
  instructions = instructions.reduce((acc, obj, idx) => {
    acc[obj.pc] = idx;
    return acc;
  }, {});
  return trace.reduce((acc, obj) => {
    if(obj.depth > 0) return acc;
    if(obj.gasCost < 0) {
      console.log("WARNING: Negative gas cost at PC " + obj.pc);
      return acc;
    }

    var offset = instructions[obj.pc];
    if(offset === undefined) console.log(obj);
    acc[offset] = (acc[offset] || 0) + obj.gasCost;
    return acc;
  }, {});
}

module.exports = async function(callback) {
  var config = Config.detect({});
  var sources = await new Promise((accept, reject) => {
    Sources(config.contracts_directory, (err, result) => {
      if(err) {
        reject(err);
        return;
      }
      accept(result);
    });
  });

  var lineAndColumnMappings = Object.assign({},
    ...sources.map(
      (filename, id) => ({
        [id]: SolidityUtils.getCharacterOffsetToLineAndColumnMapping(fs.readFileSync(filename, {encoding: 'utf-8'}))
      })
    )
  );

  var traces = [];
  for(var i = 0; i < txids.length; i++) {
    traces.push(...(await getTrace(txids[i])).structLogs);
  }

  var instructions = codeutils.parseCode(dnssec.deployedBytecode);
  var pcGasMap = reduceTraceByInstruction(traces, instructions);

  var sourceMap = SolidityUtils.getHumanReadableSourceMap(dnssec.deployedSourceMap);

  var lineMap = Object.entries(pcGasMap).reduce((acc, [offset, gasUsed]) => {
    var sourceLocation = sourceMap[offset];
    if(sourceLocation === undefined) {
      console.log("WARNING: Location " + sourceLocation + " does not exist in source map" + " (gas used: " + gasUsed + ").");
      return acc;
    }

    if(sourceLocation.file != -1) {
      var sourceFile = sources[sourceLocation.file];
      var sourceLine = lineAndColumnMappings[sourceLocation.file][sourceLocation.start];
      if(sourceLine === undefined) {
        console.log("WARNING: Location " + sourceLocation.start + " does not exist in file " + sourceFile);
        sourceLine = {line: 0};
      }

      if(!acc[sourceFile]) {
        acc[sourceFile] = {};
      }
      acc[sourceFile][sourceLine.line] = (acc[sourceFile][sourceLine.line] || 0) + gasUsed;
    }

    return acc;
  }, {});

  for(var entry of Object.entries(lineMap)) {
    console.log(entry[0]);
    console.log("---");
    var source = fs.readFileSync(entry[0], {encoding: "utf-8"}).split("\n");
    var gasUsed = entry[1];
    for(var i = 0; i < source.length; i++) {
      console.log((gasUsed[i] || 0) + "\t" + source[i]);
    }
    console.log("\n");
  }

  callback(null);
}
