{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DataStructures_1 = require(\"../../utils/DataStructures\");\n\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\n\nvar ConsoleLoggerImpl_1 = require(\"./ConsoleLoggerImpl\");\n\nvar MessageBufferLoggerImpl_1 = require(\"./MessageBufferLoggerImpl\");\n\nvar AbstractLogger_1 = require(\"./AbstractLogger\");\n\nvar LogGroupRuntimeSettings_1 = require(\"./LogGroupRuntimeSettings\");\n\nvar LoggerFactoryImpl = function () {\n  function LoggerFactoryImpl(name, options) {\n    this._loggers = new DataStructures_1.SimpleMap();\n    this._logGroupRuntimeSettingsIndexed = [];\n    this._loggerToLogGroupSettings = new DataStructures_1.SimpleMap();\n    this._name = name;\n    this.configure(options);\n  }\n\n  LoggerFactoryImpl.prototype.configure = function (options) {\n    this._options = options; // Close any current open loggers.\n\n    this.closeLoggers();\n\n    this._loggerToLogGroupSettings.clear();\n\n    this._logGroupRuntimeSettingsIndexed = [];\n    var logGroupRules = this._options.logGroupRules;\n    /* tslint:disable:prefer-for-of */\n\n    for (var i = 0; i < logGroupRules.length; i++) {\n      this._logGroupRuntimeSettingsIndexed.push(new LogGroupRuntimeSettings_1.LogGroupRuntimeSettings(logGroupRules[i]));\n    }\n    /* tslint:enable:prefer-for-of */\n\n  };\n\n  LoggerFactoryImpl.prototype.getLogger = function (named) {\n    if (!this._options.enabled) {\n      throw new Error(\"LoggerFactory is not enabled, please check your options passed in\");\n    }\n\n    var logger = this._loggers.get(named);\n\n    if (typeof logger !== \"undefined\") {\n      return logger;\n    } // Initialize logger with appropriate level\n\n\n    logger = this.loadLogger(named);\n\n    this._loggers.put(named, logger);\n\n    return logger;\n  };\n\n  LoggerFactoryImpl.prototype.isEnabled = function () {\n    return this._options.enabled;\n  };\n\n  LoggerFactoryImpl.prototype.closeLoggers = function () {\n    this._loggers.forEachValue(function (logger) {\n      // We can only close if AbstractLogger is used (our loggers, but user loggers may not extend it, even though unlikely).\n      if (logger instanceof AbstractLogger_1.AbstractLogger) {\n        logger.close();\n      }\n    });\n\n    this._loggers.clear();\n  };\n\n  LoggerFactoryImpl.prototype.getName = function () {\n    return this._name;\n  };\n\n  LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByIndex = function (idx) {\n    if (idx >= 0 && idx < this._logGroupRuntimeSettingsIndexed.length) {\n      return this._logGroupRuntimeSettingsIndexed[idx];\n    }\n\n    return null;\n  };\n\n  LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByLoggerName = function (nameLogger) {\n    var result = this._loggerToLogGroupSettings.get(nameLogger);\n\n    if (typeof result === \"undefined\") {\n      return null;\n    }\n\n    return result;\n  };\n\n  LoggerFactoryImpl.prototype.getLogGroupRuntimeSettings = function () {\n    return this._logGroupRuntimeSettingsIndexed.slice(0);\n  };\n\n  LoggerFactoryImpl.prototype.loadLogger = function (named) {\n    var logGroupRules = this._options.logGroupRules;\n\n    for (var i = 0; i < logGroupRules.length; i++) {\n      var logGroupRule = logGroupRules[i];\n\n      if (logGroupRule.regExp.test(named)) {\n        var logGroupRuntimeSettings = this._logGroupRuntimeSettingsIndexed[i];\n        var logger = void 0;\n\n        switch (logGroupRule.loggerType) {\n          case LoggerOptions_1.LoggerType.Console:\n            logger = new ConsoleLoggerImpl_1.ConsoleLoggerImpl(named, logGroupRuntimeSettings);\n            break;\n\n          case LoggerOptions_1.LoggerType.MessageBuffer:\n            logger = new MessageBufferLoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRuntimeSettings);\n            break;\n\n          case LoggerOptions_1.LoggerType.Custom:\n            if (logGroupRule.callBackLogger != null) {\n              logger = logGroupRule.callBackLogger(named, logGroupRuntimeSettings);\n            } else {\n              throw new Error(\"Cannot create a custom logger, custom callback is null\");\n            }\n\n            break;\n\n          default:\n            throw new Error(\"Cannot create a Logger for LoggerType: \" + logGroupRule.loggerType);\n        } // For a new logger map it by its name\n\n\n        this._loggerToLogGroupSettings.put(named, logGroupRuntimeSettings);\n\n        return logger;\n      }\n    }\n\n    throw new Error(\"Failed to find a match to create a Logger for: \" + named);\n  };\n\n  return LoggerFactoryImpl;\n}();\n\nexports.LoggerFactoryImpl = LoggerFactoryImpl;","map":{"version":3,"sources":["../../../../src/logging/log/standard/LoggerFactoryImpl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DataStructures_1 = require(\"../../utils/DataStructures\");\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\nvar ConsoleLoggerImpl_1 = require(\"./ConsoleLoggerImpl\");\nvar MessageBufferLoggerImpl_1 = require(\"./MessageBufferLoggerImpl\");\nvar AbstractLogger_1 = require(\"./AbstractLogger\");\nvar LogGroupRuntimeSettings_1 = require(\"./LogGroupRuntimeSettings\");\nvar LoggerFactoryImpl = (function () {\n    function LoggerFactoryImpl(name, options) {\n        this._loggers = new DataStructures_1.SimpleMap();\n        this._logGroupRuntimeSettingsIndexed = [];\n        this._loggerToLogGroupSettings = new DataStructures_1.SimpleMap();\n        this._name = name;\n        this.configure(options);\n    }\n    LoggerFactoryImpl.prototype.configure = function (options) {\n        this._options = options;\n        // Close any current open loggers.\n        this.closeLoggers();\n        this._loggerToLogGroupSettings.clear();\n        this._logGroupRuntimeSettingsIndexed = [];\n        var logGroupRules = this._options.logGroupRules;\n        /* tslint:disable:prefer-for-of */\n        for (var i = 0; i < logGroupRules.length; i++) {\n            this._logGroupRuntimeSettingsIndexed.push(new LogGroupRuntimeSettings_1.LogGroupRuntimeSettings(logGroupRules[i]));\n        }\n        /* tslint:enable:prefer-for-of */\n    };\n    LoggerFactoryImpl.prototype.getLogger = function (named) {\n        if (!this._options.enabled) {\n            throw new Error(\"LoggerFactory is not enabled, please check your options passed in\");\n        }\n        var logger = this._loggers.get(named);\n        if (typeof logger !== \"undefined\") {\n            return logger;\n        }\n        // Initialize logger with appropriate level\n        logger = this.loadLogger(named);\n        this._loggers.put(named, logger);\n        return logger;\n    };\n    LoggerFactoryImpl.prototype.isEnabled = function () {\n        return this._options.enabled;\n    };\n    LoggerFactoryImpl.prototype.closeLoggers = function () {\n        this._loggers.forEachValue(function (logger) {\n            // We can only close if AbstractLogger is used (our loggers, but user loggers may not extend it, even though unlikely).\n            if (logger instanceof AbstractLogger_1.AbstractLogger) {\n                logger.close();\n            }\n        });\n        this._loggers.clear();\n    };\n    LoggerFactoryImpl.prototype.getName = function () {\n        return this._name;\n    };\n    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByIndex = function (idx) {\n        if (idx >= 0 && idx < this._logGroupRuntimeSettingsIndexed.length) {\n            return this._logGroupRuntimeSettingsIndexed[idx];\n        }\n        return null;\n    };\n    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByLoggerName = function (nameLogger) {\n        var result = this._loggerToLogGroupSettings.get(nameLogger);\n        if (typeof result === \"undefined\") {\n            return null;\n        }\n        return result;\n    };\n    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettings = function () {\n        return this._logGroupRuntimeSettingsIndexed.slice(0);\n    };\n    LoggerFactoryImpl.prototype.loadLogger = function (named) {\n        var logGroupRules = this._options.logGroupRules;\n        for (var i = 0; i < logGroupRules.length; i++) {\n            var logGroupRule = logGroupRules[i];\n            if (logGroupRule.regExp.test(named)) {\n                var logGroupRuntimeSettings = this._logGroupRuntimeSettingsIndexed[i];\n                var logger = void 0;\n                switch (logGroupRule.loggerType) {\n                    case LoggerOptions_1.LoggerType.Console:\n                        logger = new ConsoleLoggerImpl_1.ConsoleLoggerImpl(named, logGroupRuntimeSettings);\n                        break;\n                    case LoggerOptions_1.LoggerType.MessageBuffer:\n                        logger = new MessageBufferLoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRuntimeSettings);\n                        break;\n                    case LoggerOptions_1.LoggerType.Custom:\n                        if (logGroupRule.callBackLogger != null) {\n                            logger = logGroupRule.callBackLogger(named, logGroupRuntimeSettings);\n                        }\n                        else {\n                            throw new Error(\"Cannot create a custom logger, custom callback is null\");\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Cannot create a Logger for LoggerType: \" + logGroupRule.loggerType);\n                }\n                // For a new logger map it by its name\n                this._loggerToLogGroupSettings.put(named, logGroupRuntimeSettings);\n                return logger;\n            }\n        }\n        throw new Error(\"Failed to find a match to create a Logger for: \" + named);\n    };\n    return LoggerFactoryImpl;\n}());\nexports.LoggerFactoryImpl = LoggerFactoryImpl;\n//# sourceMappingURL=LoggerFactoryImpl.js.map"]},"metadata":{},"sourceType":"script"}