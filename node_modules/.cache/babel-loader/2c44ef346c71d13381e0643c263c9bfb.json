{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar AbstractLogger_1 = require(\"./AbstractLogger\");\n/**\n * Logger which buffers all messages, use with care due to possible high memory footprint.\n * Can be convenient in some cases. Call toString() for full output, or cast to this class\n * and call getMessages() to do something with it yourself.\n */\n\n\nvar MessageBufferLoggerImpl = function (_super) {\n  __extends(MessageBufferLoggerImpl, _super);\n\n  function MessageBufferLoggerImpl(name, logGroupRuntimeSettings) {\n    var _this = _super.call(this, name, logGroupRuntimeSettings) || this;\n\n    _this.messages = [];\n    return _this;\n  }\n\n  MessageBufferLoggerImpl.prototype.close = function () {\n    this.messages = [];\n\n    _super.prototype.close.call(this);\n  };\n\n  MessageBufferLoggerImpl.prototype.getMessages = function () {\n    return this.messages;\n  };\n\n  MessageBufferLoggerImpl.prototype.toString = function () {\n    return this.messages.map(function (msg) {\n      return msg;\n    }).join(\"\\n\");\n  };\n\n  MessageBufferLoggerImpl.prototype.doLog = function (message) {\n    var messageFormatter = this._getMessageFormatter();\n\n    var fullMsg;\n\n    if (messageFormatter === null) {\n      fullMsg = this.createDefaultLogMessage(message);\n    } else {\n      fullMsg = messageFormatter(message);\n    }\n\n    this.messages.push(fullMsg);\n  };\n\n  return MessageBufferLoggerImpl;\n}(AbstractLogger_1.AbstractLogger);\n\nexports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;","map":{"version":3,"sources":["../../../../src/logging/log/standard/MessageBufferLoggerImpl.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAGA;;;;AAIG;;;AACH,IAAA,uBAAA,GAAA,UAAA,MAAA,EAAA;AAA6C,EAAA,SAAA,CAAA,uBAAA,EAAA,MAAA,CAAA;;AAI3C,WAAA,uBAAA,CAAY,IAAZ,EAA0B,uBAA1B,EAA0E;AAA1E,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,uBAAZ,KAAoC,IADtC;;AAFQ,IAAA,KAAA,CAAA,QAAA,GAAqB,EAArB;;AAIP;;AAEM,EAAA,uBAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACE,SAAK,QAAL,GAAgB,EAAhB;;AACA,IAAA,MAAA,CAAA,SAAA,CAAM,KAAN,CAAW,IAAX,CAAW,IAAX;AACD,GAHM;;AAKA,EAAA,uBAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACE,WAAO,KAAK,QAAZ;AACD,GAFM;;AAIA,EAAA,uBAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACE,WAAO,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,GAAD,EAAI;AAC3B,aAAO,GAAP;AACD,KAFM,EAEJ,IAFI,CAEC,IAFD,CAAP;AAGD,GAJM;;AAMG,EAAA,uBAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,OAAhB,EAAmC;AACjC,QAAM,gBAAgB,GAAG,KAAK,oBAAL,EAAzB;;AACA,QAAI,OAAJ;;AACA,QAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,MAAA,OAAO,GAAG,KAAK,uBAAL,CAA6B,OAA7B,CAAV;AACD,KAFD,MAGK;AACH,MAAA,OAAO,GAAG,gBAAgB,CAAC,OAAD,CAA1B;AACD;;AACD,SAAK,QAAL,CAAc,IAAd,CAAmB,OAAnB;AACD,GAVS;;AAWZ,SAAA,uBAAA;AAAC,CAlCD,CAA6C,gBAAA,CAAA,cAA7C,CAAA;;AAAa,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractLogger_1 = require(\"./AbstractLogger\");\n/**\n * Logger which buffers all messages, use with care due to possible high memory footprint.\n * Can be convenient in some cases. Call toString() for full output, or cast to this class\n * and call getMessages() to do something with it yourself.\n */\nvar MessageBufferLoggerImpl = (function (_super) {\n    __extends(MessageBufferLoggerImpl, _super);\n    function MessageBufferLoggerImpl(name, logGroupRuntimeSettings) {\n        var _this = _super.call(this, name, logGroupRuntimeSettings) || this;\n        _this.messages = [];\n        return _this;\n    }\n    MessageBufferLoggerImpl.prototype.close = function () {\n        this.messages = [];\n        _super.prototype.close.call(this);\n    };\n    MessageBufferLoggerImpl.prototype.getMessages = function () {\n        return this.messages;\n    };\n    MessageBufferLoggerImpl.prototype.toString = function () {\n        return this.messages.map(function (msg) {\n            return msg;\n        }).join(\"\\n\");\n    };\n    MessageBufferLoggerImpl.prototype.doLog = function (message) {\n        var messageFormatter = this._getMessageFormatter();\n        var fullMsg;\n        if (messageFormatter === null) {\n            fullMsg = this.createDefaultLogMessage(message);\n        }\n        else {\n            fullMsg = messageFormatter(message);\n        }\n        this.messages.push(fullMsg);\n    };\n    return MessageBufferLoggerImpl;\n}(AbstractLogger_1.AbstractLogger));\nexports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;\n//# sourceMappingURL=MessageBufferLoggerImpl.js.map"]},"metadata":{},"sourceType":"script"}