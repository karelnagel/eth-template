{"ast":null,"code":"/*\n\tISC License\n\n\tCopyright (c) 2019, Pierre-Louis Despaigne\n\n\tPermission to use, copy, modify, and/or distribute this software for any\n\tpurpose with or without fee is hereby granted, provided that the above\n\tcopyright notice and this permission notice appear in all copies.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\nconst CID = require('cids');\n\nconst multiH = require('multihashes');\n\nconst base64 = require('js-base64');\n/**\n * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'\n * @param {string} hex an hexadecimal value\n * @return {Buffer} the resulting Buffer\n */\n\n\nconst hexStringToBuffer = hex => {\n  let prefix = hex.slice(0, 2);\n  let value = hex.slice(2);\n  let res = '';\n  if (prefix === '0x') res = value;else res = hex;\n  return multiH.fromHexString(res);\n};\n/**\n * Validates IPNS identifier  to safeguard against insecure names.\n * @param {CID} name ised in ipns-ns\n * @return {bool}\n */\n\n\nconst isCryptographicIPNS = cid => {\n  try {\n    const {\n      multihash\n    } = cid; // Additional check for identifiers shorter\n    // than what inlined ED25519 pubkey would be\n    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950\n\n    if (multihash.length < 38) {\n      const mh = multiH.decode(multihash); // ED25519 pubkeys are inlined using identity hash function\n      // and we should not see anything shorter than that\n\n      if (mh.name === 'identity' && mh.length < 36) {\n        // One can read inlined string value via:\n        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))\n        return false;\n      }\n    } // ok, CID looks fine\n\n\n    return true;\n  } catch (_) {\n    return false;\n  }\n};\n/**\n* list of known encoding,\n* encoding should be a function that takes a `string` input,\n* and return a `Buffer` result\n*/\n\n\nconst encodes = {\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  skynet: value => {\n    return base64.toUint8Array(value);\n  },\n\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  swarm: value => {\n    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');\n    return new CID(1, 'swarm-manifest', multihash).bytes;\n  },\n\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  ipfs: value => {\n    return new CID(value).toV1().bytes;\n  },\n\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  ipns: value => {\n    const cid = new CID(value);\n\n    if (!isCryptographicIPNS(cid)) {\n      throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead');\n    } // Represent IPNS name as a CID with libp2p-key codec\n    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md\n\n\n    return new CID(1, 'libp2p-key', cid.multihash).bytes;\n  },\n\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  utf8: value => {\n    return Buffer.from(value, 'utf8');\n  },\n\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  arweave: value => {\n    return base64.toUint8Array(value);\n  }\n};\n/** \n* list of known decoding,\n* decoding should be a function that takes a `Buffer` input,\n* and return a `string` result\n*/\n\nconst decodes = {\n  /**\n  * @param {Buffer} value \n  */\n  hexMultiHash: value => {\n    const cid = new CID(value);\n    return multiH.decode(cid.multihash).digest.toString('hex');\n  },\n\n  /**\n  * @param {Buffer} value \n  */\n  ipfs: value => {\n    const cid = new CID(value).toV1();\n    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32');\n  },\n\n  /**\n  * @param {Buffer} value \n  */\n  ipns: value => {\n    const cid = new CID(value).toV1();\n\n    if (!isCryptographicIPNS(cid)) {\n      // Value is not a libp2p-key, return original string\n      console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key');\n      return String(multiH.decode(new CID(value).multihash).digest); // TODO: start throwing an error (after some deprecation period)\n      // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')\n    }\n\n    return cid.toString('base36');\n  },\n\n  /**\n  * @param {Buffer} value \n  */\n  utf8: value => {\n    return value.toString('utf8');\n  },\n  base64: value => {\n    // `true` option makes it URL safe (replaces / and + with - and _ )\n    return base64.fromUint8Array(value, true);\n  }\n};\n/**\n* list of known encoding/decoding for a given codec,\n* `encode` should be chosen among the `encodes` functions\n* `decode` should be chosen among the `decodes` functions\n*/\n\nconst profiles = {\n  'skynet-ns': {\n    encode: encodes.skynet,\n    decode: decodes.base64\n  },\n  'swarm-ns': {\n    encode: encodes.swarm,\n    decode: decodes.hexMultiHash\n  },\n  'ipfs-ns': {\n    encode: encodes.ipfs,\n    decode: decodes.ipfs\n  },\n  'ipns-ns': {\n    encode: encodes.ipns,\n    decode: decodes.ipns\n  },\n  'arweave-ns': {\n    encode: encodes.arweave,\n    decode: decodes.base64\n  },\n  'default': {\n    encode: encodes.utf8,\n    decode: decodes.utf8\n  }\n};\nexports.hexStringToBuffer = hexStringToBuffer;\nexports.profiles = profiles;","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@ensdomains/content-hash/src/profiles.js"],"names":["CID","require","multiH","base64","hexStringToBuffer","hex","prefix","slice","value","res","fromHexString","isCryptographicIPNS","cid","multihash","length","mh","decode","name","_","encodes","skynet","toUint8Array","swarm","encode","bytes","ipfs","toV1","ipns","Error","utf8","Buffer","from","arweave","decodes","hexMultiHash","digest","toString","codec","console","warn","String","fromUint8Array","profiles","exports"],"mappings":"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","sourcesContent":["/*\n\tISC License\n\n\tCopyright (c) 2019, Pierre-Louis Despaigne\n\n\tPermission to use, copy, modify, and/or distribute this software for any\n\tpurpose with or without fee is hereby granted, provided that the above\n\tcopyright notice and this permission notice appear in all copies.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\nconst CID = require('cids');\nconst multiH = require('multihashes');\nconst base64 = require('js-base64')\n\n/**\n * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'\n * @param {string} hex an hexadecimal value\n * @return {Buffer} the resulting Buffer\n */\nconst hexStringToBuffer = (hex) => {\n\tlet prefix = hex.slice(0, 2);\n\tlet value = hex.slice(2);\n\tlet res = '';\n\tif (prefix === '0x') res = value;\n\telse res = hex;\n\treturn multiH.fromHexString(res);\n}\n\n/**\n * Validates IPNS identifier  to safeguard against insecure names.\n * @param {CID} name ised in ipns-ns\n * @return {bool}\n */\nconst isCryptographicIPNS =  (cid) => {\n  try {\n    const { multihash } = cid\n    // Additional check for identifiers shorter\n    // than what inlined ED25519 pubkey would be\n    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950\n    if (multihash.length < 38) {\n      const mh = multiH.decode(multihash)\n      // ED25519 pubkeys are inlined using identity hash function\n      // and we should not see anything shorter than that\n      if (mh.name === 'identity' && mh.length < 36) {\n        // One can read inlined string value via:\n        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))\n        return false\n      }\n    }\n    // ok, CID looks fine\n    return true\n  } catch (_) { return false }\n}\n\n/**\n* list of known encoding,\n* encoding should be a function that takes a `string` input,\n* and return a `Buffer` result\n*/\nconst encodes = {\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  skynet: (value) => {\n    return base64.toUint8Array(value)\n  },\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  swarm: (value) => {\n    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');\n\t\treturn new CID(1, 'swarm-manifest', multihash).bytes;\n  },\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  ipfs: (value) => {\n    return new CID(value).toV1().bytes;\n  },\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  ipns: (value) => {\n    const cid = new CID(value)\n    if (!isCryptographicIPNS(cid)) {\n        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')\n    }\n    // Represent IPNS name as a CID with libp2p-key codec\n    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md\n    return new CID(1, 'libp2p-key', cid.multihash).bytes\n  },\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  utf8: (value) => {\n    return Buffer.from(value, 'utf8');\n  },\n  /**\n  * @param {string} value\n  * @return {Buffer}\n  */\n  arweave: (value) => {\n    return base64.toUint8Array(value)\n  },\n};\n\n/** \n* list of known decoding,\n* decoding should be a function that takes a `Buffer` input,\n* and return a `string` result\n*/\nconst decodes = {\n  /**\n  * @param {Buffer} value \n  */\n  hexMultiHash: (value) => {\n    const cid = new CID(value);\n    return multiH.decode(cid.multihash).digest.toString('hex');\n  },\n  /**\n  * @param {Buffer} value \n  */\n  ipfs: (value) => {\n    const cid = new CID(value).toV1();\n    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')\n  },\n  /**\n  * @param {Buffer} value \n  */\n  ipns: (value) => {\n    const cid = new CID(value).toV1()\n    if (!isCryptographicIPNS(cid)) {\n        // Value is not a libp2p-key, return original string\n        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')\n        return String(multiH.decode(new CID(value).multihash).digest)\n        // TODO: start throwing an error (after some deprecation period)\n        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')\n    }\n    return cid.toString('base36')\n  },\n  /**\n  * @param {Buffer} value \n  */\n  utf8: (value) => {\n    return value.toString('utf8');\n  },\n  base64: (value) => {\n    // `true` option makes it URL safe (replaces / and + with - and _ )\n    return base64.fromUint8Array(value, true)\n  }\n};\n\n/**\n* list of known encoding/decoding for a given codec,\n* `encode` should be chosen among the `encodes` functions\n* `decode` should be chosen among the `decodes` functions\n*/\nconst profiles = {\n  'skynet-ns': {\n    encode: encodes.skynet,\n    decode: decodes.base64,\n  },\n  'swarm-ns': {\n    encode: encodes.swarm,\n    decode: decodes.hexMultiHash,\n  },\n  'ipfs-ns': {\n    encode: encodes.ipfs,\n    decode: decodes.ipfs,\n  },\n  'ipns-ns': {\n    encode: encodes.ipns,\n    decode: decodes.ipns,\n  },\n  'arweave-ns': {\n    encode: encodes.arweave,\n    decode: decodes.base64,\n  },\n  'default': {\n    encode: encodes.utf8,\n    decode: decodes.utf8,\n  },\n};\n\nexports.hexStringToBuffer = hexStringToBuffer;\nexports.profiles = profiles;\n"]},"metadata":{},"sourceType":"script"}