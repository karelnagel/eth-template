{"ast":null,"code":"'use strict';\n\nconst Buffer = require('buffer').Buffer;\n\nconst types = require('./types');\n\nconst rcodes = require('./rcodes');\n\nconst opcodes = require('./opcodes');\n\nconst classes = require('./classes');\n\nconst optioncodes = require('./optioncodes');\n\nconst ip = require('@leichtgewicht/ip-codec');\n\nconst QUERY_FLAG = 0;\nconst RESPONSE_FLAG = 1 << 15;\nconst FLUSH_MASK = 1 << 15;\nconst NOT_FLUSH_MASK = ~FLUSH_MASK;\nconst QU_MASK = 1 << 15;\nconst NOT_QU_MASK = ~QU_MASK;\nconst name = exports.name = {};\n\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.alloc(name.encodingLength(str));\n  if (!offset) offset = 0;\n  const oldOffset = offset; // strip leading and trailing .\n\n  const n = str.replace(/^\\.|\\.$/gm, '');\n\n  if (n.length) {\n    const list = n.split('.');\n\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1);\n      buf[offset] = len;\n      offset += len + 1;\n    }\n  }\n\n  buf[offset++] = 0;\n  name.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nname.encode.bytes = 0;\n\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const list = [];\n  let oldOffset = offset;\n  let totalLength = 0;\n  let consumedBytes = 0;\n  let jumped = false;\n\n  while (true) {\n    if (offset >= buf.length) {\n      throw new Error('Cannot decode name (buffer overflow)');\n    }\n\n    const len = buf[offset++];\n    consumedBytes += jumped ? 0 : 1;\n\n    if (len === 0) {\n      break;\n    } else if ((len & 0xc0) === 0) {\n      if (offset + len > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)');\n      }\n\n      totalLength += len + 1;\n\n      if (totalLength > 254) {\n        throw new Error('Cannot decode name (name too long)');\n      }\n\n      list.push(buf.toString('utf-8', offset, offset + len));\n      offset += len;\n      consumedBytes += jumped ? 0 : len;\n    } else if ((len & 0xc0) === 0xc0) {\n      if (offset + 1 > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)');\n      }\n\n      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000;\n\n      if (jumpOffset >= oldOffset) {\n        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:\n        // \"[...] an entire domain name or a list of labels at the end of a domain name\n        // is replaced with a pointer to a prior occurance (sic) of the same name.\"\n        throw new Error('Cannot decode name (bad pointer)');\n      }\n\n      offset = jumpOffset;\n      oldOffset = jumpOffset;\n      consumedBytes += jumped ? 0 : 1;\n      jumped = true;\n    } else {\n      throw new Error('Cannot decode name (bad label)');\n    }\n  }\n\n  name.decode.bytes = consumedBytes;\n  return list.length === 0 ? '.' : list.join('.');\n};\n\nname.decode.bytes = 0;\n\nname.encodingLength = function (n) {\n  if (n === '.' || n === '..') return 1;\n  return Buffer.byteLength(n.replace(/^\\.|\\.$/gm, '')) + 2;\n};\n\nconst string = {};\n\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.alloc(string.encodingLength(s));\n  if (!offset) offset = 0;\n  const len = buf.write(s, offset + 1);\n  buf[offset] = len;\n  string.encode.bytes = len + 1;\n  return buf;\n};\n\nstring.encode.bytes = 0;\n\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf[offset];\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len);\n  string.decode.bytes = len + 1;\n  return s;\n};\n\nstring.decode.bytes = 0;\n\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1;\n};\n\nconst header = {};\n\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h);\n  if (!offset) offset = 0;\n  const flags = (h.flags || 0) & 32767;\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG;\n  buf.writeUInt16BE(h.id || 0, offset);\n  buf.writeUInt16BE(flags | type, offset + 2);\n  buf.writeUInt16BE(h.questions.length, offset + 4);\n  buf.writeUInt16BE(h.answers.length, offset + 6);\n  buf.writeUInt16BE(h.authorities.length, offset + 8);\n  buf.writeUInt16BE(h.additionals.length, offset + 10);\n  return buf;\n};\n\nheader.encode.bytes = 12;\n\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  if (buf.length < 12) throw new Error('Header must be 12 bytes');\n  const flags = buf.readUInt16BE(offset + 2);\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: (flags >> 15 & 0x1) === 1,\n    opcode: opcodes.toString(flags >> 11 & 0xf),\n    flag_aa: (flags >> 10 & 0x1) === 1,\n    flag_tc: (flags >> 9 & 0x1) === 1,\n    flag_rd: (flags >> 8 & 0x1) === 1,\n    flag_ra: (flags >> 7 & 0x1) === 1,\n    flag_z: (flags >> 6 & 0x1) === 1,\n    flag_ad: (flags >> 5 & 0x1) === 1,\n    flag_cd: (flags >> 4 & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  };\n};\n\nheader.decode.bytes = 12;\n\nheader.encodingLength = function () {\n  return 12;\n};\n\nconst runknown = exports.unknown = {};\n\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(data.length, offset);\n  data.copy(buf, offset + 2);\n  runknown.encode.bytes = data.length + 2;\n  return buf;\n};\n\nrunknown.encode.bytes = 0;\n\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const data = buf.slice(offset + 2, offset + 2 + len);\n  runknown.decode.bytes = len + 2;\n  return data;\n};\n\nrunknown.decode.bytes = 0;\n\nrunknown.encodingLength = function (data) {\n  return data.length + 2;\n};\n\nconst rns = exports.ns = {};\n\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rns.encodingLength(data));\n  if (!offset) offset = 0;\n  name.encode(data, buf, offset + 2);\n  buf.writeUInt16BE(name.encode.bytes, offset);\n  rns.encode.bytes = name.encode.bytes + 2;\n  return buf;\n};\n\nrns.encode.bytes = 0;\n\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const dd = name.decode(buf, offset + 2);\n  rns.decode.bytes = len + 2;\n  return dd;\n};\n\nrns.decode.bytes = 0;\n\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2;\n};\n\nconst rsoa = exports.soa = {};\n\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  name.encode(data.mname, buf, offset);\n  offset += name.encode.bytes;\n  name.encode(data.rname, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt32BE(data.serial || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.refresh || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.retry || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.expire || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.minimum || 0, offset);\n  offset += 4;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rsoa.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrsoa.encode.bytes = 0;\n\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.mname = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  data.rname = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  data.serial = buf.readUInt32BE(offset);\n  offset += 4;\n  data.refresh = buf.readUInt32BE(offset);\n  offset += 4;\n  data.retry = buf.readUInt32BE(offset);\n  offset += 4;\n  data.expire = buf.readUInt32BE(offset);\n  offset += 4;\n  data.minimum = buf.readUInt32BE(offset);\n  offset += 4;\n  rsoa.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrsoa.decode.bytes = 0;\n\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname);\n};\n\nconst rtxt = exports.txt = {};\n\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data];\n\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i]);\n    }\n\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer');\n    }\n  }\n\n  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  data.forEach(function (d) {\n    buf[offset++] = d.length;\n    d.copy(buf, offset, 0, d.length);\n    offset += d.length;\n  });\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rtxt.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrtxt.encode.bytes = 0;\n\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  let remaining = buf.readUInt16BE(offset);\n  offset += 2;\n  let data = [];\n\n  while (remaining > 0) {\n    const len = buf[offset++];\n    --remaining;\n\n    if (remaining < len) {\n      throw new Error('Buffer overflow');\n    }\n\n    data.push(buf.slice(offset, offset + len));\n    offset += len;\n    remaining -= len;\n  }\n\n  rtxt.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrtxt.decode.bytes = 0;\n\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data];\n  let length = 2;\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1;\n    } else {\n      length += buf.length + 1;\n    }\n  });\n  return length;\n};\n\nconst rnull = exports.null = {};\n\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data));\n  if (!offset) offset = 0;\n  if (typeof data === 'string') data = Buffer.from(data);\n  if (!data) data = Buffer.alloc(0);\n  const oldOffset = offset;\n  offset += 2;\n  const len = data.length;\n  data.copy(buf, offset, 0, len);\n  offset += len;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rnull.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrnull.encode.bytes = 0;\n\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  const data = buf.slice(offset, offset + len);\n  offset += len;\n  rnull.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrnull.decode.bytes = 0;\n\nrnull.encodingLength = function (data) {\n  if (!data) return 2;\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2;\n};\n\nconst rhinfo = exports.hinfo = {};\n\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  string.encode(data.cpu, buf, offset);\n  offset += string.encode.bytes;\n  string.encode(data.os, buf, offset);\n  offset += string.encode.bytes;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rhinfo.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrhinfo.encode.bytes = 0;\n\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.cpu = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.os = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  rhinfo.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrhinfo.decode.bytes = 0;\n\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2;\n};\n\nconst rptr = exports.ptr = {};\nconst rcname = exports.cname = rptr;\nconst rdname = exports.dname = rptr;\n\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data));\n  if (!offset) offset = 0;\n  name.encode(data, buf, offset + 2);\n  buf.writeUInt16BE(name.encode.bytes, offset);\n  rptr.encode.bytes = name.encode.bytes + 2;\n  return buf;\n};\n\nrptr.encode.bytes = 0;\n\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const data = name.decode(buf, offset + 2);\n  rptr.decode.bytes = name.decode.bytes + 2;\n  return data;\n};\n\nrptr.decode.bytes = 0;\n\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2;\n};\n\nconst rsrv = exports.srv = {};\n\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(data.priority || 0, offset + 2);\n  buf.writeUInt16BE(data.weight || 0, offset + 4);\n  buf.writeUInt16BE(data.port || 0, offset + 6);\n  name.encode(data.target, buf, offset + 8);\n  const len = name.encode.bytes + 6;\n  buf.writeUInt16BE(len, offset);\n  rsrv.encode.bytes = len + 2;\n  return buf;\n};\n\nrsrv.encode.bytes = 0;\n\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const data = {};\n  data.priority = buf.readUInt16BE(offset + 2);\n  data.weight = buf.readUInt16BE(offset + 4);\n  data.port = buf.readUInt16BE(offset + 6);\n  data.target = name.decode(buf, offset + 8);\n  rsrv.decode.bytes = len + 2;\n  return data;\n};\n\nrsrv.decode.bytes = 0;\n\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target);\n};\n\nconst rcaa = exports.caa = {};\nrcaa.ISSUER_CRITICAL = 1 << 7;\n\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data);\n  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data));\n  if (!offset) offset = 0;\n\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL;\n  }\n\n  buf.writeUInt16BE(len - 2, offset);\n  offset += 2;\n  buf.writeUInt8(data.flags || 0, offset);\n  offset += 1;\n  string.encode(data.tag, buf, offset);\n  offset += string.encode.bytes;\n  buf.write(data.value, offset);\n  offset += Buffer.byteLength(data.value);\n  rcaa.encode.bytes = len;\n  return buf;\n};\n\nrcaa.encode.bytes = 0;\n\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  const oldOffset = offset;\n  const data = {};\n  data.flags = buf.readUInt8(offset);\n  offset += 1;\n  data.tag = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.value = buf.toString('utf-8', offset, oldOffset + len);\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL);\n  rcaa.decode.bytes = len + 2;\n  return data;\n};\n\nrcaa.decode.bytes = 0;\n\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2;\n};\n\nconst rmx = exports.mx = {};\n\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  buf.writeUInt16BE(data.preference || 0, offset);\n  offset += 2;\n  name.encode(data.exchange, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rmx.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrmx.encode.bytes = 0;\n\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.preference = buf.readUInt16BE(offset);\n  offset += 2;\n  data.exchange = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  rmx.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange);\n};\n\nconst ra = exports.a = {};\n\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ra.encodingLength(host));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(4, offset);\n  offset += 2;\n  ip.v4.encode(host, buf, offset);\n  ra.encode.bytes = 6;\n  return buf;\n};\n\nra.encode.bytes = 0;\n\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  offset += 2;\n  const host = ip.v4.decode(buf, offset);\n  ra.decode.bytes = 6;\n  return host;\n};\n\nra.decode.bytes = 0;\n\nra.encodingLength = function () {\n  return 6;\n};\n\nconst raaaa = exports.aaaa = {};\n\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(16, offset);\n  offset += 2;\n  ip.v6.encode(host, buf, offset);\n  raaaa.encode.bytes = 18;\n  return buf;\n};\n\nraaaa.encode.bytes = 0;\n\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  offset += 2;\n  const host = ip.v6.decode(buf, offset);\n  raaaa.decode.bytes = 18;\n  return host;\n};\n\nraaaa.decode.bytes = 0;\n\nraaaa.encodingLength = function () {\n  return 18;\n};\n\nconst roption = exports.option = {};\n\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.alloc(roption.encodingLength(option));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const code = optioncodes.toCode(option.code);\n  buf.writeUInt16BE(code, offset);\n  offset += 2;\n\n  if (option.data) {\n    buf.writeUInt16BE(option.data.length, offset);\n    offset += 2;\n    option.data.copy(buf, offset);\n    offset += option.data.length;\n  } else {\n    switch (code) {\n      // case 3: NSID.  No encode makes sense.\n      // case 5,6,7: Not implementable\n      case 8:\n        // ECS\n        // note: do IP math before calling\n        const spl = option.sourcePrefixLength || 0;\n        const fam = option.family || ip.familyOf(option.ip);\n        const ipBuf = ip.encode(option.ip, Buffer.alloc);\n        const ipLen = Math.ceil(spl / 8);\n        buf.writeUInt16BE(ipLen + 4, offset);\n        offset += 2;\n        buf.writeUInt16BE(fam, offset);\n        offset += 2;\n        buf.writeUInt8(spl, offset++);\n        buf.writeUInt8(option.scopePrefixLength || 0, offset++);\n        ipBuf.copy(buf, offset, 0, ipLen);\n        offset += ipLen;\n        break;\n      // case 9: EXPIRE (experimental)\n      // case 10: COOKIE.  No encode makes sense.\n\n      case 11:\n        // KEEP-ALIVE\n        if (option.timeout) {\n          buf.writeUInt16BE(2, offset);\n          offset += 2;\n          buf.writeUInt16BE(option.timeout, offset);\n          offset += 2;\n        } else {\n          buf.writeUInt16BE(0, offset);\n          offset += 2;\n        }\n\n        break;\n\n      case 12:\n        // PADDING\n        const len = option.length || 0;\n        buf.writeUInt16BE(len, offset);\n        offset += 2;\n        buf.fill(0, offset, offset + len);\n        offset += len;\n        break;\n      // case 13:  CHAIN.  Experimental.\n\n      case 14:\n        // KEY-TAG\n        const tagsLen = option.tags.length * 2;\n        buf.writeUInt16BE(tagsLen, offset);\n        offset += 2;\n\n        for (const tag of option.tags) {\n          buf.writeUInt16BE(tag, offset);\n          offset += 2;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unknown roption code: ${option.code}`);\n    }\n  }\n\n  roption.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nroption.encode.bytes = 0;\n\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const option = {};\n  option.code = buf.readUInt16BE(offset);\n  option.type = optioncodes.toString(option.code);\n  offset += 2;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  option.data = buf.slice(offset, offset + len);\n\n  switch (option.code) {\n    // case 3: NSID.  No decode makes sense.\n    case 8:\n      // ECS\n      option.family = buf.readUInt16BE(offset);\n      offset += 2;\n      option.sourcePrefixLength = buf.readUInt8(offset++);\n      option.scopePrefixLength = buf.readUInt8(offset++);\n      const padded = Buffer.alloc(option.family === 1 ? 4 : 16);\n      buf.copy(padded, 0, offset, offset + len - 4);\n      option.ip = ip.decode(padded);\n      break;\n    // case 12: Padding.  No decode makes sense.\n\n    case 11:\n      // KEEP-ALIVE\n      if (len > 0) {\n        option.timeout = buf.readUInt16BE(offset);\n        offset += 2;\n      }\n\n      break;\n\n    case 14:\n      option.tags = [];\n\n      for (let i = 0; i < len; i += 2) {\n        option.tags.push(buf.readUInt16BE(offset));\n        offset += 2;\n      }\n\n    // don't worry about default.  caller will use data if desired\n  }\n\n  roption.decode.bytes = len + 4;\n  return option;\n};\n\nroption.decode.bytes = 0;\n\nroption.encodingLength = function (option) {\n  if (option.data) {\n    return option.data.length + 4;\n  }\n\n  const code = optioncodes.toCode(option.code);\n\n  switch (code) {\n    case 8:\n      // ECS\n      const spl = option.sourcePrefixLength || 0;\n      return Math.ceil(spl / 8) + 8;\n\n    case 11:\n      // KEEP-ALIVE\n      return typeof option.timeout === 'number' ? 6 : 4;\n\n    case 12:\n      // PADDING\n      return option.length + 4;\n\n    case 14:\n      // KEY-TAG\n      return 4 + option.tags.length * 2;\n  }\n\n  throw new Error(`Unknown roption code: ${option.code}`);\n};\n\nconst ropt = exports.opt = {};\n\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ropt.encodingLength(options));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const rdlen = encodingLengthList(options, roption);\n  buf.writeUInt16BE(rdlen, offset);\n  offset = encodeList(options, roption, buf, offset + 2);\n  ropt.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nropt.encode.bytes = 0;\n\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const options = [];\n  let rdlen = buf.readUInt16BE(offset);\n  offset += 2;\n  let o = 0;\n\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset);\n    offset += roption.decode.bytes;\n    rdlen -= roption.decode.bytes;\n  }\n\n  ropt.decode.bytes = offset - oldOffset;\n  return options;\n};\n\nropt.decode.bytes = 0;\n\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption);\n};\n\nconst rdnskey = exports.dnskey = {};\nrdnskey.PROTOCOL_DNSSEC = 3;\nrdnskey.ZONE_KEY = 0x80;\nrdnskey.SECURE_ENTRYPOINT = 0x8000;\n\nrdnskey.encode = function (key, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rdnskey.encodingLength(key));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const keydata = key.key;\n\n  if (!Buffer.isBuffer(keydata)) {\n    throw new Error('Key must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt16BE(key.flags, offset);\n  offset += 2;\n  buf.writeUInt8(rdnskey.PROTOCOL_DNSSEC, offset);\n  offset += 1;\n  buf.writeUInt8(key.algorithm, offset);\n  offset += 1;\n  keydata.copy(buf, offset, 0, keydata.length);\n  offset += keydata.length;\n  rdnskey.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rdnskey.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrdnskey.encode.bytes = 0;\n\nrdnskey.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var key = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  key.flags = buf.readUInt16BE(offset);\n  offset += 2;\n\n  if (buf.readUInt8(offset) !== rdnskey.PROTOCOL_DNSSEC) {\n    throw new Error('Protocol must be 3');\n  }\n\n  offset += 1;\n  key.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  key.key = buf.slice(offset, oldOffset + length + 2);\n  offset += key.key.length;\n  rdnskey.decode.bytes = offset - oldOffset;\n  return key;\n};\n\nrdnskey.decode.bytes = 0;\n\nrdnskey.encodingLength = function (key) {\n  return 6 + Buffer.byteLength(key.key);\n};\n\nconst rrrsig = exports.rrsig = {};\n\nrrrsig.encode = function (sig, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrrsig.encodingLength(sig));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const signature = sig.signature;\n\n  if (!Buffer.isBuffer(signature)) {\n    throw new Error('Signature must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt16BE(types.toType(sig.typeCovered), offset);\n  offset += 2;\n  buf.writeUInt8(sig.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(sig.labels, offset);\n  offset += 1;\n  buf.writeUInt32BE(sig.originalTTL, offset);\n  offset += 4;\n  buf.writeUInt32BE(sig.expiration, offset);\n  offset += 4;\n  buf.writeUInt32BE(sig.inception, offset);\n  offset += 4;\n  buf.writeUInt16BE(sig.keyTag, offset);\n  offset += 2;\n  name.encode(sig.signersName, buf, offset);\n  offset += name.encode.bytes;\n  signature.copy(buf, offset, 0, signature.length);\n  offset += signature.length;\n  rrrsig.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rrrsig.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrrrsig.encode.bytes = 0;\n\nrrrsig.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var sig = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  sig.typeCovered = types.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  sig.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  sig.labels = buf.readUInt8(offset);\n  offset += 1;\n  sig.originalTTL = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.expiration = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.inception = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.keyTag = buf.readUInt16BE(offset);\n  offset += 2;\n  sig.signersName = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  sig.signature = buf.slice(offset, oldOffset + length + 2);\n  offset += sig.signature.length;\n  rrrsig.decode.bytes = offset - oldOffset;\n  return sig;\n};\n\nrrrsig.decode.bytes = 0;\n\nrrrsig.encodingLength = function (sig) {\n  return 20 + name.encodingLength(sig.signersName) + Buffer.byteLength(sig.signature);\n};\n\nconst rrp = exports.rp = {};\n\nrrp.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrp.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // Leave space for length\n\n  name.encode(data.mbox || '.', buf, offset);\n  offset += name.encode.bytes;\n  name.encode(data.txt || '.', buf, offset);\n  offset += name.encode.bytes;\n  rrp.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rrp.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrrp.encode.bytes = 0;\n\nrrp.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.mbox = name.decode(buf, offset) || '.';\n  offset += name.decode.bytes;\n  data.txt = name.decode(buf, offset) || '.';\n  offset += name.decode.bytes;\n  rrp.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrrp.decode.bytes = 0;\n\nrrp.encodingLength = function (data) {\n  return 2 + name.encodingLength(data.mbox || '.') + name.encodingLength(data.txt || '.');\n};\n\nconst typebitmap = {};\n\ntypebitmap.encode = function (typelist, buf, offset) {\n  if (!buf) buf = Buffer.alloc(typebitmap.encodingLength(typelist));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var typesByWindow = [];\n\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i]);\n\n    if (typesByWindow[typeid >> 8] === undefined) {\n      typesByWindow[typeid >> 8] = [];\n    }\n\n    typesByWindow[typeid >> 8][typeid >> 3 & 0x1F] |= 1 << 7 - (typeid & 0x7);\n  }\n\n  for (i = 0; i < typesByWindow.length; i++) {\n    if (typesByWindow[i] !== undefined) {\n      var windowBuf = Buffer.from(typesByWindow[i]);\n      buf.writeUInt8(i, offset);\n      offset += 1;\n      buf.writeUInt8(windowBuf.length, offset);\n      offset += 1;\n      windowBuf.copy(buf, offset);\n      offset += windowBuf.length;\n    }\n  }\n\n  typebitmap.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\ntypebitmap.encode.bytes = 0;\n\ntypebitmap.decode = function (buf, offset, length) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var typelist = [];\n\n  while (offset - oldOffset < length) {\n    var window = buf.readUInt8(offset);\n    offset += 1;\n    var windowLength = buf.readUInt8(offset);\n    offset += 1;\n\n    for (var i = 0; i < windowLength; i++) {\n      var b = buf.readUInt8(offset + i);\n\n      for (var j = 0; j < 8; j++) {\n        if (b & 1 << 7 - j) {\n          var typeid = types.toString(window << 8 | i << 3 | j);\n          typelist.push(typeid);\n        }\n      }\n    }\n\n    offset += windowLength;\n  }\n\n  typebitmap.decode.bytes = offset - oldOffset;\n  return typelist;\n};\n\ntypebitmap.decode.bytes = 0;\n\ntypebitmap.encodingLength = function (typelist) {\n  var extents = [];\n\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i]);\n    extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 0xFF);\n  }\n\n  var len = 0;\n\n  for (i = 0; i < extents.length; i++) {\n    if (extents[i] !== undefined) {\n      len += 2 + Math.ceil((extents[i] + 1) / 8);\n    }\n  }\n\n  return len;\n};\n\nconst rnsec = exports.nsec = {};\n\nrnsec.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // Leave space for length\n\n  name.encode(record.nextDomain, buf, offset);\n  offset += name.encode.bytes;\n  typebitmap.encode(record.rrtypes, buf, offset);\n  offset += typebitmap.encode.bytes;\n  rnsec.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnsec.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrnsec.encode.bytes = 0;\n\nrnsec.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var record = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  record.nextDomain = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset));\n  offset += typebitmap.decode.bytes;\n  rnsec.decode.bytes = offset - oldOffset;\n  return record;\n};\n\nrnsec.decode.bytes = 0;\n\nrnsec.encodingLength = function (record) {\n  return 2 + name.encodingLength(record.nextDomain) + typebitmap.encodingLength(record.rrtypes);\n};\n\nconst rnsec3 = exports.nsec3 = {};\n\nrnsec3.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec3.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const salt = record.salt;\n\n  if (!Buffer.isBuffer(salt)) {\n    throw new Error('salt must be a Buffer');\n  }\n\n  const nextDomain = record.nextDomain;\n\n  if (!Buffer.isBuffer(nextDomain)) {\n    throw new Error('nextDomain must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt8(record.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(record.flags, offset);\n  offset += 1;\n  buf.writeUInt16BE(record.iterations, offset);\n  offset += 2;\n  buf.writeUInt8(salt.length, offset);\n  offset += 1;\n  salt.copy(buf, offset, 0, salt.length);\n  offset += salt.length;\n  buf.writeUInt8(nextDomain.length, offset);\n  offset += 1;\n  nextDomain.copy(buf, offset, 0, nextDomain.length);\n  offset += nextDomain.length;\n  typebitmap.encode(record.rrtypes, buf, offset);\n  offset += typebitmap.encode.bytes;\n  rnsec3.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrnsec3.encode.bytes = 0;\n\nrnsec3.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var record = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  record.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  record.flags = buf.readUInt8(offset);\n  offset += 1;\n  record.iterations = buf.readUInt16BE(offset);\n  offset += 2;\n  const saltLength = buf.readUInt8(offset);\n  offset += 1;\n  record.salt = buf.slice(offset, offset + saltLength);\n  offset += saltLength;\n  const hashLength = buf.readUInt8(offset);\n  offset += 1;\n  record.nextDomain = buf.slice(offset, offset + hashLength);\n  offset += hashLength;\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset));\n  offset += typebitmap.decode.bytes;\n  rnsec3.decode.bytes = offset - oldOffset;\n  return record;\n};\n\nrnsec3.decode.bytes = 0;\n\nrnsec3.encodingLength = function (record) {\n  return 8 + record.salt.length + record.nextDomain.length + typebitmap.encodingLength(record.rrtypes);\n};\n\nconst rds = exports.ds = {};\n\nrds.encode = function (digest, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const digestdata = digest.digest;\n\n  if (!Buffer.isBuffer(digestdata)) {\n    throw new Error('Digest must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt16BE(digest.keyTag, offset);\n  offset += 2;\n  buf.writeUInt8(digest.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(digest.digestType, offset);\n  offset += 1;\n  digestdata.copy(buf, offset, 0, digestdata.length);\n  offset += digestdata.length;\n  rds.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrds.encode.bytes = 0;\n\nrds.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var digest = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  digest.keyTag = buf.readUInt16BE(offset);\n  offset += 2;\n  digest.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  digest.digestType = buf.readUInt8(offset);\n  offset += 1;\n  digest.digest = buf.slice(offset, oldOffset + length + 2);\n  offset += digest.digest.length;\n  rds.decode.bytes = offset - oldOffset;\n  return digest;\n};\n\nrds.decode.bytes = 0;\n\nrds.encodingLength = function (digest) {\n  return 6 + Buffer.byteLength(digest.digest);\n};\n\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A':\n      return ra;\n\n    case 'PTR':\n      return rptr;\n\n    case 'CNAME':\n      return rcname;\n\n    case 'DNAME':\n      return rdname;\n\n    case 'TXT':\n      return rtxt;\n\n    case 'NULL':\n      return rnull;\n\n    case 'AAAA':\n      return raaaa;\n\n    case 'SRV':\n      return rsrv;\n\n    case 'HINFO':\n      return rhinfo;\n\n    case 'CAA':\n      return rcaa;\n\n    case 'NS':\n      return rns;\n\n    case 'SOA':\n      return rsoa;\n\n    case 'MX':\n      return rmx;\n\n    case 'OPT':\n      return ropt;\n\n    case 'DNSKEY':\n      return rdnskey;\n\n    case 'RRSIG':\n      return rrrsig;\n\n    case 'RP':\n      return rrp;\n\n    case 'NSEC':\n      return rnsec;\n\n    case 'NSEC3':\n      return rnsec3;\n\n    case 'DS':\n      return rds;\n  }\n\n  return runknown;\n};\n\nconst answer = exports.answer = {};\n\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.alloc(answer.encodingLength(a));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  name.encode(a.name, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(types.toType(a.type), offset);\n\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.');\n    }\n\n    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2);\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4);\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5);\n    buf.writeUInt16BE(a.flags || 0, offset + 6);\n    offset += 8;\n    ropt.encode(a.options || [], buf, offset);\n    offset += ropt.encode.bytes;\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class);\n    if (a.flush) klass |= FLUSH_MASK; // the 1st bit of the class is the flush bit\n\n    buf.writeUInt16BE(klass, offset + 2);\n    buf.writeUInt32BE(a.ttl || 0, offset + 4);\n    offset += 8;\n    const enc = renc(a.type);\n    enc.encode(a.data, buf, offset);\n    offset += enc.encode.bytes;\n  }\n\n  answer.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nanswer.encode.bytes = 0;\n\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const a = {};\n  const oldOffset = offset;\n  a.name = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  a.type = types.toString(buf.readUInt16BE(offset));\n\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2);\n    a.extendedRcode = buf.readUInt8(offset + 4);\n    a.ednsVersion = buf.readUInt8(offset + 5);\n    a.flags = buf.readUInt16BE(offset + 6);\n    a.flag_do = (a.flags >> 15 & 0x1) === 1;\n    a.options = ropt.decode(buf, offset + 8);\n    offset += 8 + ropt.decode.bytes;\n  } else {\n    const klass = buf.readUInt16BE(offset + 2);\n    a.ttl = buf.readUInt32BE(offset + 4);\n    a.class = classes.toString(klass & NOT_FLUSH_MASK);\n    a.flush = !!(klass & FLUSH_MASK);\n    const enc = renc(a.type);\n    a.data = enc.decode(buf, offset + 8);\n    offset += 8 + enc.decode.bytes;\n  }\n\n  answer.decode.bytes = offset - oldOffset;\n  return a;\n};\n\nanswer.decode.bytes = 0;\n\nanswer.encodingLength = function (a) {\n  const data = a.data !== null && a.data !== undefined ? a.data : a.options;\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data);\n};\n\nconst question = exports.question = {};\n\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.alloc(question.encodingLength(q));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  name.encode(q.name, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(types.toType(q.type), offset);\n  offset += 2;\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset);\n  offset += 2;\n  question.encode.bytes = offset - oldOffset;\n  return q;\n};\n\nquestion.encode.bytes = 0;\n\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const q = {};\n  q.name = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  q.type = types.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  q.class = classes.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  const qu = !!(q.class & QU_MASK);\n  if (qu) q.class &= NOT_QU_MASK;\n  question.decode.bytes = offset - oldOffset;\n  return q;\n};\n\nquestion.decode.bytes = 0;\n\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4;\n};\n\nexports.AUTHORITATIVE_ANSWER = 1 << 10;\nexports.TRUNCATED_RESPONSE = 1 << 9;\nexports.RECURSION_DESIRED = 1 << 8;\nexports.RECURSION_AVAILABLE = 1 << 7;\nexports.AUTHENTIC_DATA = 1 << 5;\nexports.CHECKING_DISABLED = 1 << 4;\nexports.DNSSEC_OK = 1 << 15;\n\nexports.encode = function (result, buf, offset) {\n  const allocing = !buf;\n  if (allocing) buf = Buffer.alloc(exports.encodingLength(result));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  if (!result.questions) result.questions = [];\n  if (!result.answers) result.answers = [];\n  if (!result.authorities) result.authorities = [];\n  if (!result.additionals) result.additionals = [];\n  header.encode(result, buf, offset);\n  offset += header.encode.bytes;\n  offset = encodeList(result.questions, question, buf, offset);\n  offset = encodeList(result.answers, answer, buf, offset);\n  offset = encodeList(result.authorities, answer, buf, offset);\n  offset = encodeList(result.additionals, answer, buf, offset);\n  exports.encode.bytes = offset - oldOffset; // just a quick sanity check\n\n  if (allocing && exports.encode.bytes !== buf.length) {\n    return buf.slice(0, exports.encode.bytes);\n  }\n\n  return buf;\n};\n\nexports.encode.bytes = 0;\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const result = header.decode(buf, offset);\n  offset += header.decode.bytes;\n  offset = decodeList(result.questions, question, buf, offset);\n  offset = decodeList(result.answers, answer, buf, offset);\n  offset = decodeList(result.authorities, answer, buf, offset);\n  offset = decodeList(result.additionals, answer, buf, offset);\n  exports.decode.bytes = offset - oldOffset;\n  return result;\n};\n\nexports.decode.bytes = 0;\n\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) + encodingLengthList(result.questions || [], question) + encodingLengthList(result.answers || [], answer) + encodingLengthList(result.authorities || [], answer) + encodingLengthList(result.additionals || [], answer);\n};\n\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result);\n  const sbuf = Buffer.alloc(2);\n  sbuf.writeUInt16BE(buf.byteLength);\n  const combine = Buffer.concat([sbuf, buf]);\n  exports.streamEncode.bytes = combine.byteLength;\n  return combine;\n};\n\nexports.streamEncode.bytes = 0;\n\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0);\n\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null;\n  }\n\n  const result = exports.decode(sbuf.slice(2));\n  exports.streamDecode.bytes = exports.decode.bytes;\n  return result;\n};\n\nexports.streamDecode.bytes = 0;\n\nfunction encodingLengthList(list, enc) {\n  let len = 0;\n\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i]);\n\n  return len;\n}\n\nfunction encodeList(list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset);\n    offset += enc.encode.bytes;\n  }\n\n  return offset;\n}\n\nfunction decodeList(list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset);\n    offset += enc.decode.bytes;\n  }\n\n  return offset;\n}","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/dns-packet/index.js"],"names":["Buffer","require","types","rcodes","opcodes","classes","optioncodes","ip","QUERY_FLAG","RESPONSE_FLAG","FLUSH_MASK","NOT_FLUSH_MASK","QU_MASK","NOT_QU_MASK","name","exports","encode","str","buf","offset","alloc","encodingLength","oldOffset","n","replace","length","list","split","i","len","write","bytes","decode","totalLength","consumedBytes","jumped","Error","push","toString","jumpOffset","readUInt16BE","join","byteLength","string","s","header","h","flags","type","writeUInt16BE","id","questions","answers","authorities","additionals","flag_qr","opcode","flag_aa","flag_tc","flag_rd","flag_ra","flag_z","flag_ad","flag_cd","rcode","Array","runknown","unknown","data","copy","slice","rns","ns","dd","rsoa","soa","mname","rname","writeUInt32BE","serial","refresh","retry","expire","minimum","readUInt32BE","rtxt","txt","isArray","from","isBuffer","forEach","d","remaining","rnull","null","rhinfo","hinfo","cpu","os","rptr","ptr","rcname","cname","rdname","dname","rsrv","srv","priority","weight","port","target","rcaa","caa","ISSUER_CRITICAL","issuerCritical","writeUInt8","tag","value","readUInt8","rmx","mx","preference","exchange","ra","a","host","v4","raaaa","aaaa","v6","roption","option","code","toCode","spl","sourcePrefixLength","fam","family","familyOf","ipBuf","ipLen","Math","ceil","scopePrefixLength","timeout","fill","tagsLen","tags","padded","ropt","opt","options","rdlen","encodingLengthList","encodeList","o","rdnskey","dnskey","PROTOCOL_DNSSEC","ZONE_KEY","SECURE_ENTRYPOINT","key","keydata","algorithm","rrrsig","rrsig","sig","signature","toType","typeCovered","labels","originalTTL","expiration","inception","keyTag","signersName","rrp","rp","mbox","typebitmap","typelist","typesByWindow","typeid","undefined","windowBuf","window","windowLength","b","j","extents","max","rnsec","nsec","record","nextDomain","rrtypes","rnsec3","nsec3","salt","iterations","saltLength","hashLength","rds","ds","digest","digestdata","digestType","renc","toUpperCase","answer","udpPayloadSize","extendedRcode","ednsVersion","klass","toClass","class","flush","ttl","enc","flag_do","question","q","qu","AUTHORITATIVE_ANSWER","TRUNCATED_RESPONSE","RECURSION_DESIRED","RECURSION_AVAILABLE","AUTHENTIC_DATA","CHECKING_DISABLED","DNSSEC_OK","result","allocing","decodeList","streamEncode","sbuf","combine","concat","streamDecode"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Buffer = require('buffer').Buffer\nconst types = require('./types')\nconst rcodes = require('./rcodes')\nconst opcodes = require('./opcodes')\nconst classes = require('./classes')\nconst optioncodes = require('./optioncodes')\nconst ip = require('@leichtgewicht/ip-codec')\n\nconst QUERY_FLAG = 0\nconst RESPONSE_FLAG = 1 << 15\nconst FLUSH_MASK = 1 << 15\nconst NOT_FLUSH_MASK = ~FLUSH_MASK\nconst QU_MASK = 1 << 15\nconst NOT_QU_MASK = ~QU_MASK\n\nconst name = exports.name = {}\n\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.alloc(name.encodingLength(str))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  // strip leading and trailing .\n  const n = str.replace(/^\\.|\\.$/gm, '')\n  if (n.length) {\n    const list = n.split('.')\n\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1)\n      buf[offset] = len\n      offset += len + 1\n    }\n  }\n\n  buf[offset++] = 0\n\n  name.encode.bytes = offset - oldOffset\n  return buf\n}\n\nname.encode.bytes = 0\n\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const list = []\n  let oldOffset = offset\n  let totalLength = 0\n  let consumedBytes = 0\n  let jumped = false\n\n  while (true) {\n    if (offset >= buf.length) {\n      throw new Error('Cannot decode name (buffer overflow)')\n    }\n    const len = buf[offset++]\n    consumedBytes += jumped ? 0 : 1\n\n    if (len === 0) {\n      break\n    } else if ((len & 0xc0) === 0) {\n      if (offset + len > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)')\n      }\n      totalLength += len + 1\n      if (totalLength > 254) {\n        throw new Error('Cannot decode name (name too long)')\n      }\n      list.push(buf.toString('utf-8', offset, offset + len))\n      offset += len\n      consumedBytes += jumped ? 0 : len\n    } else if ((len & 0xc0) === 0xc0) {\n      if (offset + 1 > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)')\n      }\n      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000\n      if (jumpOffset >= oldOffset) {\n        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:\n        // \"[...] an entire domain name or a list of labels at the end of a domain name\n        // is replaced with a pointer to a prior occurance (sic) of the same name.\"\n        throw new Error('Cannot decode name (bad pointer)')\n      }\n      offset = jumpOffset\n      oldOffset = jumpOffset\n      consumedBytes += jumped ? 0 : 1\n      jumped = true\n    } else {\n      throw new Error('Cannot decode name (bad label)')\n    }\n  }\n\n  name.decode.bytes = consumedBytes\n  return list.length === 0 ? '.' : list.join('.')\n}\n\nname.decode.bytes = 0\n\nname.encodingLength = function (n) {\n  if (n === '.' || n === '..') return 1\n  return Buffer.byteLength(n.replace(/^\\.|\\.$/gm, '')) + 2\n}\n\nconst string = {}\n\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.alloc(string.encodingLength(s))\n  if (!offset) offset = 0\n\n  const len = buf.write(s, offset + 1)\n  buf[offset] = len\n  string.encode.bytes = len + 1\n  return buf\n}\n\nstring.encode.bytes = 0\n\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf[offset]\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len)\n  string.decode.bytes = len + 1\n  return s\n}\n\nstring.decode.bytes = 0\n\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1\n}\n\nconst header = {}\n\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h)\n  if (!offset) offset = 0\n\n  const flags = (h.flags || 0) & 32767\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG\n\n  buf.writeUInt16BE(h.id || 0, offset)\n  buf.writeUInt16BE(flags | type, offset + 2)\n  buf.writeUInt16BE(h.questions.length, offset + 4)\n  buf.writeUInt16BE(h.answers.length, offset + 6)\n  buf.writeUInt16BE(h.authorities.length, offset + 8)\n  buf.writeUInt16BE(h.additionals.length, offset + 10)\n\n  return buf\n}\n\nheader.encode.bytes = 12\n\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  if (buf.length < 12) throw new Error('Header must be 12 bytes')\n  const flags = buf.readUInt16BE(offset + 2)\n\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: ((flags >> 15) & 0x1) === 1,\n    opcode: opcodes.toString((flags >> 11) & 0xf),\n    flag_aa: ((flags >> 10) & 0x1) === 1,\n    flag_tc: ((flags >> 9) & 0x1) === 1,\n    flag_rd: ((flags >> 8) & 0x1) === 1,\n    flag_ra: ((flags >> 7) & 0x1) === 1,\n    flag_z: ((flags >> 6) & 0x1) === 1,\n    flag_ad: ((flags >> 5) & 0x1) === 1,\n    flag_cd: ((flags >> 4) & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  }\n}\n\nheader.decode.bytes = 12\n\nheader.encodingLength = function () {\n  return 12\n}\n\nconst runknown = exports.unknown = {}\n\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.length, offset)\n  data.copy(buf, offset + 2)\n\n  runknown.encode.bytes = data.length + 2\n  return buf\n}\n\nrunknown.encode.bytes = 0\n\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const data = buf.slice(offset + 2, offset + 2 + len)\n  runknown.decode.bytes = len + 2\n  return data\n}\n\nrunknown.decode.bytes = 0\n\nrunknown.encodingLength = function (data) {\n  return data.length + 2\n}\n\nconst rns = exports.ns = {}\n\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rns.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rns.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrns.encode.bytes = 0\n\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const dd = name.decode(buf, offset + 2)\n\n  rns.decode.bytes = len + 2\n  return dd\n}\n\nrns.decode.bytes = 0\n\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsoa = exports.soa = {}\n\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  name.encode(data.mname, buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.rname, buf, offset)\n  offset += name.encode.bytes\n  buf.writeUInt32BE(data.serial || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.refresh || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.retry || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.expire || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.minimum || 0, offset)\n  offset += 4\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rsoa.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrsoa.encode.bytes = 0\n\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.rname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.serial = buf.readUInt32BE(offset)\n  offset += 4\n  data.refresh = buf.readUInt32BE(offset)\n  offset += 4\n  data.retry = buf.readUInt32BE(offset)\n  offset += 4\n  data.expire = buf.readUInt32BE(offset)\n  offset += 4\n  data.minimum = buf.readUInt32BE(offset)\n  offset += 4\n\n  rsoa.decode.bytes = offset - oldOffset\n  return data\n}\n\nrsoa.decode.bytes = 0\n\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname)\n}\n\nconst rtxt = exports.txt = {}\n\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data]\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i])\n    }\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer')\n    }\n  }\n\n  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n\n  data.forEach(function (d) {\n    buf[offset++] = d.length\n    d.copy(buf, offset, 0, d.length)\n    offset += d.length\n  })\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rtxt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrtxt.encode.bytes = 0\n\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  let remaining = buf.readUInt16BE(offset)\n  offset += 2\n\n  let data = []\n  while (remaining > 0) {\n    const len = buf[offset++]\n    --remaining\n    if (remaining < len) {\n      throw new Error('Buffer overflow')\n    }\n    data.push(buf.slice(offset, offset + len))\n    offset += len\n    remaining -= len\n  }\n\n  rtxt.decode.bytes = offset - oldOffset\n  return data\n}\n\nrtxt.decode.bytes = 0\n\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data]\n  let length = 2\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1\n    } else {\n      length += buf.length + 1\n    }\n  })\n  return length\n}\n\nconst rnull = exports.null = {}\n\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (typeof data === 'string') data = Buffer.from(data)\n  if (!data) data = Buffer.alloc(0)\n\n  const oldOffset = offset\n  offset += 2\n\n  const len = data.length\n  data.copy(buf, offset, 0, len)\n  offset += len\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rnull.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrnull.encode.bytes = 0\n\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  const len = buf.readUInt16BE(offset)\n\n  offset += 2\n\n  const data = buf.slice(offset, offset + len)\n  offset += len\n\n  rnull.decode.bytes = offset - oldOffset\n  return data\n}\n\nrnull.decode.bytes = 0\n\nrnull.encodingLength = function (data) {\n  if (!data) return 2\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2\n}\n\nconst rhinfo = exports.hinfo = {}\n\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  string.encode(data.cpu, buf, offset)\n  offset += string.encode.bytes\n  string.encode(data.os, buf, offset)\n  offset += string.encode.bytes\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rhinfo.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrhinfo.encode.bytes = 0\n\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.cpu = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.os = string.decode(buf, offset)\n  offset += string.decode.bytes\n  rhinfo.decode.bytes = offset - oldOffset\n  return data\n}\n\nrhinfo.decode.bytes = 0\n\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2\n}\n\nconst rptr = exports.ptr = {}\nconst rcname = exports.cname = rptr\nconst rdname = exports.dname = rptr\n\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rptr.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrptr.encode.bytes = 0\n\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const data = name.decode(buf, offset + 2)\n  rptr.decode.bytes = name.decode.bytes + 2\n  return data\n}\n\nrptr.decode.bytes = 0\n\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsrv = exports.srv = {}\n\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.priority || 0, offset + 2)\n  buf.writeUInt16BE(data.weight || 0, offset + 4)\n  buf.writeUInt16BE(data.port || 0, offset + 6)\n  name.encode(data.target, buf, offset + 8)\n\n  const len = name.encode.bytes + 6\n  buf.writeUInt16BE(len, offset)\n\n  rsrv.encode.bytes = len + 2\n  return buf\n}\n\nrsrv.encode.bytes = 0\n\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n\n  const data = {}\n  data.priority = buf.readUInt16BE(offset + 2)\n  data.weight = buf.readUInt16BE(offset + 4)\n  data.port = buf.readUInt16BE(offset + 6)\n  data.target = name.decode(buf, offset + 8)\n\n  rsrv.decode.bytes = len + 2\n  return data\n}\n\nrsrv.decode.bytes = 0\n\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target)\n}\n\nconst rcaa = exports.caa = {}\n\nrcaa.ISSUER_CRITICAL = 1 << 7\n\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data)\n\n  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL\n  }\n\n  buf.writeUInt16BE(len - 2, offset)\n  offset += 2\n  buf.writeUInt8(data.flags || 0, offset)\n  offset += 1\n  string.encode(data.tag, buf, offset)\n  offset += string.encode.bytes\n  buf.write(data.value, offset)\n  offset += Buffer.byteLength(data.value)\n\n  rcaa.encode.bytes = len\n  return buf\n}\n\nrcaa.encode.bytes = 0\n\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n\n  const oldOffset = offset\n  const data = {}\n  data.flags = buf.readUInt8(offset)\n  offset += 1\n  data.tag = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.value = buf.toString('utf-8', offset, oldOffset + len)\n\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL)\n\n  rcaa.decode.bytes = len + 2\n\n  return data\n}\n\nrcaa.decode.bytes = 0\n\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2\n}\n\nconst rmx = exports.mx = {}\n\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  buf.writeUInt16BE(data.preference || 0, offset)\n  offset += 2\n  name.encode(data.exchange, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rmx.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrmx.encode.bytes = 0\n\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.preference = buf.readUInt16BE(offset)\n  offset += 2\n  data.exchange = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  rmx.decode.bytes = offset - oldOffset\n  return data\n}\n\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange)\n}\n\nconst ra = exports.a = {}\n\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ra.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(4, offset)\n  offset += 2\n  ip.v4.encode(host, buf, offset)\n  ra.encode.bytes = 6\n  return buf\n}\n\nra.encode.bytes = 0\n\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.v4.decode(buf, offset)\n  ra.decode.bytes = 6\n  return host\n}\n\nra.decode.bytes = 0\n\nra.encodingLength = function () {\n  return 6\n}\n\nconst raaaa = exports.aaaa = {}\n\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(16, offset)\n  offset += 2\n  ip.v6.encode(host, buf, offset)\n  raaaa.encode.bytes = 18\n  return buf\n}\n\nraaaa.encode.bytes = 0\n\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.v6.decode(buf, offset)\n  raaaa.decode.bytes = 18\n  return host\n}\n\nraaaa.decode.bytes = 0\n\nraaaa.encodingLength = function () {\n  return 18\n}\n\nconst roption = exports.option = {}\n\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.alloc(roption.encodingLength(option))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const code = optioncodes.toCode(option.code)\n  buf.writeUInt16BE(code, offset)\n  offset += 2\n  if (option.data) {\n    buf.writeUInt16BE(option.data.length, offset)\n    offset += 2\n    option.data.copy(buf, offset)\n    offset += option.data.length\n  } else {\n    switch (code) {\n      // case 3: NSID.  No encode makes sense.\n      // case 5,6,7: Not implementable\n      case 8: // ECS\n        // note: do IP math before calling\n        const spl = option.sourcePrefixLength || 0\n        const fam = option.family || ip.familyOf(option.ip)\n        const ipBuf = ip.encode(option.ip, Buffer.alloc)\n        const ipLen = Math.ceil(spl / 8)\n        buf.writeUInt16BE(ipLen + 4, offset)\n        offset += 2\n        buf.writeUInt16BE(fam, offset)\n        offset += 2\n        buf.writeUInt8(spl, offset++)\n        buf.writeUInt8(option.scopePrefixLength || 0, offset++)\n\n        ipBuf.copy(buf, offset, 0, ipLen)\n        offset += ipLen\n        break\n      // case 9: EXPIRE (experimental)\n      // case 10: COOKIE.  No encode makes sense.\n      case 11: // KEEP-ALIVE\n        if (option.timeout) {\n          buf.writeUInt16BE(2, offset)\n          offset += 2\n          buf.writeUInt16BE(option.timeout, offset)\n          offset += 2\n        } else {\n          buf.writeUInt16BE(0, offset)\n          offset += 2\n        }\n        break\n      case 12: // PADDING\n        const len = option.length || 0\n        buf.writeUInt16BE(len, offset)\n        offset += 2\n        buf.fill(0, offset, offset + len)\n        offset += len\n        break\n      // case 13:  CHAIN.  Experimental.\n      case 14: // KEY-TAG\n        const tagsLen = option.tags.length * 2\n        buf.writeUInt16BE(tagsLen, offset)\n        offset += 2\n        for (const tag of option.tags) {\n          buf.writeUInt16BE(tag, offset)\n          offset += 2\n        }\n        break\n      default:\n        throw new Error(`Unknown roption code: ${option.code}`)\n    }\n  }\n\n  roption.encode.bytes = offset - oldOffset\n  return buf\n}\n\nroption.encode.bytes = 0\n\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const option = {}\n  option.code = buf.readUInt16BE(offset)\n  option.type = optioncodes.toString(option.code)\n  offset += 2\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n  option.data = buf.slice(offset, offset + len)\n  switch (option.code) {\n    // case 3: NSID.  No decode makes sense.\n    case 8: // ECS\n      option.family = buf.readUInt16BE(offset)\n      offset += 2\n      option.sourcePrefixLength = buf.readUInt8(offset++)\n      option.scopePrefixLength = buf.readUInt8(offset++)\n      const padded = Buffer.alloc((option.family === 1) ? 4 : 16)\n      buf.copy(padded, 0, offset, offset + len - 4)\n      option.ip = ip.decode(padded)\n      break\n    // case 12: Padding.  No decode makes sense.\n    case 11: // KEEP-ALIVE\n      if (len > 0) {\n        option.timeout = buf.readUInt16BE(offset)\n        offset += 2\n      }\n      break\n    case 14:\n      option.tags = []\n      for (let i = 0; i < len; i += 2) {\n        option.tags.push(buf.readUInt16BE(offset))\n        offset += 2\n      }\n    // don't worry about default.  caller will use data if desired\n  }\n\n  roption.decode.bytes = len + 4\n  return option\n}\n\nroption.decode.bytes = 0\n\nroption.encodingLength = function (option) {\n  if (option.data) {\n    return option.data.length + 4\n  }\n  const code = optioncodes.toCode(option.code)\n  switch (code) {\n    case 8: // ECS\n      const spl = option.sourcePrefixLength || 0\n      return Math.ceil(spl / 8) + 8\n    case 11: // KEEP-ALIVE\n      return (typeof option.timeout === 'number') ? 6 : 4\n    case 12: // PADDING\n      return option.length + 4\n    case 14: // KEY-TAG\n      return 4 + (option.tags.length * 2)\n  }\n  throw new Error(`Unknown roption code: ${option.code}`)\n}\n\nconst ropt = exports.opt = {}\n\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ropt.encodingLength(options))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const rdlen = encodingLengthList(options, roption)\n  buf.writeUInt16BE(rdlen, offset)\n  offset = encodeList(options, roption, buf, offset + 2)\n\n  ropt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nropt.encode.bytes = 0\n\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const options = []\n  let rdlen = buf.readUInt16BE(offset)\n  offset += 2\n  let o = 0\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset)\n    offset += roption.decode.bytes\n    rdlen -= roption.decode.bytes\n  }\n  ropt.decode.bytes = offset - oldOffset\n  return options\n}\n\nropt.decode.bytes = 0\n\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption)\n}\n\nconst rdnskey = exports.dnskey = {}\n\nrdnskey.PROTOCOL_DNSSEC = 3\nrdnskey.ZONE_KEY = 0x80\nrdnskey.SECURE_ENTRYPOINT = 0x8000\n\nrdnskey.encode = function (key, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rdnskey.encodingLength(key))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const keydata = key.key\n  if (!Buffer.isBuffer(keydata)) {\n    throw new Error('Key must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(key.flags, offset)\n  offset += 2\n  buf.writeUInt8(rdnskey.PROTOCOL_DNSSEC, offset)\n  offset += 1\n  buf.writeUInt8(key.algorithm, offset)\n  offset += 1\n  keydata.copy(buf, offset, 0, keydata.length)\n  offset += keydata.length\n\n  rdnskey.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rdnskey.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrdnskey.encode.bytes = 0\n\nrdnskey.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var key = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  key.flags = buf.readUInt16BE(offset)\n  offset += 2\n  if (buf.readUInt8(offset) !== rdnskey.PROTOCOL_DNSSEC) {\n    throw new Error('Protocol must be 3')\n  }\n  offset += 1\n  key.algorithm = buf.readUInt8(offset)\n  offset += 1\n  key.key = buf.slice(offset, oldOffset + length + 2)\n  offset += key.key.length\n  rdnskey.decode.bytes = offset - oldOffset\n  return key\n}\n\nrdnskey.decode.bytes = 0\n\nrdnskey.encodingLength = function (key) {\n  return 6 + Buffer.byteLength(key.key)\n}\n\nconst rrrsig = exports.rrsig = {}\n\nrrrsig.encode = function (sig, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrrsig.encodingLength(sig))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const signature = sig.signature\n  if (!Buffer.isBuffer(signature)) {\n    throw new Error('Signature must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(types.toType(sig.typeCovered), offset)\n  offset += 2\n  buf.writeUInt8(sig.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(sig.labels, offset)\n  offset += 1\n  buf.writeUInt32BE(sig.originalTTL, offset)\n  offset += 4\n  buf.writeUInt32BE(sig.expiration, offset)\n  offset += 4\n  buf.writeUInt32BE(sig.inception, offset)\n  offset += 4\n  buf.writeUInt16BE(sig.keyTag, offset)\n  offset += 2\n  name.encode(sig.signersName, buf, offset)\n  offset += name.encode.bytes\n  signature.copy(buf, offset, 0, signature.length)\n  offset += signature.length\n\n  rrrsig.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rrrsig.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrrrsig.encode.bytes = 0\n\nrrrsig.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var sig = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  sig.typeCovered = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n  sig.algorithm = buf.readUInt8(offset)\n  offset += 1\n  sig.labels = buf.readUInt8(offset)\n  offset += 1\n  sig.originalTTL = buf.readUInt32BE(offset)\n  offset += 4\n  sig.expiration = buf.readUInt32BE(offset)\n  offset += 4\n  sig.inception = buf.readUInt32BE(offset)\n  offset += 4\n  sig.keyTag = buf.readUInt16BE(offset)\n  offset += 2\n  sig.signersName = name.decode(buf, offset)\n  offset += name.decode.bytes\n  sig.signature = buf.slice(offset, oldOffset + length + 2)\n  offset += sig.signature.length\n  rrrsig.decode.bytes = offset - oldOffset\n  return sig\n}\n\nrrrsig.decode.bytes = 0\n\nrrrsig.encodingLength = function (sig) {\n  return 20 +\n    name.encodingLength(sig.signersName) +\n    Buffer.byteLength(sig.signature)\n}\n\nconst rrp = exports.rp = {}\n\nrrp.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrp.encodingLength(data))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // Leave space for length\n  name.encode(data.mbox || '.', buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.txt || '.', buf, offset)\n  offset += name.encode.bytes\n  rrp.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rrp.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrrp.encode.bytes = 0\n\nrrp.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mbox = name.decode(buf, offset) || '.'\n  offset += name.decode.bytes\n  data.txt = name.decode(buf, offset) || '.'\n  offset += name.decode.bytes\n  rrp.decode.bytes = offset - oldOffset\n  return data\n}\n\nrrp.decode.bytes = 0\n\nrrp.encodingLength = function (data) {\n  return 2 + name.encodingLength(data.mbox || '.') + name.encodingLength(data.txt || '.')\n}\n\nconst typebitmap = {}\n\ntypebitmap.encode = function (typelist, buf, offset) {\n  if (!buf) buf = Buffer.alloc(typebitmap.encodingLength(typelist))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var typesByWindow = []\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i])\n    if (typesByWindow[typeid >> 8] === undefined) {\n      typesByWindow[typeid >> 8] = []\n    }\n    typesByWindow[typeid >> 8][(typeid >> 3) & 0x1F] |= 1 << (7 - (typeid & 0x7))\n  }\n\n  for (i = 0; i < typesByWindow.length; i++) {\n    if (typesByWindow[i] !== undefined) {\n      var windowBuf = Buffer.from(typesByWindow[i])\n      buf.writeUInt8(i, offset)\n      offset += 1\n      buf.writeUInt8(windowBuf.length, offset)\n      offset += 1\n      windowBuf.copy(buf, offset)\n      offset += windowBuf.length\n    }\n  }\n\n  typebitmap.encode.bytes = offset - oldOffset\n  return buf\n}\n\ntypebitmap.encode.bytes = 0\n\ntypebitmap.decode = function (buf, offset, length) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var typelist = []\n  while (offset - oldOffset < length) {\n    var window = buf.readUInt8(offset)\n    offset += 1\n    var windowLength = buf.readUInt8(offset)\n    offset += 1\n    for (var i = 0; i < windowLength; i++) {\n      var b = buf.readUInt8(offset + i)\n      for (var j = 0; j < 8; j++) {\n        if (b & (1 << (7 - j))) {\n          var typeid = types.toString((window << 8) | (i << 3) | j)\n          typelist.push(typeid)\n        }\n      }\n    }\n    offset += windowLength\n  }\n\n  typebitmap.decode.bytes = offset - oldOffset\n  return typelist\n}\n\ntypebitmap.decode.bytes = 0\n\ntypebitmap.encodingLength = function (typelist) {\n  var extents = []\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i])\n    extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 0xFF)\n  }\n\n  var len = 0\n  for (i = 0; i < extents.length; i++) {\n    if (extents[i] !== undefined) {\n      len += 2 + Math.ceil((extents[i] + 1) / 8)\n    }\n  }\n\n  return len\n}\n\nconst rnsec = exports.nsec = {}\n\nrnsec.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // Leave space for length\n  name.encode(record.nextDomain, buf, offset)\n  offset += name.encode.bytes\n  typebitmap.encode(record.rrtypes, buf, offset)\n  offset += typebitmap.encode.bytes\n\n  rnsec.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnsec.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnsec.encode.bytes = 0\n\nrnsec.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var record = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  record.nextDomain = name.decode(buf, offset)\n  offset += name.decode.bytes\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))\n  offset += typebitmap.decode.bytes\n\n  rnsec.decode.bytes = offset - oldOffset\n  return record\n}\n\nrnsec.decode.bytes = 0\n\nrnsec.encodingLength = function (record) {\n  return 2 +\n    name.encodingLength(record.nextDomain) +\n    typebitmap.encodingLength(record.rrtypes)\n}\n\nconst rnsec3 = exports.nsec3 = {}\n\nrnsec3.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec3.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const salt = record.salt\n  if (!Buffer.isBuffer(salt)) {\n    throw new Error('salt must be a Buffer')\n  }\n\n  const nextDomain = record.nextDomain\n  if (!Buffer.isBuffer(nextDomain)) {\n    throw new Error('nextDomain must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt8(record.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(record.flags, offset)\n  offset += 1\n  buf.writeUInt16BE(record.iterations, offset)\n  offset += 2\n  buf.writeUInt8(salt.length, offset)\n  offset += 1\n  salt.copy(buf, offset, 0, salt.length)\n  offset += salt.length\n  buf.writeUInt8(nextDomain.length, offset)\n  offset += 1\n  nextDomain.copy(buf, offset, 0, nextDomain.length)\n  offset += nextDomain.length\n  typebitmap.encode(record.rrtypes, buf, offset)\n  offset += typebitmap.encode.bytes\n\n  rnsec3.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnsec3.encode.bytes = 0\n\nrnsec3.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var record = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  record.algorithm = buf.readUInt8(offset)\n  offset += 1\n  record.flags = buf.readUInt8(offset)\n  offset += 1\n  record.iterations = buf.readUInt16BE(offset)\n  offset += 2\n  const saltLength = buf.readUInt8(offset)\n  offset += 1\n  record.salt = buf.slice(offset, offset + saltLength)\n  offset += saltLength\n  const hashLength = buf.readUInt8(offset)\n  offset += 1\n  record.nextDomain = buf.slice(offset, offset + hashLength)\n  offset += hashLength\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))\n  offset += typebitmap.decode.bytes\n\n  rnsec3.decode.bytes = offset - oldOffset\n  return record\n}\n\nrnsec3.decode.bytes = 0\n\nrnsec3.encodingLength = function (record) {\n  return 8 +\n    record.salt.length +\n    record.nextDomain.length +\n    typebitmap.encodingLength(record.rrtypes)\n}\n\nconst rds = exports.ds = {}\n\nrds.encode = function (digest, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const digestdata = digest.digest\n  if (!Buffer.isBuffer(digestdata)) {\n    throw new Error('Digest must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(digest.keyTag, offset)\n  offset += 2\n  buf.writeUInt8(digest.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(digest.digestType, offset)\n  offset += 1\n  digestdata.copy(buf, offset, 0, digestdata.length)\n  offset += digestdata.length\n\n  rds.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrds.encode.bytes = 0\n\nrds.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var digest = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  digest.keyTag = buf.readUInt16BE(offset)\n  offset += 2\n  digest.algorithm = buf.readUInt8(offset)\n  offset += 1\n  digest.digestType = buf.readUInt8(offset)\n  offset += 1\n  digest.digest = buf.slice(offset, oldOffset + length + 2)\n  offset += digest.digest.length\n  rds.decode.bytes = offset - oldOffset\n  return digest\n}\n\nrds.decode.bytes = 0\n\nrds.encodingLength = function (digest) {\n  return 6 + Buffer.byteLength(digest.digest)\n}\n\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A': return ra\n    case 'PTR': return rptr\n    case 'CNAME': return rcname\n    case 'DNAME': return rdname\n    case 'TXT': return rtxt\n    case 'NULL': return rnull\n    case 'AAAA': return raaaa\n    case 'SRV': return rsrv\n    case 'HINFO': return rhinfo\n    case 'CAA': return rcaa\n    case 'NS': return rns\n    case 'SOA': return rsoa\n    case 'MX': return rmx\n    case 'OPT': return ropt\n    case 'DNSKEY': return rdnskey\n    case 'RRSIG': return rrrsig\n    case 'RP': return rrp\n    case 'NSEC': return rnsec\n    case 'NSEC3': return rnsec3\n    case 'DS': return rds\n  }\n  return runknown\n}\n\nconst answer = exports.answer = {}\n\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.alloc(answer.encodingLength(a))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(a.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(a.type), offset)\n\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.')\n    }\n    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2)\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4)\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5)\n    buf.writeUInt16BE(a.flags || 0, offset + 6)\n\n    offset += 8\n    ropt.encode(a.options || [], buf, offset)\n    offset += ropt.encode.bytes\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class)\n    if (a.flush) klass |= FLUSH_MASK // the 1st bit of the class is the flush bit\n    buf.writeUInt16BE(klass, offset + 2)\n    buf.writeUInt32BE(a.ttl || 0, offset + 4)\n\n    offset += 8\n    const enc = renc(a.type)\n    enc.encode(a.data, buf, offset)\n    offset += enc.encode.bytes\n  }\n\n  answer.encode.bytes = offset - oldOffset\n  return buf\n}\n\nanswer.encode.bytes = 0\n\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const a = {}\n  const oldOffset = offset\n\n  a.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n  a.type = types.toString(buf.readUInt16BE(offset))\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2)\n    a.extendedRcode = buf.readUInt8(offset + 4)\n    a.ednsVersion = buf.readUInt8(offset + 5)\n    a.flags = buf.readUInt16BE(offset + 6)\n    a.flag_do = ((a.flags >> 15) & 0x1) === 1\n    a.options = ropt.decode(buf, offset + 8)\n    offset += 8 + ropt.decode.bytes\n  } else {\n    const klass = buf.readUInt16BE(offset + 2)\n    a.ttl = buf.readUInt32BE(offset + 4)\n\n    a.class = classes.toString(klass & NOT_FLUSH_MASK)\n    a.flush = !!(klass & FLUSH_MASK)\n\n    const enc = renc(a.type)\n    a.data = enc.decode(buf, offset + 8)\n    offset += 8 + enc.decode.bytes\n  }\n\n  answer.decode.bytes = offset - oldOffset\n  return a\n}\n\nanswer.decode.bytes = 0\n\nanswer.encodingLength = function (a) {\n  const data = (a.data !== null && a.data !== undefined) ? a.data : a.options\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data)\n}\n\nconst question = exports.question = {}\n\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.alloc(question.encodingLength(q))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(q.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(q.type), offset)\n  offset += 2\n\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset)\n  offset += 2\n\n  question.encode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.encode.bytes = 0\n\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const q = {}\n\n  q.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  q.type = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  q.class = classes.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  const qu = !!(q.class & QU_MASK)\n  if (qu) q.class &= NOT_QU_MASK\n\n  question.decode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.decode.bytes = 0\n\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4\n}\n\nexports.AUTHORITATIVE_ANSWER = 1 << 10\nexports.TRUNCATED_RESPONSE = 1 << 9\nexports.RECURSION_DESIRED = 1 << 8\nexports.RECURSION_AVAILABLE = 1 << 7\nexports.AUTHENTIC_DATA = 1 << 5\nexports.CHECKING_DISABLED = 1 << 4\nexports.DNSSEC_OK = 1 << 15\n\nexports.encode = function (result, buf, offset) {\n  const allocing = !buf\n\n  if (allocing) buf = Buffer.alloc(exports.encodingLength(result))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  if (!result.questions) result.questions = []\n  if (!result.answers) result.answers = []\n  if (!result.authorities) result.authorities = []\n  if (!result.additionals) result.additionals = []\n\n  header.encode(result, buf, offset)\n  offset += header.encode.bytes\n\n  offset = encodeList(result.questions, question, buf, offset)\n  offset = encodeList(result.answers, answer, buf, offset)\n  offset = encodeList(result.authorities, answer, buf, offset)\n  offset = encodeList(result.additionals, answer, buf, offset)\n\n  exports.encode.bytes = offset - oldOffset\n\n  // just a quick sanity check\n  if (allocing && exports.encode.bytes !== buf.length) {\n    return buf.slice(0, exports.encode.bytes)\n  }\n\n  return buf\n}\n\nexports.encode.bytes = 0\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const result = header.decode(buf, offset)\n  offset += header.decode.bytes\n\n  offset = decodeList(result.questions, question, buf, offset)\n  offset = decodeList(result.answers, answer, buf, offset)\n  offset = decodeList(result.authorities, answer, buf, offset)\n  offset = decodeList(result.additionals, answer, buf, offset)\n\n  exports.decode.bytes = offset - oldOffset\n\n  return result\n}\n\nexports.decode.bytes = 0\n\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) +\n    encodingLengthList(result.questions || [], question) +\n    encodingLengthList(result.answers || [], answer) +\n    encodingLengthList(result.authorities || [], answer) +\n    encodingLengthList(result.additionals || [], answer)\n}\n\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result)\n  const sbuf = Buffer.alloc(2)\n  sbuf.writeUInt16BE(buf.byteLength)\n  const combine = Buffer.concat([sbuf, buf])\n  exports.streamEncode.bytes = combine.byteLength\n  return combine\n}\n\nexports.streamEncode.bytes = 0\n\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0)\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null\n  }\n  const result = exports.decode(sbuf.slice(2))\n  exports.streamDecode.bytes = exports.decode.bytes\n  return result\n}\n\nexports.streamDecode.bytes = 0\n\nfunction encodingLengthList (list, enc) {\n  let len = 0\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i])\n  return len\n}\n\nfunction encodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset)\n    offset += enc.encode.bytes\n  }\n  return offset\n}\n\nfunction decodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset)\n    offset += enc.decode.bytes\n  }\n  return offset\n}\n"]},"metadata":{},"sourceType":"script"}