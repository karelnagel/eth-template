{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DNSProver = exports.DEFAULT_ALGORITHMS = exports.DEFAULT_DIGESTS = exports.NoValidDnskeyError = exports.NoValidDsError = exports.ResponseCodeError = exports.SignedSet = exports.dohQuery = exports.answersToString = exports.getKeyTag = exports.DEFAULT_TRUST_ANCHORS = void 0;\n\nconst packet = require(\"dns-packet\");\n\nconst packet_types = require(\"dns-packet/types\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst log_1 = require(\"./log\");\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nexports.DEFAULT_TRUST_ANCHORS = [{\n  name: '.',\n  type: 'DS',\n  class: 'IN',\n  data: {\n    keyTag: 19036,\n    algorithm: 8,\n    digestType: 2,\n    digest: Buffer.from('49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5', 'hex')\n  }\n}, {\n  name: '.',\n  type: 'DS',\n  class: 'IN',\n  data: {\n    keyTag: 20326,\n    algorithm: 8,\n    digestType: 2,\n    digest: Buffer.from('E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D', 'hex')\n  }\n}];\n\nfunction encodeURLParams(p) {\n  return Object.entries(p).map(kv => kv.map(encodeURIComponent).join(\"=\")).join(\"&\");\n}\n\nfunction getKeyTag(key) {\n  const data = packet.dnskey.encode(key.data).slice(2);\n  let keytag = 0;\n\n  for (var i = 0; i < data.length; i++) {\n    var v = data[i];\n\n    if ((i & 1) !== 0) {\n      keytag += v;\n    } else {\n      keytag += v << 8;\n    }\n  }\n\n  keytag += keytag >> 16 & 0xffff;\n  keytag &= 0xffff;\n  return keytag;\n}\n\nexports.getKeyTag = getKeyTag;\n\nfunction answersToString(a) {\n  const s = a.map(a => {\n    const prefix = `${a.name} ${a.ttl} ${a.class} ${a.type}`;\n    const d = a.data;\n\n    switch (a.type) {\n      case 'A':\n        return `${prefix} ${d}`;\n\n      case 'DNSKEY':\n        return `${prefix} ${d.flags} 3 ${d.algorithm} ${d.key.toString('base64')}; keyTag=${getKeyTag(a)}`;\n\n      case 'DS':\n        return `${prefix} ${d.keyTag} ${d.algorithm} ${d.digestType} ${d.digest.toString('hex')}`;\n\n      case 'OPT':\n        return `${prefix}`;\n\n      case 'RRSIG':\n        return `${prefix} ${d.typeCovered} ${d.algorithm} ${d.labels} ${d.originalTTL} ${d.expiration} ${d.inception} ${d.keyTag} ${d.signersName} ${d.signature.toString('base64')}`;\n\n      case 'TXT':\n        const texts = d.map(t => `\"${t}\"`);\n        return `${prefix} ${texts.join(' ')}`;\n    }\n  });\n  return s.join('\\n');\n}\n\nexports.answersToString = answersToString;\n\nfunction dohQuery(url) {\n  return function getDNS(q) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = packet.encode(q);\n      const response = yield node_fetch_1.default(url + \"?\" + encodeURLParams({\n        ct: \"application/dns-udpwireformat\",\n        dns: buf.toString('base64'),\n        ts: Date.now().toString()\n      }));\n      return packet.decode(Buffer.from(yield response.arrayBuffer()));\n    });\n  };\n}\n\nexports.dohQuery = dohQuery;\n\nclass SignedSet {\n  constructor(records, signature) {\n    this.records = records;\n    this.signature = signature;\n  }\n\n  static fromWire(data, signatureData) {\n    const {\n      rdata,\n      length\n    } = this.readRrsigRdata(data);\n    rdata.signature = signatureData;\n    const rrs = [];\n    let off = length;\n\n    while (off < data.length) {\n      rrs.push(packet.answer.decode(data, off));\n      off += packet.answer.decode.bytes;\n    }\n\n    return new SignedSet(rrs, {\n      name: rrs[0].name,\n      type: 'RRSIG',\n      class: rrs[0].class,\n      data: rdata\n    });\n  }\n\n  static readRrsigRdata(data) {\n    let offset = 0;\n    return {\n      rdata: {\n        typeCovered: packet_types.toString(data.readUInt16BE(0)),\n        algorithm: data.readUInt8(2),\n        labels: data.readUInt8(3),\n        originalTTL: data.readUInt32BE(4),\n        expiration: data.readUInt32BE(8),\n        inception: data.readUInt32BE(12),\n        keyTag: data.readUInt16BE(16),\n        signersName: packet.name.decode(data, 18),\n        signature: Buffer.of()\n      },\n      length: 18 + packet.name.decode.bytes\n    };\n  }\n\n  toWire() {\n    let withRrsig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let rrset = Buffer.concat(this.records // https://tools.ietf.org/html/rfc4034#section-6\n    .sort((a, b) => {\n      const aenc = packet.record(a.type).encode(a.data).slice(2);\n      const benc = packet.record(b.type).encode(b.data).slice(2);\n      return aenc.compare(benc);\n    }).map(r => packet.answer.encode(Object.assign(r, {\n      name: r.name.toLowerCase(),\n      ttl: this.signature.data.originalTTL // (5)\n\n    }))));\n\n    if (withRrsig) {\n      let rrsig = packet.rrsig.encode(Object.assign({}, this.signature.data, {\n        signature: Buffer.of()\n      })).slice(2);\n      return Buffer.concat([rrsig, rrset]);\n    } else {\n      return rrset;\n    }\n  }\n\n}\n\nexports.SignedSet = SignedSet;\n\nclass ResponseCodeError extends Error {\n  constructor(query, response) {\n    super(\"DNS server responded with \" + response.rcode);\n    this.name = 'ResponseError';\n    this.query = query;\n    this.response = response;\n  }\n\n}\n\nexports.ResponseCodeError = ResponseCodeError;\n\nclass NoValidDsError extends Error {\n  constructor(keys) {\n    super(`Could not find a DS record to validate any RRSIG on DNSKEY records for ${keys[0].name}`);\n    this.keys = keys;\n    this.name = 'NoValidDsError';\n  }\n\n}\n\nexports.NoValidDsError = NoValidDsError;\n\nclass NoValidDnskeyError extends Error {\n  constructor(result) {\n    super(`Could not find a DNSKEY record to validate any RRSIG on ${result[0].type} records for ${result[0].name}`);\n    this.result = result;\n    this.name = 'NoValidDnskeyError';\n  }\n\n}\n\nexports.NoValidDnskeyError = NoValidDnskeyError;\nexports.DEFAULT_DIGESTS = {\n  // SHA256\n  1: {\n    name: 'SHA1',\n    f: (data, digest) => {\n      return true;\n    }\n  },\n  2: {\n    name: 'SHA256',\n    f: (data, digest) => {\n      return ethereumjs_util_1.sha256(data).equals(digest);\n    }\n  }\n};\nexports.DEFAULT_ALGORITHMS = {\n  5: {\n    name: 'RSASHA1Algorithm',\n    f: (key, data, sig) => {\n      return true;\n    }\n  },\n  7: {\n    name: 'RSASHA1Algorithm',\n    f: (key, data, sig) => {\n      return true;\n    }\n  },\n  8: {\n    name: 'RSASHA256',\n    f: (key, data, sig) => {\n      return true;\n    }\n  },\n  13: {\n    name: 'P256SHA256',\n    f: (key, data, sig) => {\n      return true;\n    }\n  }\n};\n\nfunction isTypedArray(array) {\n  return array.every(a => a.type == 'DNSKEY');\n}\n\nfunction makeIndex(values, fn) {\n  const ret = {};\n\n  for (const value of values) {\n    const key = fn(value);\n    let list = ret[key];\n\n    if (list === undefined) {\n      list = ret[key] = [];\n    }\n\n    list.push(value);\n  }\n\n  return ret;\n}\n\nclass DNSProver {\n  constructor(sendQuery) {\n    let digests = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.DEFAULT_DIGESTS;\n    let algorithms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.DEFAULT_ALGORITHMS;\n    let anchors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.DEFAULT_TRUST_ANCHORS;\n    this.sendQuery = sendQuery;\n    this.digests = digests;\n    this.algorithms = algorithms;\n    this.anchors = anchors;\n  }\n\n  static create(url) {\n    return new DNSProver(dohQuery(url));\n  }\n\n  queryWithProof(qtype, qname) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new DNSQuery(this).queryWithProof(qtype, qname);\n    });\n  }\n\n}\n\nexports.DNSProver = DNSProver;\n\nclass DNSQuery {\n  constructor(prover) {\n    this.cache = {};\n    this.prover = prover;\n  }\n\n  queryWithProof(qtype, qname) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.dnsQuery(qtype.toString(), qname);\n      const answers = response.answers.filter(r => r.type === qtype && r.name === qname);\n      log_1.logger.info(`Found ${answers.length} ${qtype} records for ${qname}`);\n\n      if (answers.length === 0) {\n        return null;\n      }\n\n      const sigs = response.answers.filter(r => r.type === 'RRSIG' && r.name === qname && r.data.typeCovered === qtype);\n      log_1.logger.info(`Found ${sigs.length} RRSIGs over ${qtype} RRSET`); // If the records are self-signed, verify with DS records\n\n      if (isTypedArray(answers) && sigs.some(sig => sig.name === sig.data.signersName)) {\n        log_1.logger.info(`DNSKEY RRSET on ${answers[0].name} is self-signed; attempting to verify with a DS in parent zone`);\n        return this.verifyWithDS(answers, sigs);\n      } else {\n        return this.verifyRRSet(answers, sigs);\n      }\n    });\n  }\n\n  verifyRRSet(answers, sigs) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const sig of sigs) {\n        const algorithms = this.prover.algorithms;\n        log_1.logger.info(`Attempting to verify the ${answers[0].type} RRSET on ${answers[0].name} with RRSIG=${sig.data.keyTag}/${((_a = algorithms[sig.data.algorithm]) === null || _a === void 0 ? void 0 : _a.name) || sig.data.algorithm}`);\n        const ss = new SignedSet(answers, sig);\n\n        if (!(sig.data.algorithm in algorithms)) {\n          log_1.logger.info(`Skipping RRSIG=${sig.data.keyTag}/${sig.data.algorithm} on ${answers[0].type} RRSET for ${answers[0].name}: Unknown algorithm`);\n          continue;\n        }\n\n        const result = yield this.queryWithProof('DNSKEY', sig.data.signersName);\n\n        if (result === null) {\n          throw new NoValidDnskeyError(answers);\n        }\n\n        const {\n          answer,\n          proofs\n        } = result;\n\n        for (const key of answer.records) {\n          if (this.verifySignature(ss, key)) {\n            log_1.logger.info(`RRSIG=${sig.data.keyTag}/${algorithms[sig.data.algorithm].name} verifies the ${answers[0].type} RRSET on ${answers[0].name}`);\n            proofs.push(answer);\n            return {\n              answer: ss,\n              proofs: proofs\n            };\n          }\n        }\n      }\n\n      log_1.logger.warn(`Could not verify the ${answers[0].type} RRSET on ${answers[0].name} with any RRSIGs`);\n      throw new NoValidDnskeyError(answers);\n    });\n  }\n\n  verifyWithDS(keys, sigs) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyname = keys[0].name; // Fetch the DS records to use\n\n      let answer;\n      let proofs;\n\n      if (keyname === '.') {\n        [answer, proofs] = [this.prover.anchors, []];\n      } else {\n        const response = yield this.queryWithProof('DS', keyname);\n\n        if (response === null) {\n          throw new NoValidDsError(keys);\n        }\n\n        answer = response.answer.records;\n        proofs = response.proofs;\n        proofs.push(response.answer);\n      } // Index the passed in keys by key tag\n\n\n      const keysByTag = makeIndex(keys, getKeyTag);\n      const sigsByTag = makeIndex(sigs, sig => sig.data.keyTag); // Iterate over the DS records looking for keys we can verify\n\n      const algorithms = this.prover.algorithms;\n      const digests = this.prover.digests;\n\n      for (let ds of answer) {\n        for (let key of keysByTag[ds.data.keyTag] || []) {\n          if (this.checkDs(ds, key)) {\n            log_1.logger.info(`DS=${ds.data.keyTag}/${((_a = algorithms[ds.data.algorithm]) === null || _a === void 0 ? void 0 : _a.name) || ds.data.algorithm}/${digests[ds.data.digestType].name} verifies DNSKEY=${ds.data.keyTag}/${((_b = algorithms[key.data.algorithm]) === null || _b === void 0 ? void 0 : _b.name) || key.data.algorithm} on ${key.name}`);\n\n            for (let sig of sigsByTag[ds.data.keyTag] || []) {\n              const ss = new SignedSet(keys, sig);\n\n              if (this.verifySignature(ss, key)) {\n                log_1.logger.info(`RRSIG=${sig.data.keyTag}/${algorithms[sig.data.algorithm].name} verifies the DNSKEY RRSET on ${keys[0].name}`);\n                return {\n                  answer: ss,\n                  proofs: proofs\n                };\n              }\n            }\n          }\n        }\n      }\n\n      log_1.logger.warn(`Could not find any DS records to verify the DNSKEY RRSET on ${keys[0].name}`);\n      throw new NoValidDsError(keys);\n    });\n  }\n\n  verifySignature(answer, key) {\n    const keyTag = getKeyTag(key);\n\n    if (key.data.algorithm != answer.signature.data.algorithm || keyTag != answer.signature.data.keyTag || key.name != answer.signature.data.signersName) {\n      return false;\n    }\n\n    const signatureAlgorithm = this.prover.algorithms[key.data.algorithm];\n\n    if (signatureAlgorithm === undefined) {\n      log_1.logger.warn(`Unrecognised signature algorithm for DNSKEY=${keyTag}/${key.data.algorithm} on ${key.name}`);\n      return false;\n    }\n\n    return signatureAlgorithm.f(key.data.key, answer.toWire(), answer.signature.data.signature);\n  }\n\n  checkDs(ds, key) {\n    var _a;\n\n    if (key.data.algorithm != ds.data.algorithm || key.name != ds.name) {\n      return false;\n    }\n\n    const data = Buffer.concat([packet.name.encode(ds.name), packet.dnskey.encode(key.data).slice(2)]);\n    const digestAlgorithm = this.prover.digests[ds.data.digestType];\n\n    if (digestAlgorithm === undefined) {\n      log_1.logger.warn(`Unrecognised digest type for DS=${ds.data.keyTag}/${ds.data.digestType}/${((_a = this.prover.algorithms[ds.data.algorithm]) === null || _a === void 0 ? void 0 : _a.name) || ds.data.algorithm} on ${ds.name}`);\n      return false;\n    }\n\n    return digestAlgorithm.f(data, ds.data.digest);\n  }\n\n  dnsQuery(qtype, qname) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const query = {\n        type: 'query',\n        id: 1,\n        flags: packet.RECURSION_DESIRED,\n        questions: [{\n          type: qtype,\n          class: 'IN',\n          name: qname\n        }],\n        additionals: [{\n          type: 'OPT',\n          class: 'IN',\n          name: '.',\n          udpPayloadSize: 4096,\n          flags: packet.DNSSEC_OK\n        }],\n        answers: []\n      };\n\n      if (((_a = this.cache[qname]) === null || _a === void 0 ? void 0 : _a[qtype]) === undefined) {\n        if (this.cache[qname] === undefined) {\n          this.cache[qname] = {};\n        }\n\n        this.cache[qname][qtype] = yield this.prover.sendQuery(query);\n      }\n\n      const response = this.cache[qname][qtype];\n      log_1.logger.info(`Query[${qname} ${qtype}]:\\n` + answersToString(response.answers));\n\n      if (response.rcode !== 'NOERROR') {\n        throw new ResponseCodeError(query, response);\n      }\n\n      return response;\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@ensdomains/dnsprovejs/dist/prove.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","DNSProver","DEFAULT_ALGORITHMS","DEFAULT_DIGESTS","NoValidDnskeyError","NoValidDsError","ResponseCodeError","SignedSet","dohQuery","answersToString","getKeyTag","DEFAULT_TRUST_ANCHORS","packet","require","packet_types","ethereumjs_util_1","log_1","node_fetch_1","name","type","class","data","keyTag","algorithm","digestType","digest","Buffer","from","encodeURLParams","p","entries","map","kv","encodeURIComponent","join","key","dnskey","encode","slice","keytag","i","length","v","a","s","prefix","ttl","d","flags","toString","typeCovered","labels","originalTTL","expiration","inception","signersName","signature","texts","t","url","getDNS","q","buf","response","default","ct","dns","ts","Date","now","decode","arrayBuffer","constructor","records","fromWire","signatureData","rdata","readRrsigRdata","rrs","off","push","answer","bytes","offset","readUInt16BE","readUInt8","readUInt32BE","of","toWire","withRrsig","rrset","concat","sort","b","aenc","record","benc","compare","r","assign","toLowerCase","rrsig","Error","query","rcode","keys","f","sha256","equals","sig","isTypedArray","array","every","makeIndex","values","fn","ret","list","undefined","sendQuery","digests","algorithms","anchors","create","queryWithProof","qtype","qname","DNSQuery","prover","cache","dnsQuery","answers","filter","logger","info","sigs","some","verifyWithDS","verifyRRSet","_a","ss","proofs","verifySignature","warn","_b","keyname","keysByTag","sigsByTag","ds","checkDs","signatureAlgorithm","digestAlgorithm","id","RECURSION_DESIRED","questions","additionals","udpPayloadSize","DNSSEC_OK"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASAO,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEf,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAe,OAAO,CAACC,SAAR,GAAoBD,OAAO,CAACE,kBAAR,GAA6BF,OAAO,CAACG,eAAR,GAA0BH,OAAO,CAACI,kBAAR,GAA6BJ,OAAO,CAACK,cAAR,GAAyBL,OAAO,CAACM,iBAAR,GAA4BN,OAAO,CAACO,SAAR,GAAoBP,OAAO,CAACQ,QAAR,GAAmBR,OAAO,CAACS,eAAR,GAA0BT,OAAO,CAACU,SAAR,GAAoBV,OAAO,CAACW,qBAAR,GAAgC,KAAK,CAAvR;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,YAAD,CAAtB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,kBAAD,CAA5B;;AACA,MAAME,iBAAiB,GAAGF,OAAO,CAAC,iBAAD,CAAjC;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,YAAD,CAA5B;;AACAb,OAAO,CAACW,qBAAR,GAAgC,CAC5B;AACIO,EAAAA,IAAI,EAAE,GADV;AAEIC,EAAAA,IAAI,EAAE,IAFV;AAGIC,EAAAA,KAAK,EAAE,IAHX;AAIIC,EAAAA,IAAI,EAAE;AACFC,IAAAA,MAAM,EAAE,KADN;AAEFC,IAAAA,SAAS,EAAE,CAFT;AAGFC,IAAAA,UAAU,EAAE,CAHV;AAIFC,IAAAA,MAAM,EAAEC,MAAM,CAACC,IAAP,CAAY,kEAAZ,EAAgF,KAAhF;AAJN;AAJV,CAD4B,EAY5B;AACIT,EAAAA,IAAI,EAAE,GADV;AAEIC,EAAAA,IAAI,EAAE,IAFV;AAGIC,EAAAA,KAAK,EAAE,IAHX;AAIIC,EAAAA,IAAI,EAAE;AACFC,IAAAA,MAAM,EAAE,KADN;AAEFC,IAAAA,SAAS,EAAE,CAFT;AAGFC,IAAAA,UAAU,EAAE,CAHV;AAIFC,IAAAA,MAAM,EAAEC,MAAM,CAACC,IAAP,CAAY,kEAAZ,EAAgF,KAAhF;AAJN;AAJV,CAZ4B,CAAhC;;AAwBA,SAASC,eAAT,CAAyBC,CAAzB,EAA4B;AACxB,SAAO/B,MAAM,CAACgC,OAAP,CAAeD,CAAf,EAAkBE,GAAlB,CAAsBC,EAAE,IAAIA,EAAE,CAACD,GAAH,CAAOE,kBAAP,EAA2BC,IAA3B,CAAgC,GAAhC,CAA5B,EAAkEA,IAAlE,CAAuE,GAAvE,CAAP;AACH;;AACD,SAASxB,SAAT,CAAmByB,GAAnB,EAAwB;AACpB,QAAMd,IAAI,GAAGT,MAAM,CAACwB,MAAP,CAAcC,MAAd,CAAqBF,GAAG,CAACd,IAAzB,EAA+BiB,KAA/B,CAAqC,CAArC,CAAb;AACA,MAAIC,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,IAAI,CAACoB,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AAClC,QAAIE,CAAC,GAAGrB,IAAI,CAACmB,CAAD,CAAZ;;AACA,QAAI,CAACA,CAAC,GAAG,CAAL,MAAY,CAAhB,EAAmB;AACfD,MAAAA,MAAM,IAAIG,CAAV;AACH,KAFD,MAGK;AACDH,MAAAA,MAAM,IAAIG,CAAC,IAAI,CAAf;AACH;AACJ;;AACDH,EAAAA,MAAM,IAAKA,MAAM,IAAI,EAAX,GAAiB,MAA3B;AACAA,EAAAA,MAAM,IAAI,MAAV;AACA,SAAOA,MAAP;AACH;;AACDvC,OAAO,CAACU,SAAR,GAAoBA,SAApB;;AACA,SAASD,eAAT,CAAyBkC,CAAzB,EAA4B;AACxB,QAAMC,CAAC,GAAGD,CAAC,CAACZ,GAAF,CAAOY,CAAD,IAAO;AACnB,UAAME,MAAM,GAAI,GAAEF,CAAC,CAACzB,IAAK,IAAGyB,CAAC,CAACG,GAAI,IAAGH,CAAC,CAACvB,KAAM,IAAGuB,CAAC,CAACxB,IAAK,EAAvD;AACA,UAAM4B,CAAC,GAAGJ,CAAC,CAACtB,IAAZ;;AACA,YAAQsB,CAAC,CAACxB,IAAV;AACI,WAAK,GAAL;AACI,eAAQ,GAAE0B,MAAO,IAAGE,CAAE,EAAtB;;AACJ,WAAK,QAAL;AACI,eAAQ,GAAEF,MAAO,IAAGE,CAAC,CAACC,KAAM,MAAKD,CAAC,CAACxB,SAAU,IAAGwB,CAAC,CAACZ,GAAF,CAAMc,QAAN,CAAe,QAAf,CAAyB,YAAWvC,SAAS,CAACiC,CAAD,CAAI,EAAjG;;AACJ,WAAK,IAAL;AACI,eAAQ,GAAEE,MAAO,IAAGE,CAAC,CAACzB,MAAO,IAAGyB,CAAC,CAACxB,SAAU,IAAGwB,CAAC,CAACvB,UAAW,IAAGuB,CAAC,CAACtB,MAAF,CAASwB,QAAT,CAAkB,KAAlB,CAAyB,EAAxF;;AACJ,WAAK,KAAL;AACI,eAAQ,GAAEJ,MAAO,EAAjB;;AACJ,WAAK,OAAL;AACI,eAAQ,GAAEA,MAAO,IAAGE,CAAC,CAACG,WAAY,IAAGH,CAAC,CAACxB,SAAU,IAAGwB,CAAC,CAACI,MAAO,IAAGJ,CAAC,CAACK,WAAY,IAAGL,CAAC,CAACM,UAAW,IAAGN,CAAC,CAACO,SAAU,IAAGP,CAAC,CAACzB,MAAO,IAAGyB,CAAC,CAACQ,WAAY,IAAGR,CAAC,CAACS,SAAF,CAAYP,QAAZ,CAAqB,QAArB,CAA+B,EAA5K;;AACJ,WAAK,KAAL;AACI,cAAMQ,KAAK,GAAGV,CAAC,CAAChB,GAAF,CAAO2B,CAAD,IAAQ,IAAGA,CAAE,GAAnB,CAAd;AACA,eAAQ,GAAEb,MAAO,IAAGY,KAAK,CAACvB,IAAN,CAAW,GAAX,CAAgB,EAApC;AAbR;AAeH,GAlBS,CAAV;AAmBA,SAAOU,CAAC,CAACV,IAAF,CAAO,IAAP,CAAP;AACH;;AACDlC,OAAO,CAACS,eAAR,GAA0BA,eAA1B;;AACA,SAASD,QAAT,CAAkBmD,GAAlB,EAAuB;AACnB,SAAO,SAASC,MAAT,CAAgBC,CAAhB,EAAmB;AACtB,WAAOlF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAMmF,GAAG,GAAGlD,MAAM,CAACyB,MAAP,CAAcwB,CAAd,CAAZ;AACA,YAAME,QAAQ,GAAG,MAAM9C,YAAY,CAAC+C,OAAb,CAAqBL,GAAG,GAAG,GAAN,GAAY/B,eAAe,CAAC;AACpEqC,QAAAA,EAAE,EAAE,+BADgE;AAEpEC,QAAAA,GAAG,EAAEJ,GAAG,CAACb,QAAJ,CAAa,QAAb,CAF+D;AAGpEkB,QAAAA,EAAE,EAAEC,IAAI,CAACC,GAAL,GAAWpB,QAAX;AAHgE,OAAD,CAAhD,CAAvB;AAKA,aAAOrC,MAAM,CAAC0D,MAAP,CAAc5C,MAAM,CAACC,IAAP,CAAY,MAAMoC,QAAQ,CAACQ,WAAT,EAAlB,CAAd,CAAP;AACH,KARe,CAAhB;AASH,GAVD;AAWH;;AACDvE,OAAO,CAACQ,QAAR,GAAmBA,QAAnB;;AACA,MAAMD,SAAN,CAAgB;AACZiE,EAAAA,WAAW,CAACC,OAAD,EAAUjB,SAAV,EAAqB;AAC5B,SAAKiB,OAAL,GAAeA,OAAf;AACA,SAAKjB,SAAL,GAAiBA,SAAjB;AACH;;AACc,SAARkB,QAAQ,CAACrD,IAAD,EAAOsD,aAAP,EAAsB;AACjC,UAAM;AAAEC,MAAAA,KAAF;AAASnC,MAAAA;AAAT,QAAoB,KAAKoC,cAAL,CAAoBxD,IAApB,CAA1B;AACAuD,IAAAA,KAAK,CAACpB,SAAN,GAAkBmB,aAAlB;AACA,UAAMG,GAAG,GAAG,EAAZ;AACA,QAAIC,GAAG,GAAGtC,MAAV;;AACA,WAAOsC,GAAG,GAAG1D,IAAI,CAACoB,MAAlB,EAA0B;AACtBqC,MAAAA,GAAG,CAACE,IAAJ,CAASpE,MAAM,CAACqE,MAAP,CAAcX,MAAd,CAAqBjD,IAArB,EAA2B0D,GAA3B,CAAT;AACAA,MAAAA,GAAG,IAAInE,MAAM,CAACqE,MAAP,CAAcX,MAAd,CAAqBY,KAA5B;AACH;;AACD,WAAO,IAAI3E,SAAJ,CAAcuE,GAAd,EAAmB;AACtB5D,MAAAA,IAAI,EAAE4D,GAAG,CAAC,CAAD,CAAH,CAAO5D,IADS;AAEtBC,MAAAA,IAAI,EAAE,OAFgB;AAGtBC,MAAAA,KAAK,EAAE0D,GAAG,CAAC,CAAD,CAAH,CAAO1D,KAHQ;AAItBC,MAAAA,IAAI,EAAEuD;AAJgB,KAAnB,CAAP;AAMH;;AACoB,SAAdC,cAAc,CAACxD,IAAD,EAAO;AACxB,QAAI8D,MAAM,GAAG,CAAb;AACA,WAAO;AACHP,MAAAA,KAAK,EAAE;AACH1B,QAAAA,WAAW,EAAEpC,YAAY,CAACmC,QAAb,CAAsB5B,IAAI,CAAC+D,YAAL,CAAkB,CAAlB,CAAtB,CADV;AAEH7D,QAAAA,SAAS,EAAEF,IAAI,CAACgE,SAAL,CAAe,CAAf,CAFR;AAGHlC,QAAAA,MAAM,EAAE9B,IAAI,CAACgE,SAAL,CAAe,CAAf,CAHL;AAIHjC,QAAAA,WAAW,EAAE/B,IAAI,CAACiE,YAAL,CAAkB,CAAlB,CAJV;AAKHjC,QAAAA,UAAU,EAAEhC,IAAI,CAACiE,YAAL,CAAkB,CAAlB,CALT;AAMHhC,QAAAA,SAAS,EAAEjC,IAAI,CAACiE,YAAL,CAAkB,EAAlB,CANR;AAOHhE,QAAAA,MAAM,EAAED,IAAI,CAAC+D,YAAL,CAAkB,EAAlB,CAPL;AAQH7B,QAAAA,WAAW,EAAE3C,MAAM,CAACM,IAAP,CAAYoD,MAAZ,CAAmBjD,IAAnB,EAAyB,EAAzB,CARV;AASHmC,QAAAA,SAAS,EAAE9B,MAAM,CAAC6D,EAAP;AATR,OADJ;AAYH9C,MAAAA,MAAM,EAAE,KAAK7B,MAAM,CAACM,IAAP,CAAYoD,MAAZ,CAAmBY;AAZ7B,KAAP;AAcH;;AACDM,EAAAA,MAAM,GAAmB;AAAA,QAAlBC,SAAkB,uEAAN,IAAM;AACrB,QAAIC,KAAK,GAAGhE,MAAM,CAACiE,MAAP,CAAc,KAAKlB,OAAL,CACtB;AADsB,KAErBmB,IAFqB,CAEhB,CAACjD,CAAD,EAAIkD,CAAJ,KAAU;AAChB,YAAMC,IAAI,GAAGlF,MAAM,CAACmF,MAAP,CAAcpD,CAAC,CAACxB,IAAhB,EAAsBkB,MAAtB,CAA6BM,CAAC,CAACtB,IAA/B,EAAqCiB,KAArC,CAA2C,CAA3C,CAAb;AACA,YAAM0D,IAAI,GAAGpF,MAAM,CAACmF,MAAP,CAAcF,CAAC,CAAC1E,IAAhB,EAAsBkB,MAAtB,CAA6BwD,CAAC,CAACxE,IAA/B,EAAqCiB,KAArC,CAA2C,CAA3C,CAAb;AACA,aAAOwD,IAAI,CAACG,OAAL,CAAaD,IAAb,CAAP;AACH,KANyB,EAOrBjE,GAPqB,CAOjBmE,CAAC,IAAItF,MAAM,CAACqE,MAAP,CAAc5C,MAAd,CAAqBvC,MAAM,CAACqG,MAAP,CAAcD,CAAd,EAAiB;AAChDhF,MAAAA,IAAI,EAAEgF,CAAC,CAAChF,IAAF,CAAOkF,WAAP,EAD0C;AAEhDtD,MAAAA,GAAG,EAAE,KAAKU,SAAL,CAAenC,IAAf,CAAoB+B,WAFuB,CAEX;;AAFW,KAAjB,CAArB,CAPY,CAAd,CAAZ;;AAWA,QAAIqC,SAAJ,EAAe;AACX,UAAIY,KAAK,GAAGzF,MAAM,CAACyF,KAAP,CAAahE,MAAb,CAAoBvC,MAAM,CAACqG,MAAP,CAAc,EAAd,EAAkB,KAAK3C,SAAL,CAAenC,IAAjC,EAAuC;AAAEmC,QAAAA,SAAS,EAAE9B,MAAM,CAAC6D,EAAP;AAAb,OAAvC,CAApB,EAAwFjD,KAAxF,CAA8F,CAA9F,CAAZ;AACA,aAAOZ,MAAM,CAACiE,MAAP,CAAc,CAACU,KAAD,EAAQX,KAAR,CAAd,CAAP;AACH,KAHD,MAIK;AACD,aAAOA,KAAP;AACH;AACJ;;AAzDW;;AA2DhB1F,OAAO,CAACO,SAAR,GAAoBA,SAApB;;AACA,MAAMD,iBAAN,SAAgCgG,KAAhC,CAAsC;AAClC9B,EAAAA,WAAW,CAAC+B,KAAD,EAAQxC,QAAR,EAAkB;AACzB,UAAM,+BAA+BA,QAAQ,CAACyC,KAA9C;AACA,SAAKtF,IAAL,GAAY,eAAZ;AACA,SAAKqF,KAAL,GAAaA,KAAb;AACA,SAAKxC,QAAL,GAAgBA,QAAhB;AACH;;AANiC;;AAQtC/D,OAAO,CAACM,iBAAR,GAA4BA,iBAA5B;;AACA,MAAMD,cAAN,SAA6BiG,KAA7B,CAAmC;AAC/B9B,EAAAA,WAAW,CAACiC,IAAD,EAAO;AACd,UAAO,0EAAyEA,IAAI,CAAC,CAAD,CAAJ,CAAQvF,IAAK,EAA7F;AACA,SAAKuF,IAAL,GAAYA,IAAZ;AACA,SAAKvF,IAAL,GAAY,gBAAZ;AACH;;AAL8B;;AAOnClB,OAAO,CAACK,cAAR,GAAyBA,cAAzB;;AACA,MAAMD,kBAAN,SAAiCkG,KAAjC,CAAuC;AACnC9B,EAAAA,WAAW,CAAC9E,MAAD,EAAS;AAChB,UAAO,2DAA0DA,MAAM,CAAC,CAAD,CAAN,CAAUyB,IAAK,gBAAezB,MAAM,CAAC,CAAD,CAAN,CAAUwB,IAAK,EAA9G;AACA,SAAKxB,MAAL,GAAcA,MAAd;AACA,SAAKwB,IAAL,GAAY,oBAAZ;AACH;;AALkC;;AAOvClB,OAAO,CAACI,kBAAR,GAA6BA,kBAA7B;AACAJ,OAAO,CAACG,eAAR,GAA0B;AACtB;AACA,KAAG;AACCe,IAAAA,IAAI,EAAE,MADP;AAECwF,IAAAA,CAAC,EAAE,CAACrF,IAAD,EAAOI,MAAP,KAAkB;AACjB,aAAO,IAAP;AACH;AAJF,GAFmB;AAQtB,KAAG;AACCP,IAAAA,IAAI,EAAE,QADP;AAECwF,IAAAA,CAAC,EAAE,CAACrF,IAAD,EAAOI,MAAP,KAAkB;AACjB,aAAOV,iBAAiB,CAAC4F,MAAlB,CAAyBtF,IAAzB,EAA+BuF,MAA/B,CAAsCnF,MAAtC,CAAP;AACH;AAJF;AARmB,CAA1B;AAeAzB,OAAO,CAACE,kBAAR,GAA6B;AACzB,KAAG;AACCgB,IAAAA,IAAI,EAAE,kBADP;AAECwF,IAAAA,CAAC,EAAE,CAACvE,GAAD,EAAMd,IAAN,EAAYwF,GAAZ,KAAoB;AACnB,aAAO,IAAP;AACH;AAJF,GADsB;AAOzB,KAAG;AACC3F,IAAAA,IAAI,EAAE,kBADP;AAECwF,IAAAA,CAAC,EAAE,CAACvE,GAAD,EAAMd,IAAN,EAAYwF,GAAZ,KAAoB;AACnB,aAAO,IAAP;AACH;AAJF,GAPsB;AAazB,KAAG;AACC3F,IAAAA,IAAI,EAAE,WADP;AAECwF,IAAAA,CAAC,EAAE,CAACvE,GAAD,EAAMd,IAAN,EAAYwF,GAAZ,KAAoB;AACnB,aAAO,IAAP;AACH;AAJF,GAbsB;AAmBzB,MAAI;AACA3F,IAAAA,IAAI,EAAE,YADN;AAEAwF,IAAAA,CAAC,EAAE,CAACvE,GAAD,EAAMd,IAAN,EAAYwF,GAAZ,KAAoB;AACnB,aAAO,IAAP;AACH;AAJD;AAnBqB,CAA7B;;AA0BA,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AACzB,SAAOA,KAAK,CAACC,KAAN,CAAarE,CAAD,IAAOA,CAAC,CAACxB,IAAF,IAAU,QAA7B,CAAP;AACH;;AACD,SAAS8F,SAAT,CAAmBC,MAAnB,EAA2BC,EAA3B,EAA+B;AAC3B,QAAMC,GAAG,GAAG,EAAZ;;AACA,OAAK,MAAMnI,KAAX,IAAoBiI,MAApB,EAA4B;AACxB,UAAM/E,GAAG,GAAGgF,EAAE,CAAClI,KAAD,CAAd;AACA,QAAIoI,IAAI,GAAGD,GAAG,CAACjF,GAAD,CAAd;;AACA,QAAIkF,IAAI,KAAKC,SAAb,EAAwB;AACpBD,MAAAA,IAAI,GAAGD,GAAG,CAACjF,GAAD,CAAH,GAAW,EAAlB;AACH;;AACDkF,IAAAA,IAAI,CAACrC,IAAL,CAAU/F,KAAV;AACH;;AACD,SAAOmI,GAAP;AACH;;AACD,MAAMnH,SAAN,CAAgB;AACZuE,EAAAA,WAAW,CAAC+C,SAAD,EAAiI;AAAA,QAArHC,OAAqH,uEAA3GxH,OAAO,CAACG,eAAmG;AAAA,QAAlFsH,UAAkF,uEAArEzH,OAAO,CAACE,kBAA6D;AAAA,QAAzCwH,OAAyC,uEAA/B1H,OAAO,CAACW,qBAAuB;AACxI,SAAK4G,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACH;;AACY,SAANC,MAAM,CAAChE,GAAD,EAAM;AACf,WAAO,IAAI1D,SAAJ,CAAcO,QAAQ,CAACmD,GAAD,CAAtB,CAAP;AACH;;AACDiE,EAAAA,cAAc,CAACC,KAAD,EAAQC,KAAR,EAAe;AACzB,WAAOnJ,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,aAAQ,IAAIoJ,QAAJ,CAAa,IAAb,CAAD,CAAqBH,cAArB,CAAoCC,KAApC,EAA2CC,KAA3C,CAAP;AACH,KAFe,CAAhB;AAGH;;AAdW;;AAgBhB9H,OAAO,CAACC,SAAR,GAAoBA,SAApB;;AACA,MAAM8H,QAAN,CAAe;AACXvD,EAAAA,WAAW,CAACwD,MAAD,EAAS;AAChB,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKD,MAAL,GAAcA,MAAd;AACH;;AACDJ,EAAAA,cAAc,CAACC,KAAD,EAAQC,KAAR,EAAe;AACzB,WAAOnJ,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAMoF,QAAQ,GAAG,MAAM,KAAKmE,QAAL,CAAcL,KAAK,CAAC5E,QAAN,EAAd,EAAgC6E,KAAhC,CAAvB;AACA,YAAMK,OAAO,GAAGpE,QAAQ,CAACoE,OAAT,CAAiBC,MAAjB,CAAyBlC,CAAD,IAAOA,CAAC,CAAC/E,IAAF,KAAW0G,KAAX,IAAoB3B,CAAC,CAAChF,IAAF,KAAW4G,KAA9D,CAAhB;AACA9G,MAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,SAAQH,OAAO,CAAC1F,MAAO,IAAGoF,KAAM,gBAAeC,KAAM,EAAxE;;AACA,UAAIK,OAAO,CAAC1F,MAAR,KAAmB,CAAvB,EAA0B;AACtB,eAAO,IAAP;AACH;;AACD,YAAM8F,IAAI,GAAGxE,QAAQ,CAACoE,OAAT,CAAiBC,MAAjB,CAAyBlC,CAAD,IAAOA,CAAC,CAAC/E,IAAF,KAAW,OAAX,IAAsB+E,CAAC,CAAChF,IAAF,KAAW4G,KAAjC,IAA0C5B,CAAC,CAAC7E,IAAF,CAAO6B,WAAP,KAAuB2E,KAAhG,CAAb;AACA7G,MAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,SAAQC,IAAI,CAAC9F,MAAO,gBAAeoF,KAAM,QAA5D,EARgD,CAShD;;AACA,UAAIf,YAAY,CAACqB,OAAD,CAAZ,IAAyBI,IAAI,CAACC,IAAL,CAAW3B,GAAD,IAASA,GAAG,CAAC3F,IAAJ,KAAa2F,GAAG,CAACxF,IAAJ,CAASkC,WAAzC,CAA7B,EAAoF;AAChFvC,QAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,mBAAkBH,OAAO,CAAC,CAAD,CAAP,CAAWjH,IAAK,gEAArD;AACA,eAAO,KAAKuH,YAAL,CAAkBN,OAAlB,EAA2BI,IAA3B,CAAP;AACH,OAHD,MAIK;AACD,eAAO,KAAKG,WAAL,CAAiBP,OAAjB,EAA0BI,IAA1B,CAAP;AACH;AACJ,KAjBe,CAAhB;AAkBH;;AACDG,EAAAA,WAAW,CAACP,OAAD,EAAUI,IAAV,EAAgB;AACvB,QAAII,EAAJ;;AACA,WAAOhK,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,WAAK,MAAMkI,GAAX,IAAkB0B,IAAlB,EAAwB;AACpB,cAAMd,UAAU,GAAG,KAAKO,MAAL,CAAYP,UAA/B;AACAzG,QAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,4BAA2BH,OAAO,CAAC,CAAD,CAAP,CAAWhH,IAAK,aAAYgH,OAAO,CAAC,CAAD,CAAP,CAAWjH,IAAK,eAAc2F,GAAG,CAACxF,IAAJ,CAASC,MAAO,IAAG,CAAC,CAACqH,EAAE,GAAGlB,UAAU,CAACZ,GAAG,CAACxF,IAAJ,CAASE,SAAV,CAAhB,MAA0C,IAA1C,IAAkDoH,EAAE,KAAK,KAAK,CAA9D,GAAkE,KAAK,CAAvE,GAA2EA,EAAE,CAACzH,IAA/E,KAAwF2F,GAAG,CAACxF,IAAJ,CAASE,SAAU,EAAtO;AACA,cAAMqH,EAAE,GAAG,IAAIrI,SAAJ,CAAc4H,OAAd,EAAuBtB,GAAvB,CAAX;;AACA,YAAI,EAAEA,GAAG,CAACxF,IAAJ,CAASE,SAAT,IAAsBkG,UAAxB,CAAJ,EAAyC;AACrCzG,UAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,kBAAiBzB,GAAG,CAACxF,IAAJ,CAASC,MAAO,IAAGuF,GAAG,CAACxF,IAAJ,CAASE,SAAU,OAAM4G,OAAO,CAAC,CAAD,CAAP,CAAWhH,IAAK,cAAagH,OAAO,CAAC,CAAD,CAAP,CAAWjH,IAAK,qBAA7H;AACA;AACH;;AACD,cAAMxB,MAAM,GAAG,MAAM,KAAKkI,cAAL,CAAoB,QAApB,EAA8Bf,GAAG,CAACxF,IAAJ,CAASkC,WAAvC,CAArB;;AACA,YAAI7D,MAAM,KAAK,IAAf,EAAqB;AACjB,gBAAM,IAAIU,kBAAJ,CAAuB+H,OAAvB,CAAN;AACH;;AACD,cAAM;AAAElD,UAAAA,MAAF;AAAU4D,UAAAA;AAAV,YAAqBnJ,MAA3B;;AACA,aAAK,MAAMyC,GAAX,IAAkB8C,MAAM,CAACR,OAAzB,EAAkC;AAC9B,cAAI,KAAKqE,eAAL,CAAqBF,EAArB,EAAyBzG,GAAzB,CAAJ,EAAmC;AAC/BnB,YAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,SAAQzB,GAAG,CAACxF,IAAJ,CAASC,MAAO,IAAGmG,UAAU,CAACZ,GAAG,CAACxF,IAAJ,CAASE,SAAV,CAAV,CAA+BL,IAAK,iBAAgBiH,OAAO,CAAC,CAAD,CAAP,CAAWhH,IAAK,aAAYgH,OAAO,CAAC,CAAD,CAAP,CAAWjH,IAAK,EAA9I;AACA2H,YAAAA,MAAM,CAAC7D,IAAP,CAAYC,MAAZ;AACA,mBAAO;AAAEA,cAAAA,MAAM,EAAE2D,EAAV;AAAcC,cAAAA,MAAM,EAAEA;AAAtB,aAAP;AACH;AACJ;AACJ;;AACD7H,MAAAA,KAAK,CAACqH,MAAN,CAAaU,IAAb,CAAmB,wBAAuBZ,OAAO,CAAC,CAAD,CAAP,CAAWhH,IAAK,aAAYgH,OAAO,CAAC,CAAD,CAAP,CAAWjH,IAAK,kBAAtF;AACA,YAAM,IAAId,kBAAJ,CAAuB+H,OAAvB,CAAN;AACH,KAxBe,CAAhB;AAyBH;;AACDM,EAAAA,YAAY,CAAChC,IAAD,EAAO8B,IAAP,EAAa;AACrB,QAAII,EAAJ,EAAQK,EAAR;;AACA,WAAOrK,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAMsK,OAAO,GAAGxC,IAAI,CAAC,CAAD,CAAJ,CAAQvF,IAAxB,CADgD,CAEhD;;AACA,UAAI+D,MAAJ;AACA,UAAI4D,MAAJ;;AACA,UAAII,OAAO,KAAK,GAAhB,EAAqB;AACjB,SAAChE,MAAD,EAAS4D,MAAT,IAAmB,CAAC,KAAKb,MAAL,CAAYN,OAAb,EAAsB,EAAtB,CAAnB;AACH,OAFD,MAGK;AACD,cAAM3D,QAAQ,GAAG,MAAM,KAAK6D,cAAL,CAAoB,IAApB,EAA0BqB,OAA1B,CAAvB;;AACA,YAAIlF,QAAQ,KAAK,IAAjB,EAAuB;AACnB,gBAAM,IAAI1D,cAAJ,CAAmBoG,IAAnB,CAAN;AACH;;AACDxB,QAAAA,MAAM,GAAGlB,QAAQ,CAACkB,MAAT,CAAgBR,OAAzB;AACAoE,QAAAA,MAAM,GAAG9E,QAAQ,CAAC8E,MAAlB;AACAA,QAAAA,MAAM,CAAC7D,IAAP,CAAYjB,QAAQ,CAACkB,MAArB;AACH,OAhB+C,CAiBhD;;;AACA,YAAMiE,SAAS,GAAGjC,SAAS,CAACR,IAAD,EAAO/F,SAAP,CAA3B;AACA,YAAMyI,SAAS,GAAGlC,SAAS,CAACsB,IAAD,EAAQ1B,GAAD,IAASA,GAAG,CAACxF,IAAJ,CAASC,MAAzB,CAA3B,CAnBgD,CAoBhD;;AACA,YAAMmG,UAAU,GAAG,KAAKO,MAAL,CAAYP,UAA/B;AACA,YAAMD,OAAO,GAAG,KAAKQ,MAAL,CAAYR,OAA5B;;AACA,WAAK,IAAI4B,EAAT,IAAenE,MAAf,EAAuB;AACnB,aAAK,IAAI9C,GAAT,IAAgB+G,SAAS,CAACE,EAAE,CAAC/H,IAAH,CAAQC,MAAT,CAAT,IAA6B,EAA7C,EAAiD;AAC7C,cAAI,KAAK+H,OAAL,CAAaD,EAAb,EAAiBjH,GAAjB,CAAJ,EAA2B;AACvBnB,YAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,MAAKc,EAAE,CAAC/H,IAAH,CAAQC,MAAO,IAAG,CAAC,CAACqH,EAAE,GAAGlB,UAAU,CAAC2B,EAAE,CAAC/H,IAAH,CAAQE,SAAT,CAAhB,MAAyC,IAAzC,IAAiDoH,EAAE,KAAK,KAAK,CAA7D,GAAiE,KAAK,CAAtE,GAA0EA,EAAE,CAACzH,IAA9E,KAAuFkI,EAAE,CAAC/H,IAAH,CAAQE,SAAU,IAAGiG,OAAO,CAAC4B,EAAE,CAAC/H,IAAH,CAAQG,UAAT,CAAP,CAA4BN,IAAK,oBAAmBkI,EAAE,CAAC/H,IAAH,CAAQC,MAAO,IAAG,CAAC,CAAC0H,EAAE,GAAGvB,UAAU,CAACtF,GAAG,CAACd,IAAJ,CAASE,SAAV,CAAhB,MAA0C,IAA1C,IAAkDyH,EAAE,KAAK,KAAK,CAA9D,GAAkE,KAAK,CAAvE,GAA2EA,EAAE,CAAC9H,IAA/E,KAAwFiB,GAAG,CAACd,IAAJ,CAASE,SAAU,OAAMY,GAAG,CAACjB,IAAK,EAAtV;;AACA,iBAAK,IAAI2F,GAAT,IAAgBsC,SAAS,CAACC,EAAE,CAAC/H,IAAH,CAAQC,MAAT,CAAT,IAA6B,EAA7C,EAAiD;AAC7C,oBAAMsH,EAAE,GAAG,IAAIrI,SAAJ,CAAckG,IAAd,EAAoBI,GAApB,CAAX;;AACA,kBAAI,KAAKiC,eAAL,CAAqBF,EAArB,EAAyBzG,GAAzB,CAAJ,EAAmC;AAC/BnB,gBAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,SAAQzB,GAAG,CAACxF,IAAJ,CAASC,MAAO,IAAGmG,UAAU,CAACZ,GAAG,CAACxF,IAAJ,CAASE,SAAV,CAAV,CAA+BL,IAAK,iCAAgCuF,IAAI,CAAC,CAAD,CAAJ,CAAQvF,IAAK,EAA/H;AACA,uBAAO;AAAE+D,kBAAAA,MAAM,EAAE2D,EAAV;AAAcC,kBAAAA,MAAM,EAAEA;AAAtB,iBAAP;AACH;AACJ;AACJ;AACJ;AACJ;;AACD7H,MAAAA,KAAK,CAACqH,MAAN,CAAaU,IAAb,CAAmB,+DAA8DtC,IAAI,CAAC,CAAD,CAAJ,CAAQvF,IAAK,EAA9F;AACA,YAAM,IAAIb,cAAJ,CAAmBoG,IAAnB,CAAN;AACH,KAvCe,CAAhB;AAwCH;;AACDqC,EAAAA,eAAe,CAAC7D,MAAD,EAAS9C,GAAT,EAAc;AACzB,UAAMb,MAAM,GAAGZ,SAAS,CAACyB,GAAD,CAAxB;;AACA,QAAIA,GAAG,CAACd,IAAJ,CAASE,SAAT,IAAsB0D,MAAM,CAACzB,SAAP,CAAiBnC,IAAjB,CAAsBE,SAA5C,IAAyDD,MAAM,IAAI2D,MAAM,CAACzB,SAAP,CAAiBnC,IAAjB,CAAsBC,MAAzF,IAAmGa,GAAG,CAACjB,IAAJ,IAAY+D,MAAM,CAACzB,SAAP,CAAiBnC,IAAjB,CAAsBkC,WAAzI,EAAsJ;AAClJ,aAAO,KAAP;AACH;;AACD,UAAM+F,kBAAkB,GAAG,KAAKtB,MAAL,CAAYP,UAAZ,CAAuBtF,GAAG,CAACd,IAAJ,CAASE,SAAhC,CAA3B;;AACA,QAAI+H,kBAAkB,KAAKhC,SAA3B,EAAsC;AAClCtG,MAAAA,KAAK,CAACqH,MAAN,CAAaU,IAAb,CAAmB,+CAA8CzH,MAAO,IAAGa,GAAG,CAACd,IAAJ,CAASE,SAAU,OAAMY,GAAG,CAACjB,IAAK,EAA7G;AACA,aAAO,KAAP;AACH;;AACD,WAAOoI,kBAAkB,CAAC5C,CAAnB,CAAqBvE,GAAG,CAACd,IAAJ,CAASc,GAA9B,EAAmC8C,MAAM,CAACO,MAAP,EAAnC,EAAoDP,MAAM,CAACzB,SAAP,CAAiBnC,IAAjB,CAAsBmC,SAA1E,CAAP;AACH;;AACD6F,EAAAA,OAAO,CAACD,EAAD,EAAKjH,GAAL,EAAU;AACb,QAAIwG,EAAJ;;AACA,QAAIxG,GAAG,CAACd,IAAJ,CAASE,SAAT,IAAsB6H,EAAE,CAAC/H,IAAH,CAAQE,SAA9B,IAA2CY,GAAG,CAACjB,IAAJ,IAAYkI,EAAE,CAAClI,IAA9D,EAAoE;AAChE,aAAO,KAAP;AACH;;AACD,UAAMG,IAAI,GAAGK,MAAM,CAACiE,MAAP,CAAc,CACvB/E,MAAM,CAACM,IAAP,CAAYmB,MAAZ,CAAmB+G,EAAE,CAAClI,IAAtB,CADuB,EAEvBN,MAAM,CAACwB,MAAP,CAAcC,MAAd,CAAqBF,GAAG,CAACd,IAAzB,EAA+BiB,KAA/B,CAAqC,CAArC,CAFuB,CAAd,CAAb;AAIA,UAAMiH,eAAe,GAAG,KAAKvB,MAAL,CAAYR,OAAZ,CAAoB4B,EAAE,CAAC/H,IAAH,CAAQG,UAA5B,CAAxB;;AACA,QAAI+H,eAAe,KAAKjC,SAAxB,EAAmC;AAC/BtG,MAAAA,KAAK,CAACqH,MAAN,CAAaU,IAAb,CAAmB,mCAAkCK,EAAE,CAAC/H,IAAH,CAAQC,MAAO,IAAG8H,EAAE,CAAC/H,IAAH,CAAQG,UAAW,IAAG,CAAC,CAACmH,EAAE,GAAG,KAAKX,MAAL,CAAYP,UAAZ,CAAuB2B,EAAE,CAAC/H,IAAH,CAAQE,SAA/B,CAAN,MAAqD,IAArD,IAA6DoH,EAAE,KAAK,KAAK,CAAzE,GAA6E,KAAK,CAAlF,GAAsFA,EAAE,CAACzH,IAA1F,KAAmGkI,EAAE,CAAC/H,IAAH,CAAQE,SAAU,OAAM6H,EAAE,CAAClI,IAAK,EAAhO;AACA,aAAO,KAAP;AACH;;AACD,WAAOqI,eAAe,CAAC7C,CAAhB,CAAkBrF,IAAlB,EAAwB+H,EAAE,CAAC/H,IAAH,CAAQI,MAAhC,CAAP;AACH;;AACDyG,EAAAA,QAAQ,CAACL,KAAD,EAAQC,KAAR,EAAe;AACnB,QAAIa,EAAJ;;AACA,WAAOhK,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAM4H,KAAK,GAAG;AACVpF,QAAAA,IAAI,EAAE,OADI;AAEVqI,QAAAA,EAAE,EAAE,CAFM;AAGVxG,QAAAA,KAAK,EAAEpC,MAAM,CAAC6I,iBAHJ;AAIVC,QAAAA,SAAS,EAAE,CACP;AACIvI,UAAAA,IAAI,EAAE0G,KADV;AAEIzG,UAAAA,KAAK,EAAE,IAFX;AAGIF,UAAAA,IAAI,EAAE4G;AAHV,SADO,CAJD;AAWV6B,QAAAA,WAAW,EAAE,CACT;AACIxI,UAAAA,IAAI,EAAE,KADV;AAEIC,UAAAA,KAAK,EAAE,IAFX;AAGIF,UAAAA,IAAI,EAAE,GAHV;AAII0I,UAAAA,cAAc,EAAE,IAJpB;AAKI5G,UAAAA,KAAK,EAAEpC,MAAM,CAACiJ;AALlB,SADS,CAXH;AAoBV1B,QAAAA,OAAO,EAAE;AApBC,OAAd;;AAsBA,UAAI,CAAC,CAACQ,EAAE,GAAG,KAAKV,KAAL,CAAWH,KAAX,CAAN,MAA6B,IAA7B,IAAqCa,EAAE,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,EAAE,CAACd,KAAD,CAAjE,MAA8EP,SAAlF,EAA6F;AACzF,YAAI,KAAKW,KAAL,CAAWH,KAAX,MAAsBR,SAA1B,EAAqC;AACjC,eAAKW,KAAL,CAAWH,KAAX,IAAoB,EAApB;AACH;;AACD,aAAKG,KAAL,CAAWH,KAAX,EAAkBD,KAAlB,IAA2B,MAAM,KAAKG,MAAL,CAAYT,SAAZ,CAAsBhB,KAAtB,CAAjC;AACH;;AACD,YAAMxC,QAAQ,GAAG,KAAKkE,KAAL,CAAWH,KAAX,EAAkBD,KAAlB,CAAjB;AACA7G,MAAAA,KAAK,CAACqH,MAAN,CAAaC,IAAb,CAAmB,SAAQR,KAAM,IAAGD,KAAM,MAAxB,GAAgCpH,eAAe,CAACsD,QAAQ,CAACoE,OAAV,CAAjE;;AACA,UAAIpE,QAAQ,CAACyC,KAAT,KAAmB,SAAvB,EAAkC;AAC9B,cAAM,IAAIlG,iBAAJ,CAAsBiG,KAAtB,EAA6BxC,QAA7B,CAAN;AACH;;AACD,aAAOA,QAAP;AACH,KAnCe,CAAhB;AAoCH;;AAlKU","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DNSProver = exports.DEFAULT_ALGORITHMS = exports.DEFAULT_DIGESTS = exports.NoValidDnskeyError = exports.NoValidDsError = exports.ResponseCodeError = exports.SignedSet = exports.dohQuery = exports.answersToString = exports.getKeyTag = exports.DEFAULT_TRUST_ANCHORS = void 0;\nconst packet = require(\"dns-packet\");\nconst packet_types = require(\"dns-packet/types\");\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst log_1 = require(\"./log\");\nconst node_fetch_1 = require(\"node-fetch\");\nexports.DEFAULT_TRUST_ANCHORS = [\n    {\n        name: '.',\n        type: 'DS',\n        class: 'IN',\n        data: {\n            keyTag: 19036,\n            algorithm: 8,\n            digestType: 2,\n            digest: Buffer.from('49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5', 'hex')\n        }\n    },\n    {\n        name: '.',\n        type: 'DS',\n        class: 'IN',\n        data: {\n            keyTag: 20326,\n            algorithm: 8,\n            digestType: 2,\n            digest: Buffer.from('E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D', 'hex')\n        }\n    },\n];\nfunction encodeURLParams(p) {\n    return Object.entries(p).map(kv => kv.map(encodeURIComponent).join(\"=\")).join(\"&\");\n}\nfunction getKeyTag(key) {\n    const data = packet.dnskey.encode(key.data).slice(2);\n    let keytag = 0;\n    for (var i = 0; i < data.length; i++) {\n        var v = data[i];\n        if ((i & 1) !== 0) {\n            keytag += v;\n        }\n        else {\n            keytag += v << 8;\n        }\n    }\n    keytag += (keytag >> 16) & 0xffff;\n    keytag &= 0xffff;\n    return keytag;\n}\nexports.getKeyTag = getKeyTag;\nfunction answersToString(a) {\n    const s = a.map((a) => {\n        const prefix = `${a.name} ${a.ttl} ${a.class} ${a.type}`;\n        const d = a.data;\n        switch (a.type) {\n            case 'A':\n                return `${prefix} ${d}`;\n            case 'DNSKEY':\n                return `${prefix} ${d.flags} 3 ${d.algorithm} ${d.key.toString('base64')}; keyTag=${getKeyTag(a)}`;\n            case 'DS':\n                return `${prefix} ${d.keyTag} ${d.algorithm} ${d.digestType} ${d.digest.toString('hex')}`;\n            case 'OPT':\n                return `${prefix}`;\n            case 'RRSIG':\n                return `${prefix} ${d.typeCovered} ${d.algorithm} ${d.labels} ${d.originalTTL} ${d.expiration} ${d.inception} ${d.keyTag} ${d.signersName} ${d.signature.toString('base64')}`;\n            case 'TXT':\n                const texts = d.map((t) => `\"${t}\"`);\n                return `${prefix} ${texts.join(' ')}`;\n        }\n    });\n    return s.join('\\n');\n}\nexports.answersToString = answersToString;\nfunction dohQuery(url) {\n    return function getDNS(q) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buf = packet.encode(q);\n            const response = yield node_fetch_1.default(url + \"?\" + encodeURLParams({\n                ct: \"application/dns-udpwireformat\",\n                dns: buf.toString('base64'),\n                ts: Date.now().toString(),\n            }));\n            return packet.decode(Buffer.from(yield response.arrayBuffer()));\n        });\n    };\n}\nexports.dohQuery = dohQuery;\nclass SignedSet {\n    constructor(records, signature) {\n        this.records = records;\n        this.signature = signature;\n    }\n    static fromWire(data, signatureData) {\n        const { rdata, length } = this.readRrsigRdata(data);\n        rdata.signature = signatureData;\n        const rrs = [];\n        let off = length;\n        while (off < data.length) {\n            rrs.push(packet.answer.decode(data, off));\n            off += packet.answer.decode.bytes;\n        }\n        return new SignedSet(rrs, {\n            name: rrs[0].name,\n            type: 'RRSIG',\n            class: rrs[0].class,\n            data: rdata\n        });\n    }\n    static readRrsigRdata(data) {\n        let offset = 0;\n        return {\n            rdata: {\n                typeCovered: packet_types.toString(data.readUInt16BE(0)),\n                algorithm: data.readUInt8(2),\n                labels: data.readUInt8(3),\n                originalTTL: data.readUInt32BE(4),\n                expiration: data.readUInt32BE(8),\n                inception: data.readUInt32BE(12),\n                keyTag: data.readUInt16BE(16),\n                signersName: packet.name.decode(data, 18),\n                signature: Buffer.of(),\n            },\n            length: 18 + packet.name.decode.bytes,\n        };\n    }\n    toWire(withRrsig = true) {\n        let rrset = Buffer.concat(this.records\n            // https://tools.ietf.org/html/rfc4034#section-6\n            .sort((a, b) => {\n            const aenc = packet.record(a.type).encode(a.data).slice(2);\n            const benc = packet.record(b.type).encode(b.data).slice(2);\n            return aenc.compare(benc);\n        })\n            .map(r => packet.answer.encode(Object.assign(r, {\n            name: r.name.toLowerCase(),\n            ttl: this.signature.data.originalTTL // (5)\n        }))));\n        if (withRrsig) {\n            let rrsig = packet.rrsig.encode(Object.assign({}, this.signature.data, { signature: Buffer.of() })).slice(2);\n            return Buffer.concat([rrsig, rrset]);\n        }\n        else {\n            return rrset;\n        }\n    }\n}\nexports.SignedSet = SignedSet;\nclass ResponseCodeError extends Error {\n    constructor(query, response) {\n        super(\"DNS server responded with \" + response.rcode);\n        this.name = 'ResponseError';\n        this.query = query;\n        this.response = response;\n    }\n}\nexports.ResponseCodeError = ResponseCodeError;\nclass NoValidDsError extends Error {\n    constructor(keys) {\n        super(`Could not find a DS record to validate any RRSIG on DNSKEY records for ${keys[0].name}`);\n        this.keys = keys;\n        this.name = 'NoValidDsError';\n    }\n}\nexports.NoValidDsError = NoValidDsError;\nclass NoValidDnskeyError extends Error {\n    constructor(result) {\n        super(`Could not find a DNSKEY record to validate any RRSIG on ${result[0].type} records for ${result[0].name}`);\n        this.result = result;\n        this.name = 'NoValidDnskeyError';\n    }\n}\nexports.NoValidDnskeyError = NoValidDnskeyError;\nexports.DEFAULT_DIGESTS = {\n    // SHA256\n    1: {\n        name: 'SHA1',\n        f: (data, digest) => {\n            return true;\n        },\n    },\n    2: {\n        name: 'SHA256',\n        f: (data, digest) => {\n            return ethereumjs_util_1.sha256(data).equals(digest);\n        },\n    },\n};\nexports.DEFAULT_ALGORITHMS = {\n    5: {\n        name: 'RSASHA1Algorithm',\n        f: (key, data, sig) => {\n            return true;\n        },\n    },\n    7: {\n        name: 'RSASHA1Algorithm',\n        f: (key, data, sig) => {\n            return true;\n        },\n    },\n    8: {\n        name: 'RSASHA256',\n        f: (key, data, sig) => {\n            return true;\n        },\n    },\n    13: {\n        name: 'P256SHA256',\n        f: (key, data, sig) => {\n            return true;\n        },\n    },\n};\nfunction isTypedArray(array) {\n    return array.every((a) => a.type == 'DNSKEY');\n}\nfunction makeIndex(values, fn) {\n    const ret = {};\n    for (const value of values) {\n        const key = fn(value);\n        let list = ret[key];\n        if (list === undefined) {\n            list = ret[key] = [];\n        }\n        list.push(value);\n    }\n    return ret;\n}\nclass DNSProver {\n    constructor(sendQuery, digests = exports.DEFAULT_DIGESTS, algorithms = exports.DEFAULT_ALGORITHMS, anchors = exports.DEFAULT_TRUST_ANCHORS) {\n        this.sendQuery = sendQuery;\n        this.digests = digests;\n        this.algorithms = algorithms;\n        this.anchors = anchors;\n    }\n    static create(url) {\n        return new DNSProver(dohQuery(url));\n    }\n    queryWithProof(qtype, qname) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (new DNSQuery(this)).queryWithProof(qtype, qname);\n        });\n    }\n}\nexports.DNSProver = DNSProver;\nclass DNSQuery {\n    constructor(prover) {\n        this.cache = {};\n        this.prover = prover;\n    }\n    queryWithProof(qtype, qname) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.dnsQuery(qtype.toString(), qname);\n            const answers = response.answers.filter((r) => r.type === qtype && r.name === qname);\n            log_1.logger.info(`Found ${answers.length} ${qtype} records for ${qname}`);\n            if (answers.length === 0) {\n                return null;\n            }\n            const sigs = response.answers.filter((r) => r.type === 'RRSIG' && r.name === qname && r.data.typeCovered === qtype);\n            log_1.logger.info(`Found ${sigs.length} RRSIGs over ${qtype} RRSET`);\n            // If the records are self-signed, verify with DS records\n            if (isTypedArray(answers) && sigs.some((sig) => sig.name === sig.data.signersName)) {\n                log_1.logger.info(`DNSKEY RRSET on ${answers[0].name} is self-signed; attempting to verify with a DS in parent zone`);\n                return this.verifyWithDS(answers, sigs);\n            }\n            else {\n                return this.verifyRRSet(answers, sigs);\n            }\n        });\n    }\n    verifyRRSet(answers, sigs) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const sig of sigs) {\n                const algorithms = this.prover.algorithms;\n                log_1.logger.info(`Attempting to verify the ${answers[0].type} RRSET on ${answers[0].name} with RRSIG=${sig.data.keyTag}/${((_a = algorithms[sig.data.algorithm]) === null || _a === void 0 ? void 0 : _a.name) || sig.data.algorithm}`);\n                const ss = new SignedSet(answers, sig);\n                if (!(sig.data.algorithm in algorithms)) {\n                    log_1.logger.info(`Skipping RRSIG=${sig.data.keyTag}/${sig.data.algorithm} on ${answers[0].type} RRSET for ${answers[0].name}: Unknown algorithm`);\n                    continue;\n                }\n                const result = yield this.queryWithProof('DNSKEY', sig.data.signersName);\n                if (result === null) {\n                    throw new NoValidDnskeyError(answers);\n                }\n                const { answer, proofs } = result;\n                for (const key of answer.records) {\n                    if (this.verifySignature(ss, key)) {\n                        log_1.logger.info(`RRSIG=${sig.data.keyTag}/${algorithms[sig.data.algorithm].name} verifies the ${answers[0].type} RRSET on ${answers[0].name}`);\n                        proofs.push(answer);\n                        return { answer: ss, proofs: proofs };\n                    }\n                }\n            }\n            log_1.logger.warn(`Could not verify the ${answers[0].type} RRSET on ${answers[0].name} with any RRSIGs`);\n            throw new NoValidDnskeyError(answers);\n        });\n    }\n    verifyWithDS(keys, sigs) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyname = keys[0].name;\n            // Fetch the DS records to use\n            let answer;\n            let proofs;\n            if (keyname === '.') {\n                [answer, proofs] = [this.prover.anchors, []];\n            }\n            else {\n                const response = yield this.queryWithProof('DS', keyname);\n                if (response === null) {\n                    throw new NoValidDsError(keys);\n                }\n                answer = response.answer.records;\n                proofs = response.proofs;\n                proofs.push(response.answer);\n            }\n            // Index the passed in keys by key tag\n            const keysByTag = makeIndex(keys, getKeyTag);\n            const sigsByTag = makeIndex(sigs, (sig) => sig.data.keyTag);\n            // Iterate over the DS records looking for keys we can verify\n            const algorithms = this.prover.algorithms;\n            const digests = this.prover.digests;\n            for (let ds of answer) {\n                for (let key of keysByTag[ds.data.keyTag] || []) {\n                    if (this.checkDs(ds, key)) {\n                        log_1.logger.info(`DS=${ds.data.keyTag}/${((_a = algorithms[ds.data.algorithm]) === null || _a === void 0 ? void 0 : _a.name) || ds.data.algorithm}/${digests[ds.data.digestType].name} verifies DNSKEY=${ds.data.keyTag}/${((_b = algorithms[key.data.algorithm]) === null || _b === void 0 ? void 0 : _b.name) || key.data.algorithm} on ${key.name}`);\n                        for (let sig of sigsByTag[ds.data.keyTag] || []) {\n                            const ss = new SignedSet(keys, sig);\n                            if (this.verifySignature(ss, key)) {\n                                log_1.logger.info(`RRSIG=${sig.data.keyTag}/${algorithms[sig.data.algorithm].name} verifies the DNSKEY RRSET on ${keys[0].name}`);\n                                return { answer: ss, proofs: proofs };\n                            }\n                        }\n                    }\n                }\n            }\n            log_1.logger.warn(`Could not find any DS records to verify the DNSKEY RRSET on ${keys[0].name}`);\n            throw new NoValidDsError(keys);\n        });\n    }\n    verifySignature(answer, key) {\n        const keyTag = getKeyTag(key);\n        if (key.data.algorithm != answer.signature.data.algorithm || keyTag != answer.signature.data.keyTag || key.name != answer.signature.data.signersName) {\n            return false;\n        }\n        const signatureAlgorithm = this.prover.algorithms[key.data.algorithm];\n        if (signatureAlgorithm === undefined) {\n            log_1.logger.warn(`Unrecognised signature algorithm for DNSKEY=${keyTag}/${key.data.algorithm} on ${key.name}`);\n            return false;\n        }\n        return signatureAlgorithm.f(key.data.key, answer.toWire(), answer.signature.data.signature);\n    }\n    checkDs(ds, key) {\n        var _a;\n        if (key.data.algorithm != ds.data.algorithm || key.name != ds.name) {\n            return false;\n        }\n        const data = Buffer.concat([\n            packet.name.encode(ds.name),\n            packet.dnskey.encode(key.data).slice(2)\n        ]);\n        const digestAlgorithm = this.prover.digests[ds.data.digestType];\n        if (digestAlgorithm === undefined) {\n            log_1.logger.warn(`Unrecognised digest type for DS=${ds.data.keyTag}/${ds.data.digestType}/${((_a = this.prover.algorithms[ds.data.algorithm]) === null || _a === void 0 ? void 0 : _a.name) || ds.data.algorithm} on ${ds.name}`);\n            return false;\n        }\n        return digestAlgorithm.f(data, ds.data.digest);\n    }\n    dnsQuery(qtype, qname) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const query = {\n                type: 'query',\n                id: 1,\n                flags: packet.RECURSION_DESIRED,\n                questions: [\n                    {\n                        type: qtype,\n                        class: 'IN',\n                        name: qname,\n                    },\n                ],\n                additionals: [\n                    {\n                        type: 'OPT',\n                        class: 'IN',\n                        name: '.',\n                        udpPayloadSize: 4096,\n                        flags: packet.DNSSEC_OK,\n                    },\n                ],\n                answers: [],\n            };\n            if (((_a = this.cache[qname]) === null || _a === void 0 ? void 0 : _a[qtype]) === undefined) {\n                if (this.cache[qname] === undefined) {\n                    this.cache[qname] = {};\n                }\n                this.cache[qname][qtype] = yield this.prover.sendQuery(query);\n            }\n            const response = this.cache[qname][qtype];\n            log_1.logger.info(`Query[${qname} ${qtype}]:\\n` + answersToString(response.answers));\n            if (response.rcode !== 'NOERROR') {\n                throw new ResponseCodeError(query, response);\n            }\n            return response;\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"script"}