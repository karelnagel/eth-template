{"ast":null,"code":"(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n  } else {\n    root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n  }\n})(this, function (SourceMap, StackFrame) {\n  'use strict';\n  /**\n   * Make a X-Domain request to url and callback.\n   *\n   * @param {String} url\n   * @returns {Promise} with response text if fulfilled\n   */\n\n  function _xdr(url) {\n    return new Promise(function (resolve, reject) {\n      var req = new XMLHttpRequest();\n      req.open('get', url);\n      req.onerror = reject;\n\n      req.onreadystatechange = function onreadystatechange() {\n        if (req.readyState === 4) {\n          if (req.status >= 200 && req.status < 300) {\n            resolve(req.responseText);\n          } else {\n            reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n          }\n        }\n      };\n\n      req.send();\n    });\n  }\n  /**\n   * Convert a Base64-encoded string into its original representation.\n   * Used for inline sourcemaps.\n   *\n   * @param {String} b64str Base-64 encoded string\n   * @returns {String} original representation of the base64-encoded string.\n   */\n\n\n  function _atob(b64str) {\n    if (typeof window !== 'undefined' && window.atob) {\n      return window.atob(b64str);\n    } else {\n      throw new Error('You must supply a polyfill for window.atob in this environment');\n    }\n  }\n\n  function _parseJson(string) {\n    if (typeof JSON !== 'undefined' && JSON.parse) {\n      return JSON.parse(string);\n    } else {\n      throw new Error('You must supply a polyfill for JSON.parse in this environment');\n    }\n  }\n\n  function _findFunctionName(source, lineNumber\n  /*, columnNumber*/\n  ) {\n    // function {name}({args}) m[1]=name m[2]=args\n    var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/; // {name} = function ({args}) TODO args capture\n\n    var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/; // {name} = eval()\n\n    var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n    var lines = source.split('\\n'); // Walk backwards in the source lines until we find the line which matches one of the patterns above\n\n    var code = '';\n    var maxLines = Math.min(lineNumber, 20);\n    var m;\n\n    for (var i = 0; i < maxLines; ++i) {\n      // lineNo is 1-based, source[] is 0-based\n      var line = lines[lineNumber - i - 1];\n      var commentPos = line.indexOf('//');\n\n      if (commentPos >= 0) {\n        line = line.substr(0, commentPos);\n      }\n\n      if (line) {\n        code = line + code;\n        m = reFunctionExpression.exec(code);\n\n        if (m && m[1]) {\n          return m[1];\n        }\n\n        m = reFunctionDeclaration.exec(code);\n\n        if (m && m[1]) {\n          return m[1];\n        }\n\n        m = reFunctionEvaluation.exec(code);\n\n        if (m && m[1]) {\n          return m[1];\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  function _ensureSupportedEnvironment() {\n    if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n      throw new Error('Unable to consume source maps in older browsers');\n    }\n  }\n\n  function _ensureStackFrameIsLegit(stackframe) {\n    if (typeof stackframe !== 'object') {\n      throw new TypeError('Given StackFrame is not an object');\n    } else if (typeof stackframe.fileName !== 'string') {\n      throw new TypeError('Given file name is not a String');\n    } else if (typeof stackframe.lineNumber !== 'number' || stackframe.lineNumber % 1 !== 0 || stackframe.lineNumber < 1) {\n      throw new TypeError('Given line number must be a positive integer');\n    } else if (typeof stackframe.columnNumber !== 'number' || stackframe.columnNumber % 1 !== 0 || stackframe.columnNumber < 0) {\n      throw new TypeError('Given column number must be a non-negative integer');\n    }\n\n    return true;\n  }\n\n  function _findSourceMappingURL(source) {\n    var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n\n    if (m && m[1]) {\n      return m[1];\n    } else {\n      throw new Error('sourceMappingURL not found');\n    }\n  }\n\n  function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {\n    return new Promise(function (resolve, reject) {\n      var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n      var loc = mapConsumer.originalPositionFor({\n        line: stackframe.lineNumber,\n        column: stackframe.columnNumber\n      });\n\n      if (loc.source) {\n        var mappedSource = mapConsumer.sourceContentFor(loc.source);\n\n        if (mappedSource) {\n          sourceCache[loc.source] = mappedSource;\n        }\n\n        resolve(new StackFrame(loc.name || stackframe.functionName, stackframe.args, loc.source, loc.line, loc.column));\n      } else {\n        reject(new Error('Could not get original source for given stackframe and source map'));\n      }\n    });\n  }\n  /**\n   * @constructor\n   * @param {Object} opts\n   *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n   *      opts.offline = True to prevent network requests.\n   *              Best effort without sources or source maps.\n   *      opts.ajax = Promise returning function to make X-Domain requests\n   */\n\n\n  return function StackTraceGPS(opts) {\n    if (!(this instanceof StackTraceGPS)) {\n      return new StackTraceGPS(opts);\n    }\n\n    opts = opts || {};\n    this.sourceCache = opts.sourceCache || {};\n    this.ajax = opts.ajax || _xdr;\n    this._atob = opts.atob || _atob;\n\n    this._get = function _get(location) {\n      return new Promise(function (resolve, reject) {\n        var isDataUrl = location.substr(0, 5) === 'data:';\n\n        if (this.sourceCache[location]) {\n          resolve(this.sourceCache[location]);\n        } else if (opts.offline && !isDataUrl) {\n          reject(new Error('Cannot make network requests in offline mode'));\n        } else {\n          if (isDataUrl) {\n            // data URLs can have parameters.\n            // see http://tools.ietf.org/html/rfc2397\n            var supportedEncodingRegexp = /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n            var match = location.match(supportedEncodingRegexp);\n\n            if (match) {\n              var sourceMapStart = match[0].length;\n              var encodedSource = location.substr(sourceMapStart);\n\n              var source = this._atob(encodedSource);\n\n              this.sourceCache[location] = source;\n              resolve(source);\n            } else {\n              reject(new Error('The encoding of the inline sourcemap is not supported'));\n            }\n          } else {\n            var xhrPromise = this.ajax(location, {\n              method: 'get'\n            }); // Cache the Promise to prevent duplicate in-flight requests\n\n            this.sourceCache[location] = xhrPromise;\n            xhrPromise.then(resolve, reject);\n          }\n        }\n      }.bind(this));\n    };\n    /**\n     * Given a StackFrame, enhance function name and use source maps for a\n     * better StackFrame.\n     *\n     * @param {StackFrame} stackframe object\n     * @returns {Promise} that resolves with with source-mapped StackFrame\n     */\n\n\n    this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n      return new Promise(function (resolve, reject) {\n        this.getMappedLocation(stackframe).then(function (mappedStackFrame) {\n          function resolveMappedStackFrame() {\n            resolve(mappedStackFrame);\n          }\n\n          this.findFunctionName(mappedStackFrame).then(resolve, resolveMappedStackFrame)['catch'](resolveMappedStackFrame);\n        }.bind(this), reject);\n      }.bind(this));\n    };\n    /**\n     * Given a StackFrame, guess function name from location information.\n     *\n     * @param {StackFrame} stackframe\n     * @returns {Promise} that resolves with enhanced StackFrame.\n     */\n\n\n    this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n      return new Promise(function (resolve, reject) {\n        _ensureStackFrameIsLegit(stackframe);\n\n        this._get(stackframe.fileName).then(function getSourceCallback(source) {\n          var lineNumber = stackframe.lineNumber;\n          var columnNumber = stackframe.columnNumber;\n\n          var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber); // Only replace functionName if we found something\n\n\n          if (guessedFunctionName) {\n            resolve(new StackFrame(guessedFunctionName, stackframe.args, stackframe.fileName, lineNumber, columnNumber));\n          } else {\n            resolve(stackframe);\n          }\n        }, reject)['catch'](reject);\n      }.bind(this));\n    };\n    /**\n     * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n     *\n     * @param {StackFrame} stackframe\n     * @returns {Promise} that resolves with enhanced StackFrame.\n     */\n\n\n    this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n      return new Promise(function (resolve, reject) {\n        _ensureSupportedEnvironment();\n\n        _ensureStackFrameIsLegit(stackframe);\n\n        var sourceCache = this.sourceCache;\n        var fileName = stackframe.fileName;\n\n        this._get(fileName).then(function (source) {\n          var sourceMappingURL = _findSourceMappingURL(source);\n\n          var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n          var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n          if (sourceMappingURL[0] !== '/' && !isDataUrl && !/^https?:\\/\\/|^\\/\\//i.test(sourceMappingURL)) {\n            sourceMappingURL = base + sourceMappingURL;\n          }\n\n          this._get(sourceMappingURL).then(function (sourceMap) {\n            if (typeof sourceMap === 'string') {\n              sourceMap = _parseJson(sourceMap.replace(/^\\)\\]\\}'/, ''));\n            }\n\n            if (typeof sourceMap.sourceRoot === 'undefined') {\n              sourceMap.sourceRoot = base;\n            }\n\n            _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache).then(resolve)['catch'](function () {\n              resolve(stackframe);\n            });\n          }, reject)['catch'](reject);\n        }.bind(this), reject)['catch'](reject);\n      }.bind(this));\n    };\n  };\n});","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/stacktrace-gps/stacktrace-gps.js"],"names":["root","factory","define","amd","exports","module","require","StackTraceGPS","SourceMap","sourceMap","StackFrame","_xdr","url","Promise","resolve","reject","req","XMLHttpRequest","open","onerror","onreadystatechange","readyState","status","responseText","Error","send","_atob","b64str","window","atob","_parseJson","string","JSON","parse","_findFunctionName","source","lineNumber","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","lines","split","code","maxLines","Math","min","m","i","line","commentPos","indexOf","substr","exec","undefined","_ensureSupportedEnvironment","Object","defineProperty","create","_ensureStackFrameIsLegit","stackframe","TypeError","fileName","columnNumber","_findSourceMappingURL","_extractLocationInfoFromSourceMap","rawSourceMap","sourceCache","mapConsumer","SourceMapConsumer","loc","originalPositionFor","column","mappedSource","sourceContentFor","name","functionName","args","opts","ajax","_get","location","isDataUrl","offline","supportedEncodingRegexp","match","sourceMapStart","length","encodedSource","xhrPromise","method","then","bind","pinpoint","StackTraceGPS$$pinpoint","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","StackTraceGPS$$findFunctionName","getSourceCallback","guessedFunctionName","StackTraceGPS$$getMappedLocation","sourceMappingURL","base","substring","lastIndexOf","test","replace","sourceRoot"],"mappings":"AAAC,WAASA,IAAT,EAAeC,OAAf,EAAwB;AACrB,eADqB,CAErB;;AAEA;;AACA,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA3C,EAAgD;AAC5CD,IAAAA,MAAM,CAAC,gBAAD,EAAmB,CAAC,YAAD,EAAe,YAAf,CAAnB,EAAiDD,OAAjD,CAAN;AACH,GAFD,MAEO,IAAI,OAAOG,OAAP,KAAmB,QAAvB,EAAiC;AACpCC,IAAAA,MAAM,CAACD,OAAP,GAAiBH,OAAO,CAACK,OAAO,CAAC,oCAAD,CAAR,EAAgDA,OAAO,CAAC,YAAD,CAAvD,CAAxB;AACH,GAFM,MAEA;AACHN,IAAAA,IAAI,CAACO,aAAL,GAAqBN,OAAO,CAACD,IAAI,CAACQ,SAAL,IAAkBR,IAAI,CAACS,SAAxB,EAAmCT,IAAI,CAACU,UAAxC,CAA5B;AACH;AACJ,CAZA,EAYC,IAZD,EAYO,UAASF,SAAT,EAAoBE,UAApB,EAAgC;AACpC;AAEA;AACJ;AACA;AACA;AACA;AACA;;AACI,WAASC,IAAT,CAAcC,GAAd,EAAmB;AACf,WAAO,IAAIC,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzC,UAAIC,GAAG,GAAG,IAAIC,cAAJ,EAAV;AACAD,MAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgBN,GAAhB;AACAI,MAAAA,GAAG,CAACG,OAAJ,GAAcJ,MAAd;;AACAC,MAAAA,GAAG,CAACI,kBAAJ,GAAyB,SAASA,kBAAT,GAA8B;AACnD,YAAIJ,GAAG,CAACK,UAAJ,KAAmB,CAAvB,EAA0B;AACtB,cAAIL,GAAG,CAACM,MAAJ,IAAc,GAAd,IAAqBN,GAAG,CAACM,MAAJ,GAAa,GAAtC,EAA2C;AACvCR,YAAAA,OAAO,CAACE,GAAG,CAACO,YAAL,CAAP;AACH,WAFD,MAEO;AACHR,YAAAA,MAAM,CAAC,IAAIS,KAAJ,CAAU,kBAAkBR,GAAG,CAACM,MAAtB,GAA+B,cAA/B,GAAgDV,GAA1D,CAAD,CAAN;AACH;AACJ;AACJ,OARD;;AASAI,MAAAA,GAAG,CAACS,IAAJ;AACH,KAdM,CAAP;AAgBH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASC,KAAT,CAAeC,MAAf,EAAuB;AACnB,QAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,IAA5C,EAAkD;AAC9C,aAAOD,MAAM,CAACC,IAAP,CAAYF,MAAZ,CAAP;AACH,KAFD,MAEO;AACH,YAAM,IAAIH,KAAJ,CAAU,gEAAV,CAAN;AACH;AACJ;;AAED,WAASM,UAAT,CAAoBC,MAApB,EAA4B;AACxB,QAAI,OAAOC,IAAP,KAAgB,WAAhB,IAA+BA,IAAI,CAACC,KAAxC,EAA+C;AAC3C,aAAOD,IAAI,CAACC,KAAL,CAAWF,MAAX,CAAP;AACH,KAFD,MAEO;AACH,YAAM,IAAIP,KAAJ,CAAU,+DAAV,CAAN;AACH;AACJ;;AAED,WAASU,iBAAT,CAA2BC,MAA3B,EAAmCC;AAAU;AAA7C,IAAiE;AAC7D;AACA,QAAIC,qBAAqB,GAAG,mCAA5B,CAF6D,CAG7D;;AACA,QAAIC,oBAAoB,GAAG,0DAA3B,CAJ6D,CAK7D;;AACA,QAAIC,oBAAoB,GAAG,uEAA3B;AACA,QAAIC,KAAK,GAAGL,MAAM,CAACM,KAAP,CAAa,IAAb,CAAZ,CAP6D,CAS7D;;AACA,QAAIC,IAAI,GAAG,EAAX;AACA,QAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAST,UAAT,EAAqB,EAArB,CAAf;AACA,QAAIU,CAAJ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAApB,EAA8B,EAAEI,CAAhC,EAAmC;AAC/B;AACA,UAAIC,IAAI,GAAGR,KAAK,CAACJ,UAAU,GAAGW,CAAb,GAAiB,CAAlB,CAAhB;AACA,UAAIE,UAAU,GAAGD,IAAI,CAACE,OAAL,CAAa,IAAb,CAAjB;;AACA,UAAID,UAAU,IAAI,CAAlB,EAAqB;AACjBD,QAAAA,IAAI,GAAGA,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAeF,UAAf,CAAP;AACH;;AAED,UAAID,IAAJ,EAAU;AACNN,QAAAA,IAAI,GAAGM,IAAI,GAAGN,IAAd;AACAI,QAAAA,CAAC,GAAGR,oBAAoB,CAACc,IAArB,CAA0BV,IAA1B,CAAJ;;AACA,YAAII,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAV,EAAe;AACX,iBAAOA,CAAC,CAAC,CAAD,CAAR;AACH;;AACDA,QAAAA,CAAC,GAAGT,qBAAqB,CAACe,IAAtB,CAA2BV,IAA3B,CAAJ;;AACA,YAAII,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAV,EAAe;AACX,iBAAOA,CAAC,CAAC,CAAD,CAAR;AACH;;AACDA,QAAAA,CAAC,GAAGP,oBAAoB,CAACa,IAArB,CAA0BV,IAA1B,CAAJ;;AACA,YAAII,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAV,EAAe;AACX,iBAAOA,CAAC,CAAC,CAAD,CAAR;AACH;AACJ;AACJ;;AACD,WAAOO,SAAP;AACH;;AAED,WAASC,2BAAT,GAAuC;AACnC,QAAI,OAAOC,MAAM,CAACC,cAAd,KAAiC,UAAjC,IAA+C,OAAOD,MAAM,CAACE,MAAd,KAAyB,UAA5E,EAAwF;AACpF,YAAM,IAAIjC,KAAJ,CAAU,iDAAV,CAAN;AACH;AACJ;;AAED,WAASkC,wBAAT,CAAkCC,UAAlC,EAA8C;AAC1C,QAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAChC,YAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACH,KAFD,MAEO,IAAI,OAAOD,UAAU,CAACE,QAAlB,KAA+B,QAAnC,EAA6C;AAChD,YAAM,IAAID,SAAJ,CAAc,iCAAd,CAAN;AACH,KAFM,MAEA,IAAI,OAAOD,UAAU,CAACvB,UAAlB,KAAiC,QAAjC,IACPuB,UAAU,CAACvB,UAAX,GAAwB,CAAxB,KAA8B,CADvB,IAEPuB,UAAU,CAACvB,UAAX,GAAwB,CAFrB,EAEwB;AAC3B,YAAM,IAAIwB,SAAJ,CAAc,8CAAd,CAAN;AACH,KAJM,MAIA,IAAI,OAAOD,UAAU,CAACG,YAAlB,KAAmC,QAAnC,IACPH,UAAU,CAACG,YAAX,GAA0B,CAA1B,KAAgC,CADzB,IAEPH,UAAU,CAACG,YAAX,GAA0B,CAFvB,EAE0B;AAC7B,YAAM,IAAIF,SAAJ,CAAc,oDAAd,CAAN;AACH;;AACD,WAAO,IAAP;AACH;;AAED,WAASG,qBAAT,CAA+B5B,MAA/B,EAAuC;AACnC,QAAIW,CAAC,GAAG,4CAA4CM,IAA5C,CAAiDjB,MAAjD,CAAR;;AACA,QAAIW,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAV,EAAe;AACX,aAAOA,CAAC,CAAC,CAAD,CAAR;AACH,KAFD,MAEO;AACH,YAAM,IAAItB,KAAJ,CAAU,4BAAV,CAAN;AACH;AACJ;;AAED,WAASwC,iCAAT,CAA2CL,UAA3C,EAAuDM,YAAvD,EAAqEC,WAArE,EAAkF;AAC9E,WAAO,IAAIrD,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzC,UAAIoD,WAAW,GAAG,IAAI3D,SAAS,CAAC4D,iBAAd,CAAgCH,YAAhC,CAAlB;AAEA,UAAII,GAAG,GAAGF,WAAW,CAACG,mBAAZ,CAAgC;AACtCtB,QAAAA,IAAI,EAAEW,UAAU,CAACvB,UADqB;AAEtCmC,QAAAA,MAAM,EAAEZ,UAAU,CAACG;AAFmB,OAAhC,CAAV;;AAKA,UAAIO,GAAG,CAAClC,MAAR,EAAgB;AACZ,YAAIqC,YAAY,GAAGL,WAAW,CAACM,gBAAZ,CAA6BJ,GAAG,CAAClC,MAAjC,CAAnB;;AACA,YAAIqC,YAAJ,EAAkB;AACdN,UAAAA,WAAW,CAACG,GAAG,CAAClC,MAAL,CAAX,GAA0BqC,YAA1B;AACH;;AACD1D,QAAAA,OAAO,CACH,IAAIJ,UAAJ,CACI2D,GAAG,CAACK,IAAJ,IAAYf,UAAU,CAACgB,YAD3B,EAEIhB,UAAU,CAACiB,IAFf,EAGIP,GAAG,CAAClC,MAHR,EAIIkC,GAAG,CAACrB,IAJR,EAKIqB,GAAG,CAACE,MALR,CADG,CAAP;AAOH,OAZD,MAYO;AACHxD,QAAAA,MAAM,CAAC,IAAIS,KAAJ,CAAU,mEAAV,CAAD,CAAN;AACH;AACJ,KAvBM,CAAP;AAwBH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,SAAO,SAASjB,aAAT,CAAuBsE,IAAvB,EAA6B;AAChC,QAAI,EAAE,gBAAgBtE,aAAlB,CAAJ,EAAsC;AAClC,aAAO,IAAIA,aAAJ,CAAkBsE,IAAlB,CAAP;AACH;;AACDA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,SAAKX,WAAL,GAAmBW,IAAI,CAACX,WAAL,IAAoB,EAAvC;AAEA,SAAKY,IAAL,GAAYD,IAAI,CAACC,IAAL,IAAanE,IAAzB;AAEA,SAAKe,KAAL,GAAamD,IAAI,CAAChD,IAAL,IAAaH,KAA1B;;AAEA,SAAKqD,IAAL,GAAY,SAASA,IAAT,CAAcC,QAAd,EAAwB;AAChC,aAAO,IAAInE,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzC,YAAIkE,SAAS,GAAGD,QAAQ,CAAC7B,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,OAA1C;;AACA,YAAI,KAAKe,WAAL,CAAiBc,QAAjB,CAAJ,EAAgC;AAC5BlE,UAAAA,OAAO,CAAC,KAAKoD,WAAL,CAAiBc,QAAjB,CAAD,CAAP;AACH,SAFD,MAEO,IAAIH,IAAI,CAACK,OAAL,IAAgB,CAACD,SAArB,EAAgC;AACnClE,UAAAA,MAAM,CAAC,IAAIS,KAAJ,CAAU,8CAAV,CAAD,CAAN;AACH,SAFM,MAEA;AACH,cAAIyD,SAAJ,EAAe;AACX;AACA;AACA,gBAAIE,uBAAuB,GACvB,8CADJ;AAEA,gBAAIC,KAAK,GAAGJ,QAAQ,CAACI,KAAT,CAAeD,uBAAf,CAAZ;;AACA,gBAAIC,KAAJ,EAAW;AACP,kBAAIC,cAAc,GAAGD,KAAK,CAAC,CAAD,CAAL,CAASE,MAA9B;AACA,kBAAIC,aAAa,GAAGP,QAAQ,CAAC7B,MAAT,CAAgBkC,cAAhB,CAApB;;AACA,kBAAIlD,MAAM,GAAG,KAAKT,KAAL,CAAW6D,aAAX,CAAb;;AACA,mBAAKrB,WAAL,CAAiBc,QAAjB,IAA6B7C,MAA7B;AACArB,cAAAA,OAAO,CAACqB,MAAD,CAAP;AACH,aAND,MAMO;AACHpB,cAAAA,MAAM,CAAC,IAAIS,KAAJ,CAAU,uDAAV,CAAD,CAAN;AACH;AACJ,WAfD,MAeO;AACH,gBAAIgE,UAAU,GAAG,KAAKV,IAAL,CAAUE,QAAV,EAAoB;AAACS,cAAAA,MAAM,EAAE;AAAT,aAApB,CAAjB,CADG,CAEH;;AACA,iBAAKvB,WAAL,CAAiBc,QAAjB,IAA6BQ,UAA7B;AACAA,YAAAA,UAAU,CAACE,IAAX,CAAgB5E,OAAhB,EAAyBC,MAAzB;AACH;AACJ;AACJ,OA7BkB,CA6BjB4E,IA7BiB,CA6BZ,IA7BY,CAAZ,CAAP;AA8BH,KA/BD;AAiCA;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,SAAKC,QAAL,GAAgB,SAASC,uBAAT,CAAiClC,UAAjC,EAA6C;AACzD,aAAO,IAAI9C,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzC,aAAK+E,iBAAL,CAAuBnC,UAAvB,EAAmC+B,IAAnC,CAAwC,UAASK,gBAAT,EAA2B;AAC/D,mBAASC,uBAAT,GAAmC;AAC/BlF,YAAAA,OAAO,CAACiF,gBAAD,CAAP;AACH;;AAED,eAAKE,gBAAL,CAAsBF,gBAAtB,EACKL,IADL,CACU5E,OADV,EACmBkF,uBADnB,EAEK,OAFL,EAEcA,uBAFd;AAGH,SARuC,CAQtCL,IARsC,CAQjC,IARiC,CAAxC,EAQc5E,MARd;AASH,OAVkB,CAUjB4E,IAViB,CAUZ,IAVY,CAAZ,CAAP;AAWH,KAZD;AAcA;AACR;AACA;AACA;AACA;AACA;;;AACQ,SAAKM,gBAAL,GAAwB,SAASC,+BAAT,CAAyCvC,UAAzC,EAAqD;AACzE,aAAO,IAAI9C,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzC2C,QAAAA,wBAAwB,CAACC,UAAD,CAAxB;;AACA,aAAKoB,IAAL,CAAUpB,UAAU,CAACE,QAArB,EAA+B6B,IAA/B,CAAoC,SAASS,iBAAT,CAA2BhE,MAA3B,EAAmC;AACnE,cAAIC,UAAU,GAAGuB,UAAU,CAACvB,UAA5B;AACA,cAAI0B,YAAY,GAAGH,UAAU,CAACG,YAA9B;;AACA,cAAIsC,mBAAmB,GAAGlE,iBAAiB,CAACC,MAAD,EAASC,UAAT,EAAqB0B,YAArB,CAA3C,CAHmE,CAInE;;;AACA,cAAIsC,mBAAJ,EAAyB;AACrBtF,YAAAA,OAAO,CAAC,IAAIJ,UAAJ,CAAe0F,mBAAf,EACJzC,UAAU,CAACiB,IADP,EAEJjB,UAAU,CAACE,QAFP,EAGJzB,UAHI,EAIJ0B,YAJI,CAAD,CAAP;AAKH,WAND,MAMO;AACHhD,YAAAA,OAAO,CAAC6C,UAAD,CAAP;AACH;AACJ,SAdD,EAcG5C,MAdH,EAcW,OAdX,EAcoBA,MAdpB;AAeH,OAjBkB,CAiBjB4E,IAjBiB,CAiBZ,IAjBY,CAAZ,CAAP;AAkBH,KAnBD;AAqBA;AACR;AACA;AACA;AACA;AACA;;;AACQ,SAAKG,iBAAL,GAAyB,SAASO,gCAAT,CAA0C1C,UAA1C,EAAsD;AAC3E,aAAO,IAAI9C,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzCuC,QAAAA,2BAA2B;;AAC3BI,QAAAA,wBAAwB,CAACC,UAAD,CAAxB;;AAEA,YAAIO,WAAW,GAAG,KAAKA,WAAvB;AACA,YAAIL,QAAQ,GAAGF,UAAU,CAACE,QAA1B;;AACA,aAAKkB,IAAL,CAAUlB,QAAV,EAAoB6B,IAApB,CAAyB,UAASvD,MAAT,EAAiB;AACtC,cAAImE,gBAAgB,GAAGvC,qBAAqB,CAAC5B,MAAD,CAA5C;;AACA,cAAI8C,SAAS,GAAGqB,gBAAgB,CAACnD,MAAjB,CAAwB,CAAxB,EAA2B,CAA3B,MAAkC,OAAlD;AACA,cAAIoD,IAAI,GAAG1C,QAAQ,CAAC2C,SAAT,CAAmB,CAAnB,EAAsB3C,QAAQ,CAAC4C,WAAT,CAAqB,GAArB,IAA4B,CAAlD,CAAX;;AAEA,cAAIH,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,GAAxB,IAA+B,CAACrB,SAAhC,IAA6C,CAAE,qBAAD,CAAwByB,IAAxB,CAA6BJ,gBAA7B,CAAlD,EAAkG;AAC9FA,YAAAA,gBAAgB,GAAGC,IAAI,GAAGD,gBAA1B;AACH;;AAED,eAAKvB,IAAL,CAAUuB,gBAAV,EAA4BZ,IAA5B,CAAiC,UAASjF,SAAT,EAAoB;AACjD,gBAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AAC/BA,cAAAA,SAAS,GAAGqB,UAAU,CAACrB,SAAS,CAACkG,OAAV,CAAkB,UAAlB,EAA8B,EAA9B,CAAD,CAAtB;AACH;;AACD,gBAAI,OAAOlG,SAAS,CAACmG,UAAjB,KAAgC,WAApC,EAAiD;AAC7CnG,cAAAA,SAAS,CAACmG,UAAV,GAAuBL,IAAvB;AACH;;AAEDvC,YAAAA,iCAAiC,CAACL,UAAD,EAAalD,SAAb,EAAwByD,WAAxB,CAAjC,CACKwB,IADL,CACU5E,OADV,EACmB,OADnB,EAC4B,YAAW;AACnCA,cAAAA,OAAO,CAAC6C,UAAD,CAAP;AACH,aAHD;AAIH,WAZD,EAYG5C,MAZH,EAYW,OAZX,EAYoBA,MAZpB;AAaH,SAtBwB,CAsBvB4E,IAtBuB,CAsBlB,IAtBkB,CAAzB,EAsBc5E,MAtBd,EAsBsB,OAtBtB,EAsB+BA,MAtB/B;AAuBH,OA7BkB,CA6BjB4E,IA7BiB,CA6BZ,IA7BY,CAAZ,CAAP;AA8BH,KA/BD;AAgCH,GAnID;AAoIH,CA9SA,CAAD","sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if (req.status >= 200 && req.status < 300) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        // function {name}({args}) m[1]=name m[2]=args\n        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n        // {name} = function ({args}) TODO args capture\n        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n        // {name} = eval()\n        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        var m;\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                m = reFunctionExpression.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionDeclaration.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionEvaluation.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n        if (m && m[1]) {\n            return m[1];\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n\n            var loc = mapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                var mappedSource = mapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n                resolve(\n                    new StackFrame(\n                        loc.name || stackframe.functionName,\n                        stackframe.args,\n                        loc.source,\n                        loc.line,\n                        loc.column));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame(guessedFunctionName,\n                            stackframe.args,\n                            stackframe.fileName,\n                            lineNumber,\n                            columnNumber));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = base + sourceMappingURL;\n                    }\n\n                    this._get(sourceMappingURL).then(function(sourceMap) {\n                        if (typeof sourceMap === 'string') {\n                            sourceMap = _parseJson(sourceMap.replace(/^\\)\\]\\}'/, ''));\n                        }\n                        if (typeof sourceMap.sourceRoot === 'undefined') {\n                            sourceMap.sourceRoot = base;\n                        }\n\n                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)\n                            .then(resolve)['catch'](function() {\n                            resolve(stackframe);\n                        });\n                    }, reject)['catch'](reject);\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n"]},"metadata":{},"sourceType":"script"}