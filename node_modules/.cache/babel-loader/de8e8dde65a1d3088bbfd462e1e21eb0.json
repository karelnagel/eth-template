{"ast":null,"code":"// @ts-check\n\n/* eslint-disable guard-for-in */\n\n/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst multibase = require('multibase');\n\nconst varint = require('varint');\n\nconst {\n  names\n} = require('./constants');\n\nconst {\n  TextDecoder\n} = require('web-encoding');\n\nconst textDecoder = new TextDecoder();\nconst codes = {};\n\nfor (const key in names) {\n  codes[names[key]] = key;\n}\n\nexports.names = names;\nexports.codes = Object.freeze(codes);\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\n\nexports.toHexString = function toHexString(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  const buffer = Buffer.isBuffer(hash) ? hash : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength);\n  return buffer.toString('hex');\n};\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\n\n\nexports.fromHexString = function fromHexString(hash) {\n  return Buffer.from(hash, 'hex');\n};\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\n\n\nexports.toB58String = function toB58String(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1);\n};\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Buffer}\n */\n\n\nexports.fromB58String = function fromB58String(hash) {\n  const encoded = hash instanceof Uint8Array ? textDecoder.decode(hash) : hash;\n  return multibase.decode('z' + encoded);\n};\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\n\n\nexports.decode = function decode(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array');\n  }\n\n  let buf = Buffer.isBuffer(bytes) ? bytes : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n\n  const code = varint.decode(buf);\n\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);\n  }\n\n  buf = buf.slice(varint.decode.bytes);\n  const len = varint.decode(buf);\n\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`);\n  }\n\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`);\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: buf\n  };\n};\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\n\n\nexports.encode = function encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  } // ensure it's a hashfunction code.\n\n\n  const hashfn = exports.coerceCode(code);\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array');\n  }\n\n  if (length == null) {\n    length = digest.length;\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n\n  const hash = varint.encode(hashfn);\n  const len = varint.encode(length);\n  const buffer = Buffer.alloc(hash.length + len.length + digest.length);\n  buffer.set(hash, 0);\n  buffer.set(len, hash.length);\n  buffer.set(digest, hash.length + len.length);\n  return buffer;\n};\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\n\n\nexports.coerceCode = function coerceCode(name) {\n  let code = name;\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`);\n    }\n\n    code = names[name];\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`);\n  }\n\n  if (codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`);\n  }\n\n  return code;\n};\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nexports.isAppCode = function appCode(code) {\n  return code > 0 && code < 0x10;\n};\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nexports.isValidCode = function validCode(code) {\n  if (exports.isAppCode(code)) {\n    return true;\n  }\n\n  if (codes[code]) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\n\n\nfunction validate(multihash) {\n  exports.decode(multihash); // throws if bad.\n}\n\nexports.validate = validate;\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Buffer}\n * @throws {Error}\n */\n\nexports.prefix = function prefix(multihash) {\n  validate(multihash);\n  return Buffer.from(multihash.buffer, multihash.byteOffset, 2);\n};","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js"],"names":["Buffer","require","multibase","varint","names","TextDecoder","textDecoder","codes","key","exports","Object","freeze","toHexString","hash","Uint8Array","Error","buffer","isBuffer","from","byteOffset","byteLength","toString","fromHexString","toB58String","decode","encode","slice","fromB58String","encoded","bytes","buf","length","code","isValidCode","len","name","digest","undefined","hashfn","coerceCode","alloc","set","isAppCode","appCode","validCode","validate","multihash","prefix"],"mappings":"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","sourcesContent":["// @ts-check\n/* eslint-disable guard-for-in */\n/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst { TextDecoder } = require('web-encoding')\n\nconst textDecoder = new TextDecoder()\nconst codes = {}\n\nfor (const key in names) {\n  codes[names[key]] = key\n}\nexports.names = names\nexports.codes = Object.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  const buffer = Buffer.isBuffer(hash)\n    ? hash\n    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)\n\n  return buffer.toString('hex')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString (hash) {\n  return Buffer.from(hash, 'hex')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? textDecoder.decode(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n  let buf = Buffer.isBuffer(bytes)\n    ? bytes\n    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = varint.decode(buf)\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  const len = varint.decode(buf)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: buf\n  }\n}\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  const buffer = Buffer.alloc(hash.length + len.length + digest.length)\n  buffer.set(hash, 0)\n  buffer.set(len, hash.length)\n  buffer.set(digest, hash.length + len.length)\n  return buffer\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode (code) {\n  if (exports.isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  exports.decode(multihash) // throws if bad.\n}\nexports.validate = validate\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Buffer}\n * @throws {Error}\n */\nexports.prefix = function prefix (multihash) {\n  validate(multihash)\n\n  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)\n}\n"]},"metadata":{},"sourceType":"script"}