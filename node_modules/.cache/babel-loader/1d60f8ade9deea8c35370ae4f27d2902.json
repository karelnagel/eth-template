{"ast":null,"code":"import has from 'lodash/has';\nimport { Contract, utils } from 'ethers';\nimport { getWeb3, getNetworkId, getProvider, getAccount, getSigner } from './web3';\nimport { formatsByName } from '@ensdomains/address-encoder';\nimport { abi as ensContract } from '@ensdomains/contracts/abis/ens/ENS.json';\nimport { decryptHashes } from './preimage';\nimport { uniq, getEnsStartBlock, checkLabels, mergeLabels, emptyAddress, isDecrypted, namehash, labelhash } from './utils';\nimport { encodeLabelhash } from './utils/labelhash';\nimport { getTestRegistrarContract, getReverseRegistrarContract, getENSContract, getResolverContract, getOldResolverContract } from './contracts';\nimport { isValidContenthash, encodeContenthash, decodeContenthash } from './utils/contents';\n/* Utils */\n\nexport function getNamehash(name) {\n  return namehash(name);\n}\n\nasync function getNamehashWithLabelHash(labelHash, nodeHash) {\n  let node = utils.keccak256(nodeHash + labelHash.slice(2));\n  return node.toString();\n}\n\nfunction getLabelhash(label) {\n  return labelhash(label);\n}\n\nconst contracts = {\n  1: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  3: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  4: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  5: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  }\n};\nexport class ENS {\n  constructor(_ref) {\n    let {\n      networkId,\n      registryAddress,\n      provider\n    } = _ref;\n    this.contracts = contracts;\n    const hasRegistry = has(this.contracts[networkId], 'registry');\n\n    if (!hasRegistry && !registryAddress) {\n      throw new Error(`Unsupported network ${networkId}`);\n    } else if (this.contracts[networkId] && !registryAddress) {\n      registryAddress = contracts[networkId].registry;\n    }\n\n    this.registryAddress = registryAddress;\n    const ENSContract = getENSContract({\n      address: registryAddress,\n      provider\n    });\n    this.ENS = ENSContract;\n  }\n  /* Get the raw Ethers contract object */\n\n\n  getENSContractInstance() {\n    return this.ENS;\n  }\n  /* Main methods */\n\n\n  async getOwner(name) {\n    const namehash = getNamehash(name);\n    const owner = await this.ENS.owner(namehash);\n    return owner;\n  }\n\n  async getResolver(name) {\n    const namehash = getNamehash(name);\n    return this.ENS.resolver(namehash);\n  }\n\n  async getTTL(name) {\n    const namehash = getNamehash(name);\n    return this.ENS.ttl(namehash);\n  }\n\n  async getResolverWithLabelhash(labelhash, nodehash) {\n    const namehash = await getNamehashWithLabelHash(labelhash, nodehash);\n    return this.ENS.resolver(namehash);\n  }\n\n  async getOwnerWithLabelHash(labelhash, nodeHash) {\n    const namehash = await getNamehashWithLabelHash(labelhash, nodeHash);\n    return this.ENS.owner(namehash);\n  }\n\n  async getEthAddressWithResolver(name, resolverAddr) {\n    if (parseInt(resolverAddr, 16) === 0) {\n      return emptyAddress;\n    }\n\n    const namehash = getNamehash(name);\n\n    try {\n      const provider = await getProvider();\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      });\n      const addr = await Resolver['addr(bytes32)'](namehash);\n      return addr;\n    } catch (e) {\n      console.warn('Error getting addr on the resolver contract, are you sure the resolver address is a resolver contract?');\n      return emptyAddress;\n    }\n  }\n\n  async getAddress(name) {\n    const resolverAddr = await this.getResolver(name);\n    return this.getEthAddressWithResolver(name, resolverAddr);\n  }\n\n  async getAddr(name, key) {\n    const resolverAddr = await this.getResolver(name);\n    if (parseInt(resolverAddr, 16) === 0) return emptyAddress;\n    return this.getAddrWithResolver(name, key, resolverAddr);\n  }\n\n  async getAddrWithResolver(name, key, resolverAddr) {\n    const namehash = getNamehash(name);\n\n    try {\n      const provider = await getProvider();\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      });\n      const {\n        coinType,\n        encoder\n      } = formatsByName[key];\n      const addr = await Resolver['addr(bytes32,uint256)'](namehash, coinType);\n      if (addr === '0x') return emptyAddress;\n      return encoder(Buffer.from(addr.slice(2), 'hex'));\n    } catch (e) {\n      console.log(e);\n      console.warn('Error getting addr on the resolver contract, are you sure the resolver address is a resolver contract?');\n      return emptyAddress;\n    }\n  }\n\n  async getContent(name) {\n    const resolverAddr = await this.getResolver(name);\n    return this.getContentWithResolver(name, resolverAddr);\n  }\n\n  async getContentWithResolver(name, resolverAddr) {\n    if (parseInt(resolverAddr, 16) === 0) {\n      return emptyAddress;\n    }\n\n    try {\n      const namehash = getNamehash(name);\n      const provider = await getProvider();\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      });\n      const contentHashSignature = utils.solidityKeccak256(['string'], ['contenthash(bytes32)']).slice(0, 10);\n      const isContentHashSupported = await Resolver.supportsInterface(contentHashSignature);\n\n      if (isContentHashSupported) {\n        const encoded = await Resolver.contenthash(namehash);\n        const {\n          protocolType,\n          decoded,\n          error\n        } = decodeContenthash(encoded);\n\n        if (error) {\n          return {\n            value: error,\n            contentType: 'error'\n          };\n        }\n\n        return {\n          value: `${protocolType}://${decoded}`,\n          contentType: 'contenthash'\n        };\n      } else {\n        const value = await Resolver.content(namehash);\n        return {\n          value,\n          contentType: 'oldcontent'\n        };\n      }\n    } catch (e) {\n      const message = 'Error getting content on the resolver contract, are you sure the resolver address is a resolver contract?';\n      console.warn(message, e);\n      return {\n        value: message,\n        contentType: 'error'\n      };\n    }\n  }\n\n  async getText(name, key) {\n    const resolverAddr = await this.getResolver(name);\n    return this.getTextWithResolver(name, key, resolverAddr);\n  }\n\n  async getTextWithResolver(name, key, resolverAddr) {\n    if (parseInt(resolverAddr, 16) === 0) {\n      return '';\n    }\n\n    const namehash = getNamehash(name);\n\n    try {\n      const provider = await getProvider();\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      });\n      const addr = await Resolver.text(namehash, key);\n      return addr;\n    } catch (e) {\n      console.warn('Error getting text record on the resolver contract, are you sure the resolver address is a resolver contract?');\n      return '';\n    }\n  }\n\n  async getName(address) {\n    const reverseNode = `${address.slice(2)}.addr.reverse`;\n    const resolverAddr = await this.getResolver(reverseNode);\n    return this.getNameWithResolver(address, resolverAddr);\n  }\n\n  async getNameWithResolver(address, resolverAddr) {\n    const reverseNode = `${address.slice(2)}.addr.reverse`;\n    const reverseNamehash = getNamehash(reverseNode);\n\n    if (parseInt(resolverAddr, 16) === 0) {\n      return {\n        name: null\n      };\n    }\n\n    try {\n      const provider = await getProvider();\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      });\n      const name = await Resolver.name(reverseNamehash);\n      return {\n        name\n      };\n    } catch (e) {\n      console.log(`Error getting name for reverse record of ${address}`, e);\n    }\n  }\n\n  async isMigrated(name) {\n    const namehash = getNamehash(name);\n    return this.ENS.recordExists(namehash);\n  }\n\n  async getResolverDetails(node) {\n    try {\n      const addrPromise = this.getAddress(node.name);\n      const contentPromise = this.getContent(node.name);\n      const [addr, content] = await Promise.all([addrPromise, contentPromise]);\n      return { ...node,\n        addr,\n        content: content.value,\n        contentType: content.contentType\n      };\n    } catch (e) {\n      return { ...node,\n        addr: '0x0',\n        content: '0x0',\n        contentType: 'error'\n      };\n    }\n  }\n\n  async getSubdomains(name) {\n    const startBlock = await getEnsStartBlock();\n    const namehash = getNamehash(name);\n    const rawLogs = await this.getENSEvent('NewOwner', {\n      topics: [namehash],\n      fromBlock: startBlock\n    });\n    const flattenedLogs = rawLogs.map(log => log.values);\n    flattenedLogs.reverse();\n    const logs = uniq(flattenedLogs, 'label');\n    const labelhashes = logs.map(log => log.label);\n    const remoteLabels = await decryptHashes(...labelhashes);\n    const localLabels = checkLabels(...labelhashes);\n    const labels = mergeLabels(localLabels, remoteLabels);\n    const ownerPromises = labels.map(label => this.getOwner(`${label}.${name}`));\n    return Promise.all(ownerPromises).then(owners => owners.map((owner, index) => {\n      return {\n        label: labels[index],\n        labelhash: logs[index].label,\n        decrypted: labels[index] !== null,\n        node: name,\n        name: `${labels[index] || encodeLabelhash(logs[index].label)}.${name}`,\n        owner\n      };\n    }));\n  }\n\n  async getDomainDetails(name) {\n    const nameArray = name.split('.');\n    const labelhash = getLabelhash(nameArray[0]);\n    const [owner, resolver] = await Promise.all([this.getOwner(name), this.getResolver(name)]);\n    const node = {\n      name,\n      label: nameArray[0],\n      labelhash,\n      owner,\n      resolver\n    };\n    const hasResolver = parseInt(node.resolver, 16) !== 0;\n\n    if (hasResolver) {\n      return this.getResolverDetails(node);\n    }\n\n    return { ...node,\n      addr: null,\n      content: null\n    };\n  }\n  /* non-constant functions */\n\n\n  async setOwner(name, newOwner) {\n    const ENSWithoutSigner = this.ENS;\n    const signer = await getSigner();\n    const ENS = ENSWithoutSigner.connect(signer);\n    const namehash = getNamehash(name);\n    return ENS.setOwner(namehash, newOwner);\n  }\n\n  async setSubnodeOwner(name, newOwner) {\n    const ENSWithoutSigner = this.ENS;\n    const signer = await getSigner();\n    const ENS = ENSWithoutSigner.connect(signer);\n    const nameArray = name.split('.');\n    const label = nameArray[0];\n    const node = nameArray.slice(1).join('.');\n    const labelhash = getLabelhash(label);\n    const parentNamehash = getNamehash(node);\n    return ENS.setSubnodeOwner(parentNamehash, labelhash, newOwner);\n  }\n\n  async setSubnodeRecord(name, newOwner, resolver) {\n    const ENSWithoutSigner = this.ENS;\n    const signer = await getSigner();\n    const ENS = ENSWithoutSigner.connect(signer);\n    const nameArray = name.split('.');\n    const label = nameArray[0];\n    const node = nameArray.slice(1).join('.');\n    const labelhash = getLabelhash(label);\n    const parentNamehash = getNamehash(node);\n    const ttl = await this.getTTL(name);\n    return ENS.setSubnodeRecord(parentNamehash, labelhash, newOwner, resolver, ttl);\n  }\n\n  async setResolver(name, resolver) {\n    const namehash = getNamehash(name);\n    const ENSWithoutSigner = this.ENS;\n    const signer = await getSigner();\n    const ENS = ENSWithoutSigner.connect(signer);\n    return ENS.setResolver(namehash, resolver);\n  }\n\n  async setAddress(name, address) {\n    const resolverAddr = await this.getResolver(name);\n    return this.setAddressWithResolver(name, address, resolverAddr);\n  }\n\n  async setAddressWithResolver(name, address, resolverAddr) {\n    const namehash = getNamehash(name);\n    const provider = await getProvider();\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const Resolver = ResolverWithoutSigner.connect(signer);\n    return Resolver['setAddr(bytes32,address)'](namehash, address);\n  }\n\n  async setAddr(name, key, address) {\n    const resolverAddr = await this.getResolver(name);\n    return this.setAddrWithResolver(name, key, address, resolverAddr);\n  }\n\n  async setAddrWithResolver(name, key, address, resolverAddr) {\n    const namehash = getNamehash(name);\n    const provider = await getProvider();\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const Resolver = ResolverWithoutSigner.connect(signer);\n    const {\n      decoder,\n      coinType\n    } = formatsByName[key];\n    let addressAsBytes;\n\n    if (!address || address === '') {\n      addressAsBytes = Buffer.from('');\n    } else {\n      addressAsBytes = decoder(address);\n    }\n\n    return Resolver['setAddr(bytes32,uint256,bytes)'](namehash, coinType, addressAsBytes);\n  }\n\n  async setContent(name, content) {\n    const resolverAddr = await this.getResolver(name);\n    return this.setContentWithResolver(name, content, resolverAddr);\n  }\n\n  async setContentWithResolver(name, content, resolverAddr) {\n    const namehash = getNamehash(name);\n    const provider = await getProvider();\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const Resolver = ResolverWithoutSigner.connect(signer);\n    return Resolver.setContent(namehash, content);\n  }\n\n  async setContenthash(name, content) {\n    const resolverAddr = await this.getResolver(name);\n    return this.setContenthashWithResolver(name, content, resolverAddr);\n  }\n\n  async setContenthashWithResolver(name, content, resolverAddr) {\n    let encodedContenthash = content;\n\n    if (parseInt(content, 16) !== 0) {\n      encodedContenthash = encodeContenthash(content);\n    }\n\n    const namehash = getNamehash(name);\n    const provider = await getProvider();\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const Resolver = ResolverWithoutSigner.connect(signer);\n    return Resolver.setContenthash(namehash, encodedContenthash);\n  }\n\n  async setText(name, key, recordValue) {\n    const resolverAddr = await this.getResolver(name);\n    return this.setTextWithResolver(name, key, recordValue, resolverAddr);\n  }\n\n  async setTextWithResolver(name, key, recordValue, resolverAddr) {\n    const namehash = getNamehash(name);\n    const provider = await getProvider();\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const Resolver = ResolverWithoutSigner.connect(signer);\n    return Resolver.setText(namehash, key, recordValue);\n  }\n\n  async createSubdomain(name) {\n    const account = await getAccount();\n    const publicResolverAddress = await this.getAddress('resolver.eth');\n\n    try {\n      return this.setSubnodeRecord(name, account, publicResolverAddress);\n    } catch (e) {\n      console.log('error creating subdomain', e);\n    }\n  }\n\n  async deleteSubdomain(name) {\n    try {\n      return this.setSubnodeRecord(name, emptyAddress, emptyAddress);\n    } catch (e) {\n      console.log('error deleting subdomain', e);\n    }\n  }\n\n  async claimAndSetReverseRecordName(name) {\n    let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const reverseRegistrarAddr = await this.getOwner('addr.reverse');\n    const provider = await getProvider(0);\n    const reverseRegistrarWithoutSigner = getReverseRegistrarContract({\n      address: reverseRegistrarAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const reverseRegistrar = reverseRegistrarWithoutSigner.connect(signer);\n    const networkId = await getNetworkId();\n\n    if (parseInt(networkId) > 1000) {\n      const gasLimit = await reverseRegistrar.estimateGas.setName(name);\n      overrides = {\n        gasLimit: gasLimit.toNumber() * 2,\n        ...overrides\n      };\n    }\n\n    return reverseRegistrar.setName(name, overrides);\n  }\n\n  async setReverseRecordName(name) {\n    const account = await getAccount();\n    const provider = await getProvider();\n    const reverseNode = `${account.slice(2)}.addr.reverse`;\n    const resolverAddr = await this.getResolver(reverseNode);\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    const signer = await getSigner();\n    const Resolver = ResolverWithoutSigner.connect(signer);\n    let namehash = getNamehash(reverseNode);\n    return Resolver.setName(namehash, name);\n  } // Events\n\n\n  async getENSEvent(event, _ref2) {\n    let {\n      topics,\n      fromBlock\n    } = _ref2;\n    const provider = await getWeb3();\n    const {\n      ENS\n    } = this;\n    const ensInterface = new utils.Interface(ensContract);\n    let Event = ENS.filters[event]();\n    const filter = {\n      fromBlock,\n      toBlock: 'latest',\n      address: Event.address,\n      topics: [...Event.topics, ...topics]\n    };\n    const logs = await provider.getLogs(filter);\n    const parsed = logs.map(log => {\n      const parsedLog = ensInterface.parseLog(log);\n      return parsedLog;\n    });\n    return parsed;\n  }\n\n}","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@ensdomains/ui/src/ens.js"],"names":["has","Contract","utils","getWeb3","getNetworkId","getProvider","getAccount","getSigner","formatsByName","abi","ensContract","decryptHashes","uniq","getEnsStartBlock","checkLabels","mergeLabels","emptyAddress","isDecrypted","namehash","labelhash","encodeLabelhash","getTestRegistrarContract","getReverseRegistrarContract","getENSContract","getResolverContract","getOldResolverContract","isValidContenthash","encodeContenthash","decodeContenthash","getNamehash","name","getNamehashWithLabelHash","labelHash","nodeHash","node","keccak256","slice","toString","getLabelhash","label","contracts","registry","ENS","constructor","networkId","registryAddress","provider","hasRegistry","Error","ENSContract","address","getENSContractInstance","getOwner","owner","getResolver","resolver","getTTL","ttl","getResolverWithLabelhash","nodehash","getOwnerWithLabelHash","getEthAddressWithResolver","resolverAddr","parseInt","Resolver","addr","e","console","warn","getAddress","getAddr","key","getAddrWithResolver","coinType","encoder","Buffer","from","log","getContent","getContentWithResolver","contentHashSignature","solidityKeccak256","isContentHashSupported","supportsInterface","encoded","contenthash","protocolType","decoded","error","value","contentType","content","message","getText","getTextWithResolver","text","getName","reverseNode","getNameWithResolver","reverseNamehash","isMigrated","recordExists","getResolverDetails","addrPromise","contentPromise","Promise","all","getSubdomains","startBlock","rawLogs","getENSEvent","topics","fromBlock","flattenedLogs","map","values","reverse","logs","labelhashes","remoteLabels","localLabels","labels","ownerPromises","then","owners","index","decrypted","getDomainDetails","nameArray","split","hasResolver","setOwner","newOwner","ENSWithoutSigner","signer","connect","setSubnodeOwner","join","parentNamehash","setSubnodeRecord","setResolver","setAddress","setAddressWithResolver","ResolverWithoutSigner","setAddr","setAddrWithResolver","decoder","addressAsBytes","setContent","setContentWithResolver","setContenthash","setContenthashWithResolver","encodedContenthash","setText","recordValue","setTextWithResolver","createSubdomain","account","publicResolverAddress","deleteSubdomain","claimAndSetReverseRecordName","overrides","reverseRegistrarAddr","reverseRegistrarWithoutSigner","reverseRegistrar","gasLimit","estimateGas","setName","toNumber","setReverseRecordName","event","ensInterface","Interface","Event","filters","filter","toBlock","getLogs","parsed","parsedLog","parseLog"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,YAAhB;AACA,SAASC,QAAT,EAAmBC,KAAnB,QAAgC,QAAhC;AACA,SACEC,OADF,EAEEC,YAFF,EAGEC,WAHF,EAIEC,UAJF,EAKEC,SALF,QAMO,QANP;AAOA,SAASC,aAAT,QAA8B,6BAA9B;AACA,SAASC,GAAG,IAAIC,WAAhB,QAAmC,yCAAnC;AAEA,SAASC,aAAT,QAA8B,YAA9B;AAEA,SACEC,IADF,EAEEC,gBAFF,EAGEC,WAHF,EAIEC,WAJF,EAKEC,YALF,EAMEC,WANF,EAOEC,QAPF,EAQEC,SARF,QASO,SATP;AAUA,SAASC,eAAT,QAAgC,mBAAhC;AAEA,SACEC,wBADF,EAEEC,2BAFF,EAGEC,cAHF,EAIEC,mBAJF,EAKEC,sBALF,QAMO,aANP;AAQA,SACEC,kBADF,EAEEC,iBAFF,EAGEC,iBAHF,QAIO,kBAJP;AAMA;;AAEA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2B;AAChC,SAAOZ,QAAQ,CAACY,IAAD,CAAf;AACD;;AAED,eAAeC,wBAAf,CAAwCC,SAAxC,EAAmDC,QAAnD,EAA6D;AAC3D,MAAIC,IAAI,GAAGhC,KAAK,CAACiC,SAAN,CAAgBF,QAAQ,GAAGD,SAAS,CAACI,KAAV,CAAgB,CAAhB,CAA3B,CAAX;AACA,SAAOF,IAAI,CAACG,QAAL,EAAP;AACD;;AAED,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAC3B,SAAOpB,SAAS,CAACoB,KAAD,CAAhB;AACD;;AAED,MAAMC,SAAS,GAAG;AAChB,KAAG;AACDC,IAAAA,QAAQ,EAAE;AADT,GADa;AAIhB,KAAG;AACDA,IAAAA,QAAQ,EAAE;AADT,GAJa;AAOhB,KAAG;AACDA,IAAAA,QAAQ,EAAE;AADT,GAPa;AAUhB,KAAG;AACDA,IAAAA,QAAQ,EAAE;AADT;AAVa,CAAlB;AAeA,OAAO,MAAMC,GAAN,CAAU;AACfC,EAAAA,WAAW,OAA2C;AAAA,QAA1C;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,eAAb;AAA8BC,MAAAA;AAA9B,KAA0C;AACpD,SAAKN,SAAL,GAAiBA,SAAjB;AACA,UAAMO,WAAW,GAAG/C,GAAG,CAAC,KAAKwC,SAAL,CAAeI,SAAf,CAAD,EAA4B,UAA5B,CAAvB;;AAEA,QAAI,CAACG,WAAD,IAAgB,CAACF,eAArB,EAAsC;AACpC,YAAM,IAAIG,KAAJ,CAAW,uBAAsBJ,SAAU,EAA3C,CAAN;AACD,KAFD,MAEO,IAAI,KAAKJ,SAAL,CAAeI,SAAf,KAA6B,CAACC,eAAlC,EAAmD;AACxDA,MAAAA,eAAe,GAAGL,SAAS,CAACI,SAAD,CAAT,CAAqBH,QAAvC;AACD;;AAED,SAAKI,eAAL,GAAuBA,eAAvB;AAEA,UAAMI,WAAW,GAAG1B,cAAc,CAAC;AAAE2B,MAAAA,OAAO,EAAEL,eAAX;AAA4BC,MAAAA;AAA5B,KAAD,CAAlC;AACA,SAAKJ,GAAL,GAAWO,WAAX;AACD;AAED;;;AACAE,EAAAA,sBAAsB,GAAG;AACvB,WAAO,KAAKT,GAAZ;AACD;AAED;;;AAEc,QAARU,QAAQ,CAACtB,IAAD,EAAO;AACnB,UAAMZ,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMuB,KAAK,GAAG,MAAM,KAAKX,GAAL,CAASW,KAAT,CAAenC,QAAf,CAApB;AACA,WAAOmC,KAAP;AACD;;AAEgB,QAAXC,WAAW,CAACxB,IAAD,EAAO;AACtB,UAAMZ,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,WAAO,KAAKY,GAAL,CAASa,QAAT,CAAkBrC,QAAlB,CAAP;AACD;;AAEW,QAANsC,MAAM,CAAC1B,IAAD,EAAO;AACjB,UAAMZ,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,WAAO,KAAKY,GAAL,CAASe,GAAT,CAAavC,QAAb,CAAP;AACD;;AAE6B,QAAxBwC,wBAAwB,CAACvC,SAAD,EAAYwC,QAAZ,EAAsB;AAClD,UAAMzC,QAAQ,GAAG,MAAMa,wBAAwB,CAACZ,SAAD,EAAYwC,QAAZ,CAA/C;AACA,WAAO,KAAKjB,GAAL,CAASa,QAAT,CAAkBrC,QAAlB,CAAP;AACD;;AAE0B,QAArB0C,qBAAqB,CAACzC,SAAD,EAAYc,QAAZ,EAAsB;AAC/C,UAAMf,QAAQ,GAAG,MAAMa,wBAAwB,CAACZ,SAAD,EAAYc,QAAZ,CAA/C;AACA,WAAO,KAAKS,GAAL,CAASW,KAAT,CAAenC,QAAf,CAAP;AACD;;AAE8B,QAAzB2C,yBAAyB,CAAC/B,IAAD,EAAOgC,YAAP,EAAqB;AAClD,QAAIC,QAAQ,CAACD,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC;AACpC,aAAO9C,YAAP;AACD;;AACD,UAAME,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;;AACA,QAAI;AACF,YAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,YAAM2D,QAAQ,GAAGxC,mBAAmB,CAAC;AACnC0B,QAAAA,OAAO,EAAEY,YAD0B;AAEnChB,QAAAA;AAFmC,OAAD,CAApC;AAIA,YAAMmB,IAAI,GAAG,MAAMD,QAAQ,CAAC,eAAD,CAAR,CAA0B9C,QAA1B,CAAnB;AACA,aAAO+C,IAAP;AACD,KARD,CAQE,OAAOC,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACC,IAAR,CACE,wGADF;AAGA,aAAOpD,YAAP;AACD;AACF;;AAEe,QAAVqD,UAAU,CAACvC,IAAD,EAAO;AACrB,UAAMgC,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAK+B,yBAAL,CAA+B/B,IAA/B,EAAqCgC,YAArC,CAAP;AACD;;AAEY,QAAPQ,OAAO,CAACxC,IAAD,EAAOyC,GAAP,EAAY;AACvB,UAAMT,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,QAAIiC,QAAQ,CAACD,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC,OAAO9C,YAAP;AACtC,WAAO,KAAKwD,mBAAL,CAAyB1C,IAAzB,EAA+ByC,GAA/B,EAAoCT,YAApC,CAAP;AACD;;AAEwB,QAAnBU,mBAAmB,CAAC1C,IAAD,EAAOyC,GAAP,EAAYT,YAAZ,EAA0B;AACjD,UAAM5C,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;;AACA,QAAI;AACF,YAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,YAAM2D,QAAQ,GAAGxC,mBAAmB,CAAC;AACnC0B,QAAAA,OAAO,EAAEY,YAD0B;AAEnChB,QAAAA;AAFmC,OAAD,CAApC;AAIA,YAAM;AAAE2B,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,UAAwBlE,aAAa,CAAC+D,GAAD,CAA3C;AACA,YAAMN,IAAI,GAAG,MAAMD,QAAQ,CAAC,uBAAD,CAAR,CAAkC9C,QAAlC,EAA4CuD,QAA5C,CAAnB;AACA,UAAIR,IAAI,KAAK,IAAb,EAAmB,OAAOjD,YAAP;AAEnB,aAAO0D,OAAO,CAACC,MAAM,CAACC,IAAP,CAAYX,IAAI,CAAC7B,KAAL,CAAW,CAAX,CAAZ,EAA2B,KAA3B,CAAD,CAAd;AACD,KAXD,CAWE,OAAO8B,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACU,GAAR,CAAYX,CAAZ;AACAC,MAAAA,OAAO,CAACC,IAAR,CACE,wGADF;AAGA,aAAOpD,YAAP;AACD;AACF;;AAEe,QAAV8D,UAAU,CAAChD,IAAD,EAAO;AACrB,UAAMgC,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAKiD,sBAAL,CAA4BjD,IAA5B,EAAkCgC,YAAlC,CAAP;AACD;;AAE2B,QAAtBiB,sBAAsB,CAACjD,IAAD,EAAOgC,YAAP,EAAqB;AAC/C,QAAIC,QAAQ,CAACD,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC;AACpC,aAAO9C,YAAP;AACD;;AACD,QAAI;AACF,YAAME,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,YAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,YAAM2D,QAAQ,GAAGxC,mBAAmB,CAAC;AACnC0B,QAAAA,OAAO,EAAEY,YAD0B;AAEnChB,QAAAA;AAFmC,OAAD,CAApC;AAIA,YAAMkC,oBAAoB,GAAG9E,KAAK,CAC/B+E,iBAD0B,CACR,CAAC,QAAD,CADQ,EACI,CAAC,sBAAD,CADJ,EAE1B7C,KAF0B,CAEpB,CAFoB,EAEjB,EAFiB,CAA7B;AAIA,YAAM8C,sBAAsB,GAAG,MAAMlB,QAAQ,CAACmB,iBAAT,CACnCH,oBADmC,CAArC;;AAIA,UAAIE,sBAAJ,EAA4B;AAC1B,cAAME,OAAO,GAAG,MAAMpB,QAAQ,CAACqB,WAAT,CAAqBnE,QAArB,CAAtB;AACA,cAAM;AAAEoE,UAAAA,YAAF;AAAgBC,UAAAA,OAAhB;AAAyBC,UAAAA;AAAzB,YAAmC5D,iBAAiB,CAACwD,OAAD,CAA1D;;AACA,YAAII,KAAJ,EAAW;AACT,iBAAO;AACLC,YAAAA,KAAK,EAAED,KADF;AAELE,YAAAA,WAAW,EAAE;AAFR,WAAP;AAID;;AACD,eAAO;AACLD,UAAAA,KAAK,EAAG,GAAEH,YAAa,MAAKC,OAAQ,EAD/B;AAELG,UAAAA,WAAW,EAAE;AAFR,SAAP;AAID,OAbD,MAaO;AACL,cAAMD,KAAK,GAAG,MAAMzB,QAAQ,CAAC2B,OAAT,CAAiBzE,QAAjB,CAApB;AACA,eAAO;AACLuE,UAAAA,KADK;AAELC,UAAAA,WAAW,EAAE;AAFR,SAAP;AAID;AACF,KAnCD,CAmCE,OAAOxB,CAAP,EAAU;AACV,YAAM0B,OAAO,GACX,2GADF;AAEAzB,MAAAA,OAAO,CAACC,IAAR,CAAawB,OAAb,EAAsB1B,CAAtB;AACA,aAAO;AAAEuB,QAAAA,KAAK,EAAEG,OAAT;AAAkBF,QAAAA,WAAW,EAAE;AAA/B,OAAP;AACD;AACF;;AAEY,QAAPG,OAAO,CAAC/D,IAAD,EAAOyC,GAAP,EAAY;AACvB,UAAMT,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAKgE,mBAAL,CAAyBhE,IAAzB,EAA+ByC,GAA/B,EAAoCT,YAApC,CAAP;AACD;;AAEwB,QAAnBgC,mBAAmB,CAAChE,IAAD,EAAOyC,GAAP,EAAYT,YAAZ,EAA0B;AACjD,QAAIC,QAAQ,CAACD,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC;AACpC,aAAO,EAAP;AACD;;AACD,UAAM5C,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;;AACA,QAAI;AACF,YAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,YAAM2D,QAAQ,GAAGxC,mBAAmB,CAAC;AACnC0B,QAAAA,OAAO,EAAEY,YAD0B;AAEnChB,QAAAA;AAFmC,OAAD,CAApC;AAIA,YAAMmB,IAAI,GAAG,MAAMD,QAAQ,CAAC+B,IAAT,CAAc7E,QAAd,EAAwBqD,GAAxB,CAAnB;AACA,aAAON,IAAP;AACD,KARD,CAQE,OAAOC,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACC,IAAR,CACE,+GADF;AAGA,aAAO,EAAP;AACD;AACF;;AAEY,QAAP4B,OAAO,CAAC9C,OAAD,EAAU;AACrB,UAAM+C,WAAW,GAAI,GAAE/C,OAAO,CAACd,KAAR,CAAc,CAAd,CAAiB,eAAxC;AACA,UAAM0B,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiB2C,WAAjB,CAA3B;AACA,WAAO,KAAKC,mBAAL,CAAyBhD,OAAzB,EAAkCY,YAAlC,CAAP;AACD;;AAEwB,QAAnBoC,mBAAmB,CAAChD,OAAD,EAAUY,YAAV,EAAwB;AAC/C,UAAMmC,WAAW,GAAI,GAAE/C,OAAO,CAACd,KAAR,CAAc,CAAd,CAAiB,eAAxC;AACA,UAAM+D,eAAe,GAAGtE,WAAW,CAACoE,WAAD,CAAnC;;AACA,QAAIlC,QAAQ,CAACD,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC;AACpC,aAAO;AACLhC,QAAAA,IAAI,EAAE;AADD,OAAP;AAGD;;AAED,QAAI;AACF,YAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,YAAM2D,QAAQ,GAAGxC,mBAAmB,CAAC;AACnC0B,QAAAA,OAAO,EAAEY,YAD0B;AAEnChB,QAAAA;AAFmC,OAAD,CAApC;AAIA,YAAMhB,IAAI,GAAG,MAAMkC,QAAQ,CAAClC,IAAT,CAAcqE,eAAd,CAAnB;AACA,aAAO;AACLrE,QAAAA;AADK,OAAP;AAGD,KAVD,CAUE,OAAOoC,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACU,GAAR,CAAa,4CAA2C3B,OAAQ,EAAhE,EAAmEgB,CAAnE;AACD;AACF;;AAEe,QAAVkC,UAAU,CAACtE,IAAD,EAAO;AACrB,UAAMZ,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,WAAO,KAAKY,GAAL,CAAS2D,YAAT,CAAsBnF,QAAtB,CAAP;AACD;;AAEuB,QAAlBoF,kBAAkB,CAACpE,IAAD,EAAO;AAC7B,QAAI;AACF,YAAMqE,WAAW,GAAG,KAAKlC,UAAL,CAAgBnC,IAAI,CAACJ,IAArB,CAApB;AACA,YAAM0E,cAAc,GAAG,KAAK1B,UAAL,CAAgB5C,IAAI,CAACJ,IAArB,CAAvB;AACA,YAAM,CAACmC,IAAD,EAAO0B,OAAP,IAAkB,MAAMc,OAAO,CAACC,GAAR,CAAY,CAACH,WAAD,EAAcC,cAAd,CAAZ,CAA9B;AACA,aAAO,EACL,GAAGtE,IADE;AAEL+B,QAAAA,IAFK;AAGL0B,QAAAA,OAAO,EAAEA,OAAO,CAACF,KAHZ;AAILC,QAAAA,WAAW,EAAEC,OAAO,CAACD;AAJhB,OAAP;AAMD,KAVD,CAUE,OAAOxB,CAAP,EAAU;AACV,aAAO,EACL,GAAGhC,IADE;AAEL+B,QAAAA,IAAI,EAAE,KAFD;AAGL0B,QAAAA,OAAO,EAAE,KAHJ;AAILD,QAAAA,WAAW,EAAE;AAJR,OAAP;AAMD;AACF;;AAEkB,QAAbiB,aAAa,CAAC7E,IAAD,EAAO;AACxB,UAAM8E,UAAU,GAAG,MAAM/F,gBAAgB,EAAzC;AACA,UAAMK,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAM+E,OAAO,GAAG,MAAM,KAAKC,WAAL,CAAiB,UAAjB,EAA6B;AACjDC,MAAAA,MAAM,EAAE,CAAC7F,QAAD,CADyC;AAEjD8F,MAAAA,SAAS,EAAEJ;AAFsC,KAA7B,CAAtB;AAIA,UAAMK,aAAa,GAAGJ,OAAO,CAACK,GAAR,CAAYrC,GAAG,IAAIA,GAAG,CAACsC,MAAvB,CAAtB;AACAF,IAAAA,aAAa,CAACG,OAAd;AACA,UAAMC,IAAI,GAAGzG,IAAI,CAACqG,aAAD,EAAgB,OAAhB,CAAjB;AACA,UAAMK,WAAW,GAAGD,IAAI,CAACH,GAAL,CAASrC,GAAG,IAAIA,GAAG,CAACtC,KAApB,CAApB;AACA,UAAMgF,YAAY,GAAG,MAAM5G,aAAa,CAAC,GAAG2G,WAAJ,CAAxC;AACA,UAAME,WAAW,GAAG1G,WAAW,CAAC,GAAGwG,WAAJ,CAA/B;AACA,UAAMG,MAAM,GAAG1G,WAAW,CAACyG,WAAD,EAAcD,YAAd,CAA1B;AACA,UAAMG,aAAa,GAAGD,MAAM,CAACP,GAAP,CAAW3E,KAAK,IAAI,KAAKa,QAAL,CAAe,GAAEb,KAAM,IAAGT,IAAK,EAA/B,CAApB,CAAtB;AAEA,WAAO2E,OAAO,CAACC,GAAR,CAAYgB,aAAZ,EAA2BC,IAA3B,CAAgCC,MAAM,IAC3CA,MAAM,CAACV,GAAP,CAAW,CAAC7D,KAAD,EAAQwE,KAAR,KAAkB;AAC3B,aAAO;AACLtF,QAAAA,KAAK,EAAEkF,MAAM,CAACI,KAAD,CADR;AAEL1G,QAAAA,SAAS,EAAEkG,IAAI,CAACQ,KAAD,CAAJ,CAAYtF,KAFlB;AAGLuF,QAAAA,SAAS,EAAEL,MAAM,CAACI,KAAD,CAAN,KAAkB,IAHxB;AAIL3F,QAAAA,IAAI,EAAEJ,IAJD;AAKLA,QAAAA,IAAI,EAAG,GAAE2F,MAAM,CAACI,KAAD,CAAN,IACPzG,eAAe,CAACiG,IAAI,CAACQ,KAAD,CAAJ,CAAYtF,KAAb,CAAoB,IAAGT,IAAK,EANxC;AAOLuB,QAAAA;AAPK,OAAP;AASD,KAVD,CADK,CAAP;AAaD;;AAEqB,QAAhB0E,gBAAgB,CAACjG,IAAD,EAAO;AAC3B,UAAMkG,SAAS,GAAGlG,IAAI,CAACmG,KAAL,CAAW,GAAX,CAAlB;AACA,UAAM9G,SAAS,GAAGmB,YAAY,CAAC0F,SAAS,CAAC,CAAD,CAAV,CAA9B;AACA,UAAM,CAAC3E,KAAD,EAAQE,QAAR,IAAoB,MAAMkD,OAAO,CAACC,GAAR,CAAY,CAC1C,KAAKtD,QAAL,CAActB,IAAd,CAD0C,EAE1C,KAAKwB,WAAL,CAAiBxB,IAAjB,CAF0C,CAAZ,CAAhC;AAIA,UAAMI,IAAI,GAAG;AACXJ,MAAAA,IADW;AAEXS,MAAAA,KAAK,EAAEyF,SAAS,CAAC,CAAD,CAFL;AAGX7G,MAAAA,SAHW;AAIXkC,MAAAA,KAJW;AAKXE,MAAAA;AALW,KAAb;AAQA,UAAM2E,WAAW,GAAGnE,QAAQ,CAAC7B,IAAI,CAACqB,QAAN,EAAgB,EAAhB,CAAR,KAAgC,CAApD;;AAEA,QAAI2E,WAAJ,EAAiB;AACf,aAAO,KAAK5B,kBAAL,CAAwBpE,IAAxB,CAAP;AACD;;AAED,WAAO,EACL,GAAGA,IADE;AAEL+B,MAAAA,IAAI,EAAE,IAFD;AAGL0B,MAAAA,OAAO,EAAE;AAHJ,KAAP;AAKD;AAED;;;AAEc,QAARwC,QAAQ,CAACrG,IAAD,EAAOsG,QAAP,EAAiB;AAC7B,UAAMC,gBAAgB,GAAG,KAAK3F,GAA9B;AACA,UAAM4F,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMmC,GAAG,GAAG2F,gBAAgB,CAACE,OAAjB,CAAyBD,MAAzB,CAAZ;AACA,UAAMpH,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,WAAOY,GAAG,CAACyF,QAAJ,CAAajH,QAAb,EAAuBkH,QAAvB,CAAP;AACD;;AAEoB,QAAfI,eAAe,CAAC1G,IAAD,EAAOsG,QAAP,EAAiB;AACpC,UAAMC,gBAAgB,GAAG,KAAK3F,GAA9B;AACA,UAAM4F,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMmC,GAAG,GAAG2F,gBAAgB,CAACE,OAAjB,CAAyBD,MAAzB,CAAZ;AACA,UAAMN,SAAS,GAAGlG,IAAI,CAACmG,KAAL,CAAW,GAAX,CAAlB;AACA,UAAM1F,KAAK,GAAGyF,SAAS,CAAC,CAAD,CAAvB;AACA,UAAM9F,IAAI,GAAG8F,SAAS,CAAC5F,KAAV,CAAgB,CAAhB,EAAmBqG,IAAnB,CAAwB,GAAxB,CAAb;AACA,UAAMtH,SAAS,GAAGmB,YAAY,CAACC,KAAD,CAA9B;AACA,UAAMmG,cAAc,GAAG7G,WAAW,CAACK,IAAD,CAAlC;AACA,WAAOQ,GAAG,CAAC8F,eAAJ,CAAoBE,cAApB,EAAoCvH,SAApC,EAA+CiH,QAA/C,CAAP;AACD;;AAEqB,QAAhBO,gBAAgB,CAAC7G,IAAD,EAAOsG,QAAP,EAAiB7E,QAAjB,EAA2B;AAC/C,UAAM8E,gBAAgB,GAAG,KAAK3F,GAA9B;AACA,UAAM4F,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMmC,GAAG,GAAG2F,gBAAgB,CAACE,OAAjB,CAAyBD,MAAzB,CAAZ;AACA,UAAMN,SAAS,GAAGlG,IAAI,CAACmG,KAAL,CAAW,GAAX,CAAlB;AACA,UAAM1F,KAAK,GAAGyF,SAAS,CAAC,CAAD,CAAvB;AACA,UAAM9F,IAAI,GAAG8F,SAAS,CAAC5F,KAAV,CAAgB,CAAhB,EAAmBqG,IAAnB,CAAwB,GAAxB,CAAb;AACA,UAAMtH,SAAS,GAAGmB,YAAY,CAACC,KAAD,CAA9B;AACA,UAAMmG,cAAc,GAAG7G,WAAW,CAACK,IAAD,CAAlC;AACA,UAAMuB,GAAG,GAAG,MAAM,KAAKD,MAAL,CAAY1B,IAAZ,CAAlB;AACA,WAAOY,GAAG,CAACiG,gBAAJ,CACLD,cADK,EAELvH,SAFK,EAGLiH,QAHK,EAIL7E,QAJK,EAKLE,GALK,CAAP;AAOD;;AAEgB,QAAXmF,WAAW,CAAC9G,IAAD,EAAOyB,QAAP,EAAiB;AAChC,UAAMrC,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMuG,gBAAgB,GAAG,KAAK3F,GAA9B;AACA,UAAM4F,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMmC,GAAG,GAAG2F,gBAAgB,CAACE,OAAjB,CAAyBD,MAAzB,CAAZ;AACA,WAAO5F,GAAG,CAACkG,WAAJ,CAAgB1H,QAAhB,EAA0BqC,QAA1B,CAAP;AACD;;AAEe,QAAVsF,UAAU,CAAC/G,IAAD,EAAOoB,OAAP,EAAgB;AAC9B,UAAMY,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAKgH,sBAAL,CAA4BhH,IAA5B,EAAkCoB,OAAlC,EAA2CY,YAA3C,CAAP;AACD;;AAE2B,QAAtBgF,sBAAsB,CAAChH,IAAD,EAAOoB,OAAP,EAAgBY,YAAhB,EAA8B;AACxD,UAAM5C,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,UAAM0I,qBAAqB,GAAGvH,mBAAmB,CAAC;AAChD0B,MAAAA,OAAO,EAAEY,YADuC;AAEhDhB,MAAAA;AAFgD,KAAD,CAAjD;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMyD,QAAQ,GAAG+E,qBAAqB,CAACR,OAAtB,CAA8BD,MAA9B,CAAjB;AACA,WAAOtE,QAAQ,CAAC,0BAAD,CAAR,CAAqC9C,QAArC,EAA+CgC,OAA/C,CAAP;AACD;;AAEY,QAAP8F,OAAO,CAAClH,IAAD,EAAOyC,GAAP,EAAYrB,OAAZ,EAAqB;AAChC,UAAMY,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAKmH,mBAAL,CAAyBnH,IAAzB,EAA+ByC,GAA/B,EAAoCrB,OAApC,EAA6CY,YAA7C,CAAP;AACD;;AAEwB,QAAnBmF,mBAAmB,CAACnH,IAAD,EAAOyC,GAAP,EAAYrB,OAAZ,EAAqBY,YAArB,EAAmC;AAC1D,UAAM5C,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,UAAM0I,qBAAqB,GAAGvH,mBAAmB,CAAC;AAChD0B,MAAAA,OAAO,EAAEY,YADuC;AAEhDhB,MAAAA;AAFgD,KAAD,CAAjD;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMyD,QAAQ,GAAG+E,qBAAqB,CAACR,OAAtB,CAA8BD,MAA9B,CAAjB;AACA,UAAM;AAAEY,MAAAA,OAAF;AAAWzE,MAAAA;AAAX,QAAwBjE,aAAa,CAAC+D,GAAD,CAA3C;AACA,QAAI4E,cAAJ;;AACA,QAAI,CAACjG,OAAD,IAAYA,OAAO,KAAK,EAA5B,EAAgC;AAC9BiG,MAAAA,cAAc,GAAGxE,MAAM,CAACC,IAAP,CAAY,EAAZ,CAAjB;AACD,KAFD,MAEO;AACLuE,MAAAA,cAAc,GAAGD,OAAO,CAAChG,OAAD,CAAxB;AACD;;AACD,WAAOc,QAAQ,CAAC,gCAAD,CAAR,CACL9C,QADK,EAELuD,QAFK,EAGL0E,cAHK,CAAP;AAKD;;AAEe,QAAVC,UAAU,CAACtH,IAAD,EAAO6D,OAAP,EAAgB;AAC9B,UAAM7B,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAKuH,sBAAL,CAA4BvH,IAA5B,EAAkC6D,OAAlC,EAA2C7B,YAA3C,CAAP;AACD;;AAE2B,QAAtBuF,sBAAsB,CAACvH,IAAD,EAAO6D,OAAP,EAAgB7B,YAAhB,EAA8B;AACxD,UAAM5C,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,UAAM0I,qBAAqB,GAAGvH,mBAAmB,CAAC;AAChD0B,MAAAA,OAAO,EAAEY,YADuC;AAEhDhB,MAAAA;AAFgD,KAAD,CAAjD;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMyD,QAAQ,GAAG+E,qBAAqB,CAACR,OAAtB,CAA8BD,MAA9B,CAAjB;AACA,WAAOtE,QAAQ,CAACoF,UAAT,CAAoBlI,QAApB,EAA8ByE,OAA9B,CAAP;AACD;;AAEmB,QAAd2D,cAAc,CAACxH,IAAD,EAAO6D,OAAP,EAAgB;AAClC,UAAM7B,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAKyH,0BAAL,CAAgCzH,IAAhC,EAAsC6D,OAAtC,EAA+C7B,YAA/C,CAAP;AACD;;AAE+B,QAA1ByF,0BAA0B,CAACzH,IAAD,EAAO6D,OAAP,EAAgB7B,YAAhB,EAA8B;AAC5D,QAAI0F,kBAAkB,GAAG7D,OAAzB;;AACA,QAAI5B,QAAQ,CAAC4B,OAAD,EAAU,EAAV,CAAR,KAA0B,CAA9B,EAAiC;AAC/B6D,MAAAA,kBAAkB,GAAG7H,iBAAiB,CAACgE,OAAD,CAAtC;AACD;;AACD,UAAMzE,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,UAAM0I,qBAAqB,GAAGvH,mBAAmB,CAAC;AAChD0B,MAAAA,OAAO,EAAEY,YADuC;AAEhDhB,MAAAA;AAFgD,KAAD,CAAjD;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMyD,QAAQ,GAAG+E,qBAAqB,CAACR,OAAtB,CAA8BD,MAA9B,CAAjB;AACA,WAAOtE,QAAQ,CAACsF,cAAT,CAAwBpI,QAAxB,EAAkCsI,kBAAlC,CAAP;AACD;;AAEY,QAAPC,OAAO,CAAC3H,IAAD,EAAOyC,GAAP,EAAYmF,WAAZ,EAAyB;AACpC,UAAM5F,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiBxB,IAAjB,CAA3B;AACA,WAAO,KAAK6H,mBAAL,CAAyB7H,IAAzB,EAA+ByC,GAA/B,EAAoCmF,WAApC,EAAiD5F,YAAjD,CAAP;AACD;;AAEwB,QAAnB6F,mBAAmB,CAAC7H,IAAD,EAAOyC,GAAP,EAAYmF,WAAZ,EAAyB5F,YAAzB,EAAuC;AAC9D,UAAM5C,QAAQ,GAAGW,WAAW,CAACC,IAAD,CAA5B;AACA,UAAMgB,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,UAAM0I,qBAAqB,GAAGvH,mBAAmB,CAAC;AAChD0B,MAAAA,OAAO,EAAEY,YADuC;AAEhDhB,MAAAA;AAFgD,KAAD,CAAjD;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMyD,QAAQ,GAAG+E,qBAAqB,CAACR,OAAtB,CAA8BD,MAA9B,CAAjB;AACA,WAAOtE,QAAQ,CAACyF,OAAT,CAAiBvI,QAAjB,EAA2BqD,GAA3B,EAAgCmF,WAAhC,CAAP;AACD;;AAEoB,QAAfE,eAAe,CAAC9H,IAAD,EAAO;AAC1B,UAAM+H,OAAO,GAAG,MAAMvJ,UAAU,EAAhC;AACA,UAAMwJ,qBAAqB,GAAG,MAAM,KAAKzF,UAAL,CAAgB,cAAhB,CAApC;;AACA,QAAI;AACF,aAAO,KAAKsE,gBAAL,CAAsB7G,IAAtB,EAA4B+H,OAA5B,EAAqCC,qBAArC,CAAP;AACD,KAFD,CAEE,OAAO5F,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACU,GAAR,CAAY,0BAAZ,EAAwCX,CAAxC;AACD;AACF;;AAEoB,QAAf6F,eAAe,CAACjI,IAAD,EAAO;AAC1B,QAAI;AACF,aAAO,KAAK6G,gBAAL,CAAsB7G,IAAtB,EAA4Bd,YAA5B,EAA0CA,YAA1C,CAAP;AACD,KAFD,CAEE,OAAOkD,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACU,GAAR,CAAY,0BAAZ,EAAwCX,CAAxC;AACD;AACF;;AAEiC,QAA5B8F,4BAA4B,CAAClI,IAAD,EAAuB;AAAA,QAAhBmI,SAAgB,uEAAJ,EAAI;AACvD,UAAMC,oBAAoB,GAAG,MAAM,KAAK9G,QAAL,CAAc,cAAd,CAAnC;AACA,UAAMN,QAAQ,GAAG,MAAMzC,WAAW,CAAC,CAAD,CAAlC;AACA,UAAM8J,6BAA6B,GAAG7I,2BAA2B,CAAC;AAChE4B,MAAAA,OAAO,EAAEgH,oBADuD;AAEhEpH,MAAAA;AAFgE,KAAD,CAAjE;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAM6J,gBAAgB,GAAGD,6BAA6B,CAAC5B,OAA9B,CAAsCD,MAAtC,CAAzB;AACA,UAAM1F,SAAS,GAAG,MAAMxC,YAAY,EAApC;;AAEA,QAAI2D,QAAQ,CAACnB,SAAD,CAAR,GAAsB,IAA1B,EAAgC;AAC9B,YAAMyH,QAAQ,GAAG,MAAMD,gBAAgB,CAACE,WAAjB,CAA6BC,OAA7B,CAAqCzI,IAArC,CAAvB;AACAmI,MAAAA,SAAS,GAAG;AACVI,QAAAA,QAAQ,EAAEA,QAAQ,CAACG,QAAT,KAAsB,CADtB;AAEV,WAAGP;AAFO,OAAZ;AAID;;AAED,WAAOG,gBAAgB,CAACG,OAAjB,CAAyBzI,IAAzB,EAA+BmI,SAA/B,CAAP;AACD;;AAEyB,QAApBQ,oBAAoB,CAAC3I,IAAD,EAAO;AAC/B,UAAM+H,OAAO,GAAG,MAAMvJ,UAAU,EAAhC;AACA,UAAMwC,QAAQ,GAAG,MAAMzC,WAAW,EAAlC;AACA,UAAM4F,WAAW,GAAI,GAAE4D,OAAO,CAACzH,KAAR,CAAc,CAAd,CAAiB,eAAxC;AACA,UAAM0B,YAAY,GAAG,MAAM,KAAKR,WAAL,CAAiB2C,WAAjB,CAA3B;AACA,UAAM8C,qBAAqB,GAAGvH,mBAAmB,CAAC;AAChD0B,MAAAA,OAAO,EAAEY,YADuC;AAEhDhB,MAAAA;AAFgD,KAAD,CAAjD;AAIA,UAAMwF,MAAM,GAAG,MAAM/H,SAAS,EAA9B;AACA,UAAMyD,QAAQ,GAAG+E,qBAAqB,CAACR,OAAtB,CAA8BD,MAA9B,CAAjB;AACA,QAAIpH,QAAQ,GAAGW,WAAW,CAACoE,WAAD,CAA1B;AACA,WAAOjC,QAAQ,CAACuG,OAAT,CAAiBrJ,QAAjB,EAA2BY,IAA3B,CAAP;AACD,GAnfc,CAqff;;;AAEiB,QAAXgF,WAAW,CAAC4D,KAAD,SAA+B;AAAA,QAAvB;AAAE3D,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAAuB;AAC9C,UAAMlE,QAAQ,GAAG,MAAM3C,OAAO,EAA9B;AACA,UAAM;AAAEuC,MAAAA;AAAF,QAAU,IAAhB;AACA,UAAMiI,YAAY,GAAG,IAAIzK,KAAK,CAAC0K,SAAV,CAAoBlK,WAApB,CAArB;AACA,QAAImK,KAAK,GAAGnI,GAAG,CAACoI,OAAJ,CAAYJ,KAAZ,GAAZ;AAEA,UAAMK,MAAM,GAAG;AACb/D,MAAAA,SADa;AAEbgE,MAAAA,OAAO,EAAE,QAFI;AAGb9H,MAAAA,OAAO,EAAE2H,KAAK,CAAC3H,OAHF;AAIb6D,MAAAA,MAAM,EAAE,CAAC,GAAG8D,KAAK,CAAC9D,MAAV,EAAkB,GAAGA,MAArB;AAJK,KAAf;AAOA,UAAMM,IAAI,GAAG,MAAMvE,QAAQ,CAACmI,OAAT,CAAiBF,MAAjB,CAAnB;AAEA,UAAMG,MAAM,GAAG7D,IAAI,CAACH,GAAL,CAASrC,GAAG,IAAI;AAC7B,YAAMsG,SAAS,GAAGR,YAAY,CAACS,QAAb,CAAsBvG,GAAtB,CAAlB;AACA,aAAOsG,SAAP;AACD,KAHc,CAAf;AAKA,WAAOD,MAAP;AACD;;AA5gBc","sourcesContent":["import has from 'lodash/has'\nimport { Contract, utils } from 'ethers'\nimport {\n  getWeb3,\n  getNetworkId,\n  getProvider,\n  getAccount,\n  getSigner\n} from './web3'\nimport { formatsByName } from '@ensdomains/address-encoder'\nimport { abi as ensContract } from '@ensdomains/contracts/abis/ens/ENS.json'\n\nimport { decryptHashes } from './preimage'\n\nimport {\n  uniq,\n  getEnsStartBlock,\n  checkLabels,\n  mergeLabels,\n  emptyAddress,\n  isDecrypted,\n  namehash,\n  labelhash\n} from './utils'\nimport { encodeLabelhash } from './utils/labelhash'\n\nimport {\n  getTestRegistrarContract,\n  getReverseRegistrarContract,\n  getENSContract,\n  getResolverContract,\n  getOldResolverContract\n} from './contracts'\n\nimport {\n  isValidContenthash,\n  encodeContenthash,\n  decodeContenthash\n} from './utils/contents'\n\n/* Utils */\n\nexport function getNamehash(name) {\n  return namehash(name)\n}\n\nasync function getNamehashWithLabelHash(labelHash, nodeHash) {\n  let node = utils.keccak256(nodeHash + labelHash.slice(2))\n  return node.toString()\n}\n\nfunction getLabelhash(label) {\n  return labelhash(label)\n}\n\nconst contracts = {\n  1: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  3: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  4: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  5: {\n    registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  }\n}\n\nexport class ENS {\n  constructor({ networkId, registryAddress, provider }) {\n    this.contracts = contracts\n    const hasRegistry = has(this.contracts[networkId], 'registry')\n\n    if (!hasRegistry && !registryAddress) {\n      throw new Error(`Unsupported network ${networkId}`)\n    } else if (this.contracts[networkId] && !registryAddress) {\n      registryAddress = contracts[networkId].registry\n    }\n\n    this.registryAddress = registryAddress\n\n    const ENSContract = getENSContract({ address: registryAddress, provider })\n    this.ENS = ENSContract\n  }\n\n  /* Get the raw Ethers contract object */\n  getENSContractInstance() {\n    return this.ENS\n  }\n\n  /* Main methods */\n\n  async getOwner(name) {\n    const namehash = getNamehash(name)\n    const owner = await this.ENS.owner(namehash)\n    return owner\n  }\n\n  async getResolver(name) {\n    const namehash = getNamehash(name)\n    return this.ENS.resolver(namehash)\n  }\n\n  async getTTL(name) {\n    const namehash = getNamehash(name)\n    return this.ENS.ttl(namehash)\n  }\n\n  async getResolverWithLabelhash(labelhash, nodehash) {\n    const namehash = await getNamehashWithLabelHash(labelhash, nodehash)\n    return this.ENS.resolver(namehash)\n  }\n\n  async getOwnerWithLabelHash(labelhash, nodeHash) {\n    const namehash = await getNamehashWithLabelHash(labelhash, nodeHash)\n    return this.ENS.owner(namehash)\n  }\n\n  async getEthAddressWithResolver(name, resolverAddr) {\n    if (parseInt(resolverAddr, 16) === 0) {\n      return emptyAddress\n    }\n    const namehash = getNamehash(name)\n    try {\n      const provider = await getProvider()\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      })\n      const addr = await Resolver['addr(bytes32)'](namehash)\n      return addr\n    } catch (e) {\n      console.warn(\n        'Error getting addr on the resolver contract, are you sure the resolver address is a resolver contract?'\n      )\n      return emptyAddress\n    }\n  }\n\n  async getAddress(name) {\n    const resolverAddr = await this.getResolver(name)\n    return this.getEthAddressWithResolver(name, resolverAddr)\n  }\n\n  async getAddr(name, key) {\n    const resolverAddr = await this.getResolver(name)\n    if (parseInt(resolverAddr, 16) === 0) return emptyAddress\n    return this.getAddrWithResolver(name, key, resolverAddr)\n  }\n\n  async getAddrWithResolver(name, key, resolverAddr) {\n    const namehash = getNamehash(name)\n    try {\n      const provider = await getProvider()\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      })\n      const { coinType, encoder } = formatsByName[key]\n      const addr = await Resolver['addr(bytes32,uint256)'](namehash, coinType)\n      if (addr === '0x') return emptyAddress\n\n      return encoder(Buffer.from(addr.slice(2), 'hex'))\n    } catch (e) {\n      console.log(e)\n      console.warn(\n        'Error getting addr on the resolver contract, are you sure the resolver address is a resolver contract?'\n      )\n      return emptyAddress\n    }\n  }\n\n  async getContent(name) {\n    const resolverAddr = await this.getResolver(name)\n    return this.getContentWithResolver(name, resolverAddr)\n  }\n\n  async getContentWithResolver(name, resolverAddr) {\n    if (parseInt(resolverAddr, 16) === 0) {\n      return emptyAddress\n    }\n    try {\n      const namehash = getNamehash(name)\n      const provider = await getProvider()\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      })\n      const contentHashSignature = utils\n        .solidityKeccak256(['string'], ['contenthash(bytes32)'])\n        .slice(0, 10)\n\n      const isContentHashSupported = await Resolver.supportsInterface(\n        contentHashSignature\n      )\n\n      if (isContentHashSupported) {\n        const encoded = await Resolver.contenthash(namehash)\n        const { protocolType, decoded, error } = decodeContenthash(encoded)\n        if (error) {\n          return {\n            value: error,\n            contentType: 'error'\n          }\n        }\n        return {\n          value: `${protocolType}://${decoded}`,\n          contentType: 'contenthash'\n        }\n      } else {\n        const value = await Resolver.content(namehash)\n        return {\n          value,\n          contentType: 'oldcontent'\n        }\n      }\n    } catch (e) {\n      const message =\n        'Error getting content on the resolver contract, are you sure the resolver address is a resolver contract?'\n      console.warn(message, e)\n      return { value: message, contentType: 'error' }\n    }\n  }\n\n  async getText(name, key) {\n    const resolverAddr = await this.getResolver(name)\n    return this.getTextWithResolver(name, key, resolverAddr)\n  }\n\n  async getTextWithResolver(name, key, resolverAddr) {\n    if (parseInt(resolverAddr, 16) === 0) {\n      return ''\n    }\n    const namehash = getNamehash(name)\n    try {\n      const provider = await getProvider()\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      })\n      const addr = await Resolver.text(namehash, key)\n      return addr\n    } catch (e) {\n      console.warn(\n        'Error getting text record on the resolver contract, are you sure the resolver address is a resolver contract?'\n      )\n      return ''\n    }\n  }\n\n  async getName(address) {\n    const reverseNode = `${address.slice(2)}.addr.reverse`\n    const resolverAddr = await this.getResolver(reverseNode)\n    return this.getNameWithResolver(address, resolverAddr)\n  }\n\n  async getNameWithResolver(address, resolverAddr) {\n    const reverseNode = `${address.slice(2)}.addr.reverse`\n    const reverseNamehash = getNamehash(reverseNode)\n    if (parseInt(resolverAddr, 16) === 0) {\n      return {\n        name: null\n      }\n    }\n\n    try {\n      const provider = await getProvider()\n      const Resolver = getResolverContract({\n        address: resolverAddr,\n        provider\n      })\n      const name = await Resolver.name(reverseNamehash)\n      return {\n        name\n      }\n    } catch (e) {\n      console.log(`Error getting name for reverse record of ${address}`, e)\n    }\n  }\n\n  async isMigrated(name) {\n    const namehash = getNamehash(name)\n    return this.ENS.recordExists(namehash)\n  }\n\n  async getResolverDetails(node) {\n    try {\n      const addrPromise = this.getAddress(node.name)\n      const contentPromise = this.getContent(node.name)\n      const [addr, content] = await Promise.all([addrPromise, contentPromise])\n      return {\n        ...node,\n        addr,\n        content: content.value,\n        contentType: content.contentType\n      }\n    } catch (e) {\n      return {\n        ...node,\n        addr: '0x0',\n        content: '0x0',\n        contentType: 'error'\n      }\n    }\n  }\n\n  async getSubdomains(name) {\n    const startBlock = await getEnsStartBlock()\n    const namehash = getNamehash(name)\n    const rawLogs = await this.getENSEvent('NewOwner', {\n      topics: [namehash],\n      fromBlock: startBlock\n    })\n    const flattenedLogs = rawLogs.map(log => log.values)\n    flattenedLogs.reverse()\n    const logs = uniq(flattenedLogs, 'label')\n    const labelhashes = logs.map(log => log.label)\n    const remoteLabels = await decryptHashes(...labelhashes)\n    const localLabels = checkLabels(...labelhashes)\n    const labels = mergeLabels(localLabels, remoteLabels)\n    const ownerPromises = labels.map(label => this.getOwner(`${label}.${name}`))\n\n    return Promise.all(ownerPromises).then(owners =>\n      owners.map((owner, index) => {\n        return {\n          label: labels[index],\n          labelhash: logs[index].label,\n          decrypted: labels[index] !== null,\n          node: name,\n          name: `${labels[index] ||\n            encodeLabelhash(logs[index].label)}.${name}`,\n          owner\n        }\n      })\n    )\n  }\n\n  async getDomainDetails(name) {\n    const nameArray = name.split('.')\n    const labelhash = getLabelhash(nameArray[0])\n    const [owner, resolver] = await Promise.all([\n      this.getOwner(name),\n      this.getResolver(name)\n    ])\n    const node = {\n      name,\n      label: nameArray[0],\n      labelhash,\n      owner,\n      resolver\n    }\n\n    const hasResolver = parseInt(node.resolver, 16) !== 0\n\n    if (hasResolver) {\n      return this.getResolverDetails(node)\n    }\n\n    return {\n      ...node,\n      addr: null,\n      content: null\n    }\n  }\n\n  /* non-constant functions */\n\n  async setOwner(name, newOwner) {\n    const ENSWithoutSigner = this.ENS\n    const signer = await getSigner()\n    const ENS = ENSWithoutSigner.connect(signer)\n    const namehash = getNamehash(name)\n    return ENS.setOwner(namehash, newOwner)\n  }\n\n  async setSubnodeOwner(name, newOwner) {\n    const ENSWithoutSigner = this.ENS\n    const signer = await getSigner()\n    const ENS = ENSWithoutSigner.connect(signer)\n    const nameArray = name.split('.')\n    const label = nameArray[0]\n    const node = nameArray.slice(1).join('.')\n    const labelhash = getLabelhash(label)\n    const parentNamehash = getNamehash(node)\n    return ENS.setSubnodeOwner(parentNamehash, labelhash, newOwner)\n  }\n\n  async setSubnodeRecord(name, newOwner, resolver) {\n    const ENSWithoutSigner = this.ENS\n    const signer = await getSigner()\n    const ENS = ENSWithoutSigner.connect(signer)\n    const nameArray = name.split('.')\n    const label = nameArray[0]\n    const node = nameArray.slice(1).join('.')\n    const labelhash = getLabelhash(label)\n    const parentNamehash = getNamehash(node)\n    const ttl = await this.getTTL(name)\n    return ENS.setSubnodeRecord(\n      parentNamehash,\n      labelhash,\n      newOwner,\n      resolver,\n      ttl\n    )\n  }\n\n  async setResolver(name, resolver) {\n    const namehash = getNamehash(name)\n    const ENSWithoutSigner = this.ENS\n    const signer = await getSigner()\n    const ENS = ENSWithoutSigner.connect(signer)\n    return ENS.setResolver(namehash, resolver)\n  }\n\n  async setAddress(name, address) {\n    const resolverAddr = await this.getResolver(name)\n    return this.setAddressWithResolver(name, address, resolverAddr)\n  }\n\n  async setAddressWithResolver(name, address, resolverAddr) {\n    const namehash = getNamehash(name)\n    const provider = await getProvider()\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const Resolver = ResolverWithoutSigner.connect(signer)\n    return Resolver['setAddr(bytes32,address)'](namehash, address)\n  }\n\n  async setAddr(name, key, address) {\n    const resolverAddr = await this.getResolver(name)\n    return this.setAddrWithResolver(name, key, address, resolverAddr)\n  }\n\n  async setAddrWithResolver(name, key, address, resolverAddr) {\n    const namehash = getNamehash(name)\n    const provider = await getProvider()\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const Resolver = ResolverWithoutSigner.connect(signer)\n    const { decoder, coinType } = formatsByName[key]\n    let addressAsBytes\n    if (!address || address === '') {\n      addressAsBytes = Buffer.from('')\n    } else {\n      addressAsBytes = decoder(address)\n    }\n    return Resolver['setAddr(bytes32,uint256,bytes)'](\n      namehash,\n      coinType,\n      addressAsBytes\n    )\n  }\n\n  async setContent(name, content) {\n    const resolverAddr = await this.getResolver(name)\n    return this.setContentWithResolver(name, content, resolverAddr)\n  }\n\n  async setContentWithResolver(name, content, resolverAddr) {\n    const namehash = getNamehash(name)\n    const provider = await getProvider()\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const Resolver = ResolverWithoutSigner.connect(signer)\n    return Resolver.setContent(namehash, content)\n  }\n\n  async setContenthash(name, content) {\n    const resolverAddr = await this.getResolver(name)\n    return this.setContenthashWithResolver(name, content, resolverAddr)\n  }\n\n  async setContenthashWithResolver(name, content, resolverAddr) {\n    let encodedContenthash = content\n    if (parseInt(content, 16) !== 0) {\n      encodedContenthash = encodeContenthash(content)\n    }\n    const namehash = getNamehash(name)\n    const provider = await getProvider()\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const Resolver = ResolverWithoutSigner.connect(signer)\n    return Resolver.setContenthash(namehash, encodedContenthash)\n  }\n\n  async setText(name, key, recordValue) {\n    const resolverAddr = await this.getResolver(name)\n    return this.setTextWithResolver(name, key, recordValue, resolverAddr)\n  }\n\n  async setTextWithResolver(name, key, recordValue, resolverAddr) {\n    const namehash = getNamehash(name)\n    const provider = await getProvider()\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const Resolver = ResolverWithoutSigner.connect(signer)\n    return Resolver.setText(namehash, key, recordValue)\n  }\n\n  async createSubdomain(name) {\n    const account = await getAccount()\n    const publicResolverAddress = await this.getAddress('resolver.eth')\n    try {\n      return this.setSubnodeRecord(name, account, publicResolverAddress)\n    } catch (e) {\n      console.log('error creating subdomain', e)\n    }\n  }\n\n  async deleteSubdomain(name) {\n    try {\n      return this.setSubnodeRecord(name, emptyAddress, emptyAddress)\n    } catch (e) {\n      console.log('error deleting subdomain', e)\n    }\n  }\n\n  async claimAndSetReverseRecordName(name, overrides = {}) {\n    const reverseRegistrarAddr = await this.getOwner('addr.reverse')\n    const provider = await getProvider(0)\n    const reverseRegistrarWithoutSigner = getReverseRegistrarContract({\n      address: reverseRegistrarAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const reverseRegistrar = reverseRegistrarWithoutSigner.connect(signer)\n    const networkId = await getNetworkId()\n\n    if (parseInt(networkId) > 1000) {\n      const gasLimit = await reverseRegistrar.estimateGas.setName(name)\n      overrides = {\n        gasLimit: gasLimit.toNumber() * 2,\n        ...overrides\n      }\n    }\n\n    return reverseRegistrar.setName(name, overrides)\n  }\n\n  async setReverseRecordName(name) {\n    const account = await getAccount()\n    const provider = await getProvider()\n    const reverseNode = `${account.slice(2)}.addr.reverse`\n    const resolverAddr = await this.getResolver(reverseNode)\n    const ResolverWithoutSigner = getResolverContract({\n      address: resolverAddr,\n      provider\n    })\n    const signer = await getSigner()\n    const Resolver = ResolverWithoutSigner.connect(signer)\n    let namehash = getNamehash(reverseNode)\n    return Resolver.setName(namehash, name)\n  }\n\n  // Events\n\n  async getENSEvent(event, { topics, fromBlock }) {\n    const provider = await getWeb3()\n    const { ENS } = this\n    const ensInterface = new utils.Interface(ensContract)\n    let Event = ENS.filters[event]()\n\n    const filter = {\n      fromBlock,\n      toBlock: 'latest',\n      address: Event.address,\n      topics: [...Event.topics, ...topics]\n    }\n\n    const logs = await provider.getLogs(filter)\n\n    const parsed = logs.map(log => {\n      const parsedLog = ensInterface.parseLog(log)\n      return parsedLog\n    })\n\n    return parsed\n  }\n}\n"]},"metadata":{},"sourceType":"module"}