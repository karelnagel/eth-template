{"ast":null,"code":"import { getNetworkId } from '../web3';\nimport { addressUtils } from '@0xproject/utils/lib/src/address_utils';\nimport { isEncodedLabelhash, isDecrypted, decodeLabelhash, encodeLabelhash, labelhash } from './labelhash';\nimport { encodeContenthash, decodeContenthash, isValidContenthash, getProtocolType } from './contents';\nimport { normalize } from '@ensdomains/eth-ens-namehash';\nimport { namehash } from './namehash'; //import { checkLabelHash } from '../updaters/preImageDB'\n\nconst uniq = (a, param) => a.filter((item, pos) => a.map(mapItem => mapItem[param]).indexOf(item[param]) === pos);\n\nconst checkLabels = function () {\n  for (var _len = arguments.length, labelHashes = new Array(_len), _key = 0; _key < _len; _key++) {\n    labelHashes[_key] = arguments[_key];\n  }\n\n  return labelHashes.map(hash => null);\n};\n\nasync function getEtherScanAddr() {\n  const networkId = await getNetworkId();\n\n  switch (networkId) {\n    case 1:\n    case '1':\n      return 'https://etherscan.io/';\n\n    case 3:\n    case '3':\n      return 'https://ropsten.etherscan.io/';\n\n    case 4:\n    case '4':\n      return 'https://rinkeby.etherscan.io/';\n\n    default:\n      return 'https://etherscan.io/';\n  }\n}\n\nasync function getEnsStartBlock() {\n  const networkId = await getNetworkId();\n\n  switch (networkId) {\n    case 1:\n    case '1':\n      return 3327417;\n\n    case 3:\n    case '3':\n      return 25409;\n\n    default:\n      return 0;\n  }\n} // export const checkLabels = (...labelHashes) =>\n//   labelHashes.map(labelHash => checkLabelHash(labelHash) || null)\n\n\nconst mergeLabels = (labels1, labels2) => labels1.map((label, index) => label ? label : labels2[index]);\n\nfunction validateName(name) {\n  const nameArray = name.split('.');\n  const hasEmptyLabels = nameArray.some(label => label.length == 0);\n  if (hasEmptyLabels) throw new Error('Domain cannot have empty labels');\n  const normalizedArray = nameArray.map(label => {\n    if (label === '[root]') {\n      return label;\n    } else {\n      return isEncodedLabelhash(label) ? label : normalize(label);\n    }\n  });\n\n  try {\n    return normalizedArray.join('.');\n  } catch (e) {\n    throw e;\n  }\n}\n\nfunction isLabelValid(name) {\n  try {\n    validateName(name);\n\n    if (name.indexOf('.') === -1) {\n      return true;\n    }\n  } catch (e) {\n    console.log(e);\n    return false;\n  }\n}\n\nconst parseSearchTerm = (term, validTld) => {\n  let regex = /[^.]+$/;\n\n  try {\n    validateName(term);\n  } catch (e) {\n    return 'invalid';\n  }\n\n  if (term.indexOf('.') !== -1) {\n    const termArray = term.split('.');\n    const tld = term.match(regex) ? term.match(regex)[0] : '';\n\n    if (validTld) {\n      if (tld === 'eth' && [...termArray[termArray.length - 2]].length < 3) {\n        // code-point length\n        return 'short';\n      }\n\n      return 'supported';\n    }\n\n    return 'unsupported';\n  } else if (addressUtils.isAddress(term)) {\n    return 'address';\n  } else {\n    //check if the search term is actually a tld\n    if (validTld) {\n      return 'tld';\n    }\n\n    return 'search';\n  }\n};\n\nconst emptyAddress = '0x0000000000000000000000000000000000000000';\nexport { // general utils\nuniq, emptyAddress, getEtherScanAddr, getEnsStartBlock, checkLabels, mergeLabels, // name validation\nvalidateName, parseSearchTerm, isLabelValid, // labelhash utils\nlabelhash, isEncodedLabelhash, isDecrypted, decodeLabelhash, encodeLabelhash, // namehash utils\nnamehash, // contents utils\nencodeContenthash, decodeContenthash, isValidContenthash, getProtocolType };","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@ensdomains/ui/src/utils/index.js"],"names":["getNetworkId","addressUtils","isEncodedLabelhash","isDecrypted","decodeLabelhash","encodeLabelhash","labelhash","encodeContenthash","decodeContenthash","isValidContenthash","getProtocolType","normalize","namehash","uniq","a","param","filter","item","pos","map","mapItem","indexOf","checkLabels","labelHashes","hash","getEtherScanAddr","networkId","getEnsStartBlock","mergeLabels","labels1","labels2","label","index","validateName","name","nameArray","split","hasEmptyLabels","some","length","Error","normalizedArray","join","e","isLabelValid","console","log","parseSearchTerm","term","validTld","regex","termArray","tld","match","isAddress","emptyAddress"],"mappings":"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","sourcesContent":["import { getNetworkId } from '../web3'\nimport { addressUtils } from '@0xproject/utils/lib/src/address_utils'\n\nimport {\n  isEncodedLabelhash,\n  isDecrypted,\n  decodeLabelhash,\n  encodeLabelhash,\n  labelhash\n} from './labelhash'\nimport {\n  encodeContenthash,\n  decodeContenthash,\n  isValidContenthash,\n  getProtocolType\n} from './contents'\nimport { normalize } from '@ensdomains/eth-ens-namehash'\nimport { namehash } from './namehash'\n\n//import { checkLabelHash } from '../updaters/preImageDB'\n\nconst uniq = (a, param) =>\n  a.filter(\n    (item, pos) => a.map(mapItem => mapItem[param]).indexOf(item[param]) === pos\n  )\n\nconst checkLabels = (...labelHashes) => labelHashes.map(hash => null)\n\nasync function getEtherScanAddr() {\n  const networkId = await getNetworkId()\n  switch (networkId) {\n    case 1:\n    case '1':\n      return 'https://etherscan.io/'\n    case 3:\n    case '3':\n      return 'https://ropsten.etherscan.io/'\n    case 4:\n    case '4':\n      return 'https://rinkeby.etherscan.io/'\n    default:\n      return 'https://etherscan.io/'\n  }\n}\n\nasync function getEnsStartBlock() {\n  const networkId = await getNetworkId()\n  switch (networkId) {\n    case 1:\n    case '1':\n      return 3327417\n    case 3:\n    case '3':\n      return 25409\n    default:\n      return 0\n  }\n}\n\n// export const checkLabels = (...labelHashes) =>\n//   labelHashes.map(labelHash => checkLabelHash(labelHash) || null)\n\nconst mergeLabels = (labels1, labels2) =>\n  labels1.map((label, index) => (label ? label : labels2[index]))\n\nfunction validateName(name) {\n  const nameArray = name.split('.')\n  const hasEmptyLabels = nameArray.some(label => label.length == 0); \n  if (hasEmptyLabels) throw new Error('Domain cannot have empty labels')\n  const normalizedArray = nameArray.map(label => {\n    if(label === '[root]'){\n      return label\n    }else{\n      return isEncodedLabelhash(label) ? label : normalize(label)\n    }\n  })\n  try {\n    return normalizedArray.join('.')\n  } catch (e) {\n    throw e\n  }\n}\n\nfunction isLabelValid(name) {\n  try {\n    validateName(name)\n    if (name.indexOf('.') === -1) {\n      return true\n    }\n  } catch (e) {\n    console.log(e)\n    return false\n  }\n}\n\nconst parseSearchTerm = (term, validTld) => {\n  let regex = /[^.]+$/\n\n  try {\n    validateName(term)\n  } catch (e) {\n    return 'invalid'\n  }\n\n  if (term.indexOf('.') !== -1) {\n    const termArray = term.split('.')\n    const tld = term.match(regex) ? term.match(regex)[0] : ''\n    if (validTld) {\n      if (tld === 'eth' && [...termArray[termArray.length - 2]].length < 3) { // code-point length\n        return 'short'\n      }\n      return 'supported'\n    }\n\n    return 'unsupported'\n  } else if (addressUtils.isAddress(term)) {\n    return 'address'\n  } else {\n    //check if the search term is actually a tld\n    if (validTld) {\n      return 'tld'\n    }\n    return 'search'\n  }\n}\n\nconst emptyAddress = '0x0000000000000000000000000000000000000000'\n\nexport {\n  // general utils\n  uniq,\n  emptyAddress,\n  getEtherScanAddr,\n  getEnsStartBlock,\n  checkLabels,\n  mergeLabels,\n  // name validation\n  validateName,\n  parseSearchTerm,\n  isLabelValid,\n  // labelhash utils\n  labelhash,\n  isEncodedLabelhash,\n  isDecrypted,\n  decodeLabelhash,\n  encodeLabelhash,\n  // namehash utils\n  namehash,\n  // contents utils\n  encodeContenthash,\n  decodeContenthash,\n  isValidContenthash,\n  getProtocolType\n}\n"]},"metadata":{},"sourceType":"module"}