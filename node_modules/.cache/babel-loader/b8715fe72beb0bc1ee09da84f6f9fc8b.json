{"ast":null,"code":"const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst v4Size = 4;\nconst v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\nconst v6Size = 16;\nconst v4 = {\n  name: 'v4',\n  size: v4Size,\n  isFormat: ip => v4Regex.test(ip),\n\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    buff = buff || new Uint8Array(offset + v4Size);\n    const max = ip.length;\n    let n = 0;\n\n    for (let i = 0; i < max;) {\n      const c = ip.charCodeAt(i++);\n\n      if (c === 46) {\n        // \".\"\n        buff[offset++] = n;\n        n = 0;\n      } else {\n        n = n * 10 + (c - 48);\n      }\n    }\n\n    buff[offset] = n;\n    return buff;\n  },\n\n  decode(buff, offset) {\n    offset = ~~offset;\n    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;\n  }\n\n};\nconst v6 = {\n  name: 'v6',\n  size: v6Size,\n  isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    let end = offset + v6Size;\n    let fill = -1;\n    let hexN = 0;\n    let decN = 0;\n    let prevColon = true;\n    let useDec = false;\n    buff = buff || new Uint8Array(offset + v6Size); // Note: This algorithm needs to check if the offset\n    // could exceed the buffer boundaries as it supports\n    // non-standard compliant encodings that may go beyond\n    // the boundary limits. if (offset < end) checks should\n    // not be necessary...\n\n    for (let i = 0; i < ip.length; i++) {\n      let c = ip.charCodeAt(i);\n\n      if (c === 58) {\n        // :\n        if (prevColon) {\n          if (fill !== -1) {\n            // Not Standard! (standard doesn't allow multiple ::)\n            // We need to treat\n            if (offset < end) buff[offset] = 0;\n            if (offset < end - 1) buff[offset + 1] = 0;\n            offset += 2;\n          } else if (offset < end) {\n            // :: in the middle\n            fill = offset;\n          }\n        } else {\n          // : ends the previous number\n          if (useDec === true) {\n            // Non-standard! (ipv4 should be at end only)\n            // A ipv4 address should not be found anywhere else but at\n            // the end. This codec also support putting characters\n            // after the ipv4 address..\n            if (offset < end) buff[offset] = decN;\n            offset++;\n          } else {\n            if (offset < end) buff[offset] = hexN >> 8;\n            if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n            offset += 2;\n          }\n\n          hexN = 0;\n          decN = 0;\n        }\n\n        prevColon = true;\n        useDec = false;\n      } else if (c === 46) {\n        // . indicates IPV4 notation\n        if (offset < end) buff[offset] = decN;\n        offset++;\n        decN = 0;\n        hexN = 0;\n        prevColon = false;\n        useDec = true;\n      } else {\n        prevColon = false;\n\n        if (c >= 97) {\n          c -= 87; // a-f ... 97~102 -87 => 10~15\n        } else if (c >= 65) {\n          c -= 55; // A-F ... 65~70 -55 => 10~15\n        } else {\n          c -= 48; // 0-9 ... starting from charCode 48\n\n          decN = decN * 10 + c;\n        } // We don't know yet if its a dec or hex number\n\n\n        hexN = (hexN << 4) + c;\n      }\n    }\n\n    if (prevColon === false) {\n      // Commiting last number\n      if (useDec === true) {\n        if (offset < end) buff[offset] = decN;\n        offset++;\n      } else {\n        if (offset < end) buff[offset] = hexN >> 8;\n        if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n        offset += 2;\n      }\n    } else if (fill === 0) {\n      // Not Standard! (standard doesn't allow multiple ::)\n      // This means that a : was found at the start AND end which means the\n      // end needs to be treated as 0 entry...\n      if (offset < end) buff[offset] = 0;\n      if (offset < end - 1) buff[offset + 1] = 0;\n      offset += 2;\n    } else if (fill !== -1) {\n      // Non-standard! (standard doens't allow multiple ::)\n      // Here we find that there has been a :: somewhere in the middle\n      // and the end. To treat the end with priority we need to move all\n      // written data two bytes to the right.\n      offset += 2;\n\n      for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n        buff[i] = buff[i - 2];\n      }\n\n      buff[fill] = 0;\n      buff[fill + 1] = 0;\n      fill = offset;\n    }\n\n    if (fill !== offset && fill !== -1) {\n      // Move the written numbers to the end while filling the everything\n      // \"fill\" to the bytes with zeros.\n      if (offset > end - 2) {\n        // Non Standard support, when the cursor exceeds bounds.\n        offset = end - 2;\n      }\n\n      while (end > fill) {\n        buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;\n      }\n    } else {\n      // Fill the rest with zeros\n      while (offset < end) {\n        buff[offset++] = 0;\n      }\n    }\n\n    return buff;\n  },\n\n  decode(buff, offset) {\n    offset = ~~offset;\n    let result = '';\n\n    for (let i = 0; i < v6Size; i += 2) {\n      if (i !== 0) {\n        result += ':';\n      }\n\n      result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);\n    }\n\n    return result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');\n  }\n\n};\n\nfunction sizeOf(ip) {\n  if (v4.isFormat(ip)) return v4.size;\n  if (v6.isFormat(ip)) return v6.size;\n  throw Error(`Invalid ip address: ${ip}`);\n}\n\nmodule.exports = Object.freeze({\n  name: 'ip',\n  sizeOf,\n  familyOf: string => sizeOf(string) === v4.size ? 1 : 2,\n  v4,\n  v6,\n\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    const size = sizeOf(ip);\n\n    if (typeof buff === 'function') {\n      buff = buff(offset + size);\n    }\n\n    if (size === v4.size) {\n      return v4.encode(ip, buff, offset);\n    }\n\n    return v6.encode(ip, buff, offset);\n  },\n\n  decode(buff, offset, length) {\n    offset = ~~offset;\n    length = length || buff.length - offset;\n\n    if (length === v4.size) {\n      return v4.decode(buff, offset, length);\n    }\n\n    if (length === v6.size) {\n      return v6.decode(buff, offset, length);\n    }\n\n    throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`);\n  }\n\n});","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@leichtgewicht/ip-codec/index.js"],"names":["v4Regex","v4Size","v6Regex","v6Size","v4","name","size","isFormat","ip","test","encode","buff","offset","Uint8Array","max","length","n","i","c","charCodeAt","decode","v6","end","fill","hexN","decN","prevColon","useDec","Math","min","result","toString","replace","sizeOf","Error","module","exports","Object","freeze","familyOf","string"],"mappings":"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","sourcesContent":["const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/\nconst v4Size = 4\nconst v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i\nconst v6Size = 16\n\nconst v4 = {\n  name: 'v4',\n  size: v4Size,\n  isFormat: ip => v4Regex.test(ip),\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    buff = buff || new Uint8Array(offset + v4Size)\n    const max = ip.length\n    let n = 0\n    for (let i = 0; i < max;) {\n      const c = ip.charCodeAt(i++)\n      if (c === 46) { // \".\"\n        buff[offset++] = n\n        n = 0\n      } else {\n        n = n * 10 + (c - 48)\n      }\n    }\n    buff[offset] = n\n    return buff\n  },\n  decode (buff, offset) {\n    offset = ~~offset\n    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`\n  }\n}\n\nconst v6 = {\n  name: 'v6',\n  size: v6Size,\n  isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    let end = offset + v6Size\n    let fill = -1\n    let hexN = 0\n    let decN = 0\n    let prevColon = true\n    let useDec = false\n    buff = buff || new Uint8Array(offset + v6Size)\n    // Note: This algorithm needs to check if the offset\n    // could exceed the buffer boundaries as it supports\n    // non-standard compliant encodings that may go beyond\n    // the boundary limits. if (offset < end) checks should\n    // not be necessary...\n    for (let i = 0; i < ip.length; i++) {\n      let c = ip.charCodeAt(i)\n      if (c === 58) { // :\n        if (prevColon) {\n          if (fill !== -1) {\n            // Not Standard! (standard doesn't allow multiple ::)\n            // We need to treat\n            if (offset < end) buff[offset] = 0\n            if (offset < end - 1) buff[offset + 1] = 0\n            offset += 2\n          } else if (offset < end) {\n            // :: in the middle\n            fill = offset\n          }\n        } else {\n          // : ends the previous number\n          if (useDec === true) {\n            // Non-standard! (ipv4 should be at end only)\n            // A ipv4 address should not be found anywhere else but at\n            // the end. This codec also support putting characters\n            // after the ipv4 address..\n            if (offset < end) buff[offset] = decN\n            offset++\n          } else {\n            if (offset < end) buff[offset] = hexN >> 8\n            if (offset < end - 1) buff[offset + 1] = hexN & 0xff\n            offset += 2\n          }\n          hexN = 0\n          decN = 0\n        }\n        prevColon = true\n        useDec = false\n      } else if (c === 46) { // . indicates IPV4 notation\n        if (offset < end) buff[offset] = decN\n        offset++\n        decN = 0\n        hexN = 0\n        prevColon = false\n        useDec = true\n      } else {\n        prevColon = false\n        if (c >= 97) {\n          c -= 87 // a-f ... 97~102 -87 => 10~15\n        } else if (c >= 65) {\n          c -= 55 // A-F ... 65~70 -55 => 10~15\n        } else {\n          c -= 48 // 0-9 ... starting from charCode 48\n          decN = decN * 10 + c\n        }\n        // We don't know yet if its a dec or hex number\n        hexN = (hexN << 4) + c\n      }\n    }\n    if (prevColon === false) {\n      // Commiting last number\n      if (useDec === true) {\n        if (offset < end) buff[offset] = decN\n        offset++\n      } else {\n        if (offset < end) buff[offset] = hexN >> 8\n        if (offset < end - 1) buff[offset + 1] = hexN & 0xff\n        offset += 2\n      }\n    } else if (fill === 0) {\n      // Not Standard! (standard doesn't allow multiple ::)\n      // This means that a : was found at the start AND end which means the\n      // end needs to be treated as 0 entry...\n      if (offset < end) buff[offset] = 0\n      if (offset < end - 1) buff[offset + 1] = 0\n      offset += 2\n    } else if (fill !== -1) {\n      // Non-standard! (standard doens't allow multiple ::)\n      // Here we find that there has been a :: somewhere in the middle\n      // and the end. To treat the end with priority we need to move all\n      // written data two bytes to the right.\n      offset += 2\n      for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n        buff[i] = buff[i - 2]\n      }\n      buff[fill] = 0\n      buff[fill + 1] = 0\n      fill = offset\n    }\n    if (fill !== offset && fill !== -1) {\n      // Move the written numbers to the end while filling the everything\n      // \"fill\" to the bytes with zeros.\n      if (offset > end - 2) {\n        // Non Standard support, when the cursor exceeds bounds.\n        offset = end - 2\n      }\n      while (end > fill) {\n        buff[--end] = offset < end && offset > fill ? buff[--offset] : 0\n      }\n    } else {\n      // Fill the rest with zeros\n      while (offset < end) {\n        buff[offset++] = 0\n      }\n    }\n    return buff\n  },\n  decode (buff, offset) {\n    offset = ~~offset\n    let result = ''\n    for (let i = 0; i < v6Size; i += 2) {\n      if (i !== 0) {\n        result += ':'\n      }\n      result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16)\n    }\n    return result\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n}\n\nfunction sizeOf (ip) {\n  if (v4.isFormat(ip)) return v4.size\n  if (v6.isFormat(ip)) return v6.size\n  throw Error(`Invalid ip address: ${ip}`)\n}\n\nmodule.exports = Object.freeze({\n  name: 'ip',\n  sizeOf,\n  familyOf: string => sizeOf(string) === v4.size ? 1 : 2,\n  v4,\n  v6,\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    const size = sizeOf(ip)\n    if (typeof buff === 'function') {\n      buff = buff(offset + size)\n    }\n    if (size === v4.size) {\n      return v4.encode(ip, buff, offset)\n    }\n    return v6.encode(ip, buff, offset)\n  },\n  decode (buff, offset, length) {\n    offset = ~~offset\n    length = length || (buff.length - offset)\n    if (length === v4.size) {\n      return v4.decode(buff, offset, length)\n    }\n    if (length === v6.size) {\n      return v6.decode(buff, offset, length)\n    }\n    throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`)\n  }\n})\n"]},"metadata":{},"sourceType":"script"}