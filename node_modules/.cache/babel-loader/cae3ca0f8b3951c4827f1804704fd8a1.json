{"ast":null,"code":"import DNSRegistrarJS from './dnsregistrar';\nimport { getENSContract, getResolverContract, getPermanentRegistrarContract, getDnsRegistrarContract, getOldDnsRegistrarContract, getPermanentRegistrarControllerContract, getLegacyAuctionContract, getDeedContract, getTestRegistrarContract, getBulkRenewalContract } from './contracts';\nimport { getAccount, getBlock, getProvider, getSigner, getNetworkId, getWeb3Read, getLegacyProvider } from './web3';\nimport { namehash } from './utils/namehash';\nimport { interfaces } from './constants/interfaces';\nimport { isEncodedLabelhash, labelhash } from './utils/labelhash';\nimport { utils } from 'ethers';\nconst {\n  legacyRegistrar: legacyRegistrarInterfaceId,\n  permanentRegistrar: permanentRegistrarInterfaceId,\n  bulkRenewal: bulkRenewalInterfaceId,\n  dnsRegistrar: dnsRegistrarInterfaceId,\n  dnssecClaimOld: dnssecClaimOldId,\n  dnssecClaimNew: dnssecClaimNewId\n} = interfaces; // Renewal seem failing as it's not correctly estimating gas to return when buffer exceeds the renewal cost\n\nconst transferGasCost = 21000;\n\nfunction checkArguments(_ref) {\n  let {\n    registryAddress,\n    ethAddress,\n    legacyAuctionRegistrarAddress,\n    provider\n  } = _ref;\n  if (!registryAddress) throw 'No registry address given to Registrar class';\n  if (!legacyAuctionRegistrarAddress) throw 'No legacy auction address given to Registrar class';\n  if (!ethAddress) throw 'No .eth address given to Registrar class';\n  if (!provider) throw 'Provider is required for Registrar';\n  return;\n} // Add 10% buffer to handle price fructuation.\n// Any unused value will be sent back by the smart contract.\n\n\nfunction getBufferedPrice(price) {\n  return price.mul(110).div(100);\n}\n\nexport default class Registrar {\n  constructor(_ref2) {\n    let {\n      registryAddress,\n      ethAddress,\n      legacyAuctionRegistrarAddress,\n      controllerAddress,\n      bulkRenewalAddress,\n      provider\n    } = _ref2;\n    checkArguments({\n      registryAddress,\n      ethAddress,\n      legacyAuctionRegistrarAddress,\n      provider\n    });\n    const permanentRegistrar = getPermanentRegistrarContract({\n      address: ethAddress,\n      provider\n    });\n    const permanentRegistrarController = getPermanentRegistrarControllerContract({\n      address: controllerAddress,\n      provider\n    });\n    const legacyAuctionRegistrar = getLegacyAuctionContract({\n      address: legacyAuctionRegistrarAddress,\n      provider\n    });\n    const bulkRenewal = getBulkRenewalContract({\n      address: bulkRenewalAddress,\n      provider\n    });\n    const ENS = getENSContract({\n      address: registryAddress,\n      provider\n    });\n    this.permanentRegistrar = permanentRegistrar;\n    this.permanentRegistrarController = permanentRegistrarController;\n    this.legacyAuctionRegistrar = legacyAuctionRegistrar;\n    this.registryAddress = registryAddress;\n    this.bulkRenewal = bulkRenewal;\n    this.ENS = ENS;\n  }\n\n  async getAddress(name) {\n    const provider = await getProvider();\n    const hash = namehash(name);\n    const resolverAddr = await this.ENS.resolver(hash);\n    const Resolver = getResolverContract({\n      address: resolverAddr,\n      provider\n    });\n    return Resolver['addr(bytes32)'](hash);\n  }\n\n  async getDeed(address) {\n    const provider = await getProvider();\n    return getDeedContract({\n      address,\n      provider\n    });\n  }\n\n  async getLegacyEntry(label) {\n    let legacyEntry;\n\n    try {\n      const Registrar = this.legacyAuctionRegistrar;\n      let deedOwner = '0x0';\n      const entry = await Registrar.entries(labelhash(label));\n\n      if (parseInt(entry[1], 16) !== 0) {\n        const deed = await this.getDeed(entry[1]);\n        deedOwner = await deed.owner();\n      }\n\n      legacyEntry = {\n        deedOwner,\n        // TODO: Display \"Release\" button if deedOwner is not 0x0\n        state: parseInt(entry[0]),\n        registrationDate: parseInt(entry[2]) * 1000,\n        revealDate: (parseInt(entry[2]) - 24 * 2 * 60 * 60) * 1000,\n        value: parseInt(entry[3]),\n        highestBid: parseInt(entry[4])\n      };\n    } catch (e) {\n      legacyEntry = {\n        deedOwner: '0x0',\n        state: 0,\n        registrationDate: 0,\n        revealDate: 0,\n        value: 0,\n        highestBid: 0,\n        expiryTime: 0,\n        error: e.message\n      };\n    }\n\n    return legacyEntry;\n  }\n\n  async getPermanentEntry(label) {\n    const {\n      permanentRegistrar: Registrar,\n      permanentRegistrarController: RegistrarController\n    } = this;\n    let getAvailable;\n    let ret = {\n      available: null,\n      nameExpires: null\n    };\n\n    try {\n      const labelHash = labelhash(label); // Returns true if name is available\n\n      if (isEncodedLabelhash(label)) {\n        getAvailable = Registrar.available(labelHash);\n      } else {\n        getAvailable = RegistrarController.available(label);\n      }\n\n      const [available, nameExpires, gracePeriod] = await Promise.all([getAvailable, Registrar.nameExpires(labelHash), this.getGracePeriod(Registrar)]);\n      ret = { ...ret,\n        available,\n        gracePeriod,\n        nameExpires: nameExpires > 0 ? new Date(nameExpires * 1000) : null\n      }; // Returns registrar address if owned by new registrar.\n      // Keep it as a separate call as this will throw exception for non existing domains\n\n      ret.ownerOf = await Registrar.ownerOf(labelHash);\n    } catch (e) {\n      console.log('Error getting permanent registrar entry', e);\n      return false;\n    } finally {\n      return ret;\n    }\n  }\n\n  async getEntry(label) {\n    let [block, legacyEntry, permEntry] = await Promise.all([getBlock(), this.getLegacyEntry(label), this.getPermanentEntry(label)]);\n    let ret = {\n      currentBlockDate: new Date(block.timestamp * 1000),\n      registrant: 0,\n      transferEndDate: null,\n      isNewRegistrar: false,\n      gracePeriodEndDate: null\n    };\n\n    if (permEntry) {\n      ret.available = permEntry.available;\n\n      if (permEntry.nameExpires) {\n        ret.expiryTime = permEntry.nameExpires;\n      }\n\n      if (permEntry.ownerOf) {\n        ret.registrant = permEntry.ownerOf;\n        ret.isNewRegistrar = true;\n      } else if (permEntry.nameExpires) {\n        const currentTime = new Date(ret.currentBlockDate);\n        const gracePeriodEndDate = new Date(permEntry.nameExpires.getTime() + permEntry.gracePeriod * 1000); // It is within grace period\n\n        if (permEntry.nameExpires < currentTime < gracePeriodEndDate) {\n          ret.isNewRegistrar = true;\n          ret.gracePeriodEndDate = gracePeriodEndDate;\n        }\n      }\n    }\n\n    return { ...legacyEntry,\n      ...ret\n    };\n  }\n\n  async getGracePeriod(Registrar) {\n    if (!this.gracePeriod) {\n      this.gracePeriod = await Registrar.GRACE_PERIOD();\n      return this.gracePeriod;\n    }\n\n    return this.gracePeriod;\n  }\n\n  async transferOwner(name, to) {\n    let overrides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    try {\n      const nameArray = name.split('.');\n      const labelHash = labelhash(nameArray[0]);\n      const account = await getAccount();\n      const permanentRegistrar = this.permanentRegistrar;\n      const signer = await getSigner();\n      const Registrar = permanentRegistrar.connect(signer);\n      const networkId = await getNetworkId();\n\n      if (parseInt(networkId) > 1000) {\n        /* if private network */\n        const gas = await Registrar.estimateGas[\"safeTransferFrom(address,address,uint256)\"](account, to, labelHash);\n        overrides = { ...overrides,\n          gasLimit: gas.toNumber() * 2\n        };\n      }\n\n      return Registrar[\"safeTransferFrom(address,address,uint256)\"](account, to, labelHash, overrides);\n    } catch (e) {\n      console.log('Error calling transferOwner', e);\n    }\n  }\n\n  async reclaim(name, address) {\n    let overrides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    try {\n      const nameArray = name.split('.');\n      const labelHash = labelhash(nameArray[0]);\n      const permanentRegistrar = this.permanentRegistrar;\n      const signer = await getSigner();\n      const Registrar = permanentRegistrar.connect(signer);\n      const networkId = await getNetworkId();\n\n      if (parseInt(networkId) > 1000) {\n        /* if private network */\n        const gas = await Registrar.estimateGas.reclaim(labelHash, address);\n        overrides = { ...overrides,\n          gasLimit: gas.toNumber() * 2\n        };\n      }\n\n      return Registrar.reclaim(labelHash, address, { ...overrides\n      });\n    } catch (e) {\n      console.log('Error calling reclaim', e);\n    }\n  }\n\n  async getRentPrice(name, duration) {\n    const permanentRegistrarController = this.permanentRegistrarController;\n    let price = await permanentRegistrarController.rentPrice(name, duration);\n    return price;\n  }\n\n  async getRentPrices(labels, duration) {\n    const pricesArray = await Promise.all(labels.map(label => {\n      return this.getRentPrice(label, duration);\n    }));\n    return pricesArray.reduce((a, c) => a.add(c));\n  }\n\n  async getMinimumCommitmentAge() {\n    const permanentRegistrarController = this.permanentRegistrarController;\n    return permanentRegistrarController.minCommitmentAge();\n  }\n\n  async getMaximumCommitmentAge() {\n    const permanentRegistrarController = this.permanentRegistrarController;\n    return permanentRegistrarController.maxCommitmentAge();\n  }\n\n  async makeCommitment(name, owner) {\n    let secret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const permanentRegistrarControllerWithoutSigner = this.permanentRegistrarController;\n    const signer = await getSigner();\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(signer);\n    const account = await getAccount();\n    const resolverAddr = await this.getAddress('resolver.eth');\n\n    if (parseInt(resolverAddr, 16) === 0) {\n      return permanentRegistrarController.makeCommitment(name, owner, secret);\n    } else {\n      return permanentRegistrarController.makeCommitmentWithConfig(name, owner, secret, resolverAddr, account);\n    }\n  }\n\n  async checkCommitment(label) {\n    let secret = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    const permanentRegistrarControllerWithoutSigner = this.permanentRegistrarController;\n    const signer = await getSigner();\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(signer);\n    const account = await getAccount();\n    const commitment = await this.makeCommitment(label, account, secret);\n    return await permanentRegistrarController.commitments(commitment);\n  }\n\n  async commit(label) {\n    let secret = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    const permanentRegistrarControllerWithoutSigner = this.permanentRegistrarController;\n    const signer = await getSigner();\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(signer);\n    const account = await getAccount();\n    const commitment = await this.makeCommitment(label, account, secret);\n    return permanentRegistrarController.commit(commitment);\n  }\n\n  async register(label, duration, secret) {\n    const permanentRegistrarControllerWithoutSigner = this.permanentRegistrarController;\n    const signer = await getSigner();\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(signer);\n    const account = await getAccount();\n    const price = await this.getRentPrice(label, duration);\n    const priceWithBuffer = getBufferedPrice(price);\n    const resolverAddr = await this.getAddress('resolver.eth');\n\n    if (parseInt(resolverAddr, 16) === 0) {\n      const gasLimit = await this.estimateGasLimit(() => {\n        return permanentRegistrarController.estimateGas.register(label, account, duration, secret, {\n          value: priceWithBuffer\n        });\n      });\n      return permanentRegistrarController.register(label, account, duration, secret, {\n        value: priceWithBuffer,\n        gasLimit\n      });\n    } else {\n      const gasLimit = await this.estimateGasLimit(() => {\n        return permanentRegistrarController.estimateGas.registerWithConfig(label, account, duration, secret, resolverAddr, account, {\n          value: priceWithBuffer\n        });\n      });\n      return permanentRegistrarController.registerWithConfig(label, account, duration, secret, resolverAddr, account, {\n        value: priceWithBuffer,\n        gasLimit\n      });\n    }\n  }\n\n  async estimateGasLimit(cb) {\n    let gas = 0;\n\n    try {\n      gas = (await cb()).toNumber();\n    } catch (e) {\n      let matched = e.message.match(/\\(supplied gas (.*)\\)/) || e.message.match(/\\(gas required exceeds allowance (.*)\\)/);\n\n      if (matched) {\n        gas = parseInt(matched[1]);\n      }\n\n      console.log({\n        gas,\n        e,\n        matched\n      });\n    }\n\n    if (gas > 0) {\n      return gas + transferGasCost;\n    } else {\n      return gas;\n    }\n  }\n\n  async renew(label, duration) {\n    const permanentRegistrarControllerWithoutSigner = this.permanentRegistrarController;\n    const signer = await getSigner();\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(signer);\n    const price = await this.getRentPrice(label, duration);\n    const priceWithBuffer = getBufferedPrice(price);\n    const gasLimit = await this.estimateGasLimit(() => {\n      return permanentRegistrarController.estimateGas.renew(label, duration, {\n        value: priceWithBuffer\n      });\n    });\n    return permanentRegistrarController.renew(label, duration, {\n      value: priceWithBuffer,\n      gasLimit\n    });\n  }\n\n  async renewAll(labels, duration) {\n    const bulkRenewalWithoutSigner = this.bulkRenewal;\n    const signer = await getSigner();\n    const bulkRenewal = bulkRenewalWithoutSigner.connect(signer);\n    const prices = await this.getRentPrices(labels, duration);\n    const pricesWithBuffer = getBufferedPrice(prices);\n    const gasLimit = await this.estimateGasLimit(() => {\n      return bulkRenewal.estimateGas.renewAll(labels, duration, {\n        value: pricesWithBuffer\n      });\n    });\n    return bulkRenewal.renewAll(labels, duration, {\n      value: pricesWithBuffer,\n      gasLimit\n    });\n  }\n\n  async releaseDeed(label) {\n    const legacyAuctionRegistrar = this.legacyAuctionRegistrar;\n    const signer = await getSigner();\n    const legacyAuctionRegistrarWithSigner = legacyAuctionRegistrar.connect(signer);\n    const hash = labelhash(label);\n    return legacyAuctionRegistrarWithSigner.releaseDeed(hash);\n  }\n\n  async isDNSRegistrar(parentOwner) {\n    const provider = await getProvider();\n    const registrar = await getDnsRegistrarContract({\n      parentOwner,\n      provider\n    });\n    let isDNSSECSupported = false,\n        isOld = false,\n        isNew = false;\n\n    try {\n      isOld = await registrar['supportsInterface(bytes4)'](dnssecClaimOldId);\n      isNew = await registrar['supportsInterface(bytes4)'](dnssecClaimNewId);\n    } catch (e) {\n      console.log({\n        e\n      });\n    }\n\n    isDNSSECSupported = isOld || isNew;\n    return isDNSSECSupported;\n  }\n\n  async selectDnsRegistrarContract(_ref3) {\n    let {\n      parentOwner,\n      provider\n    } = _ref3;\n    let registrarContract = await getOldDnsRegistrarContract({\n      parentOwner,\n      provider\n    });\n    let isOld = false,\n        isNew = false;\n\n    try {\n      isOld = await registrarContract['supportsInterface(bytes4)'](dnssecClaimOldId);\n\n      if (!isOld) {\n        registrarContract = await getDnsRegistrarContract({\n          parentOwner,\n          provider\n        });\n        isNew = await registrarContract['supportsInterface(bytes4)'](dnssecClaimNewId);\n      }\n    } catch (e) {\n      console.log({\n        e\n      });\n    }\n\n    return {\n      registrarContract,\n      isOld\n    };\n  }\n\n  async getDNSEntry(name, parentOwner, owner) {\n    // Do not cache as it needs to be refetched on \"Refresh\"\n    const dnsRegistrar = {\n      stateError: null\n    };\n    const web3Provider = getLegacyProvider();\n    const provider = await getProvider();\n    const {\n      isOld,\n      registrarContract\n    } = await this.selectDnsRegistrarContract({\n      parentOwner,\n      provider\n    });\n    const oracleAddress = await registrarContract.oracle();\n    const registrarjs = new DNSRegistrarJS(web3Provider.givenProvider, oracleAddress, isOld);\n\n    try {\n      const claim = await registrarjs.claim(name);\n      const result = claim.getResult();\n      dnsRegistrar.claim = claim;\n      dnsRegistrar.result = result;\n\n      if (claim && claim.isFound) {\n        dnsRegistrar.dnsOwner = claim.getOwner();\n\n        if (!dnsRegistrar.dnsOwner || parseInt(dnsRegistrar.dnsOwner) === 0) {\n          // Empty\n          dnsRegistrar.state = 8;\n        } else if (!utils.isAddress(dnsRegistrar.dnsOwner)) {\n          // Invalid record\n          dnsRegistrar.state = 4;\n        } else if (!owner || dnsRegistrar.dnsOwner.toLowerCase() === owner.toLowerCase()) {\n          // Ready to register\n          dnsRegistrar.state = 5;\n        } else {\n          // Out of sync\n          dnsRegistrar.state = 6;\n        }\n      } else {\n        if (claim && claim.nsec) {\n          if (result.results.length === 4) {\n            // DNS entry does not exist\n            dnsRegistrar.state = 1;\n          } else if (result.results.length === 6) {\n            // DNS entry exists but _ens subdomain does not exist\n            dnsRegistrar.state = 3;\n          } else {\n            throw `DNSSEC results cannot be ${result.results.length}`;\n          }\n        } else {\n          // DNSSEC is not enabled\n          dnsRegistrar.state = 2;\n        }\n      }\n    } catch (e) {\n      console.log('Problem fetching data from DNS', e); // Problem fetching data from DNS\n\n      dnsRegistrar.stateError = e.message;\n      dnsRegistrar.state = 0;\n    }\n\n    return dnsRegistrar;\n  }\n\n  async submitProof(name, parentOwner) {\n    const provider = await getProvider();\n    const {\n      claim,\n      result\n    } = await this.getDNSEntry(name, parentOwner);\n    const owner = claim.getOwner();\n    const {\n      registrarContract: registrarWithoutSigner,\n      isOld\n    } = await this.selectDnsRegistrarContract({\n      parentOwner,\n      provider\n    });\n    const signer = await getSigner();\n    const user = await signer.getAddress();\n    const registrar = registrarWithoutSigner.connect(signer);\n    const proofData = await claim.getProofData();\n    const data = isOld ? proofData.data : proofData.rrsets;\n    const proof = proofData.proof;\n\n    if (data.length === 0) {\n      return registrar.claim(claim.encodedName, proof);\n    } else {\n      // Only available for the new DNSRegistrar\n      if (!isOld && owner === user) {\n        const resolverAddress = await this.getAddress('resolver.eth');\n        return registrar.proveAndClaimWithResolver(claim.encodedName, data, proof, resolverAddress, owner);\n      } else {\n        return registrar.proveAndClaim(claim.encodedName, data, proof);\n      }\n    }\n  }\n\n  async registerTestdomain(label) {\n    const provider = await getProvider();\n    const testAddress = await this.ENS.owner(namehash('test'));\n    const registrarWithoutSigner = getTestRegistrarContract({\n      address: testAddress,\n      provider\n    });\n    const signer = await getSigner();\n    const hash = labelhash(label);\n    const account = await getAccount();\n    const registrar = registrarWithoutSigner.connect(signer);\n    return registrar.register(hash, account);\n  }\n\n  async expiryTimes(label) {\n    const provider = await getProvider();\n    const testAddress = await this.ENS.owner(namehash('test'));\n    const TestRegistrar = await getTestRegistrarContract({\n      address: testAddress,\n      provider\n    });\n    const hash = labelhash(label);\n    const result = await TestRegistrar.expiryTimes(hash);\n\n    if (result > 0) {\n      return new Date(result * 1000);\n    }\n  }\n\n}\n\nasync function getEthResolver(ENS) {\n  const resolverAddr = await ENS.resolver(namehash('eth'));\n  const provider = await getProvider();\n  return getResolverContract({\n    address: resolverAddr,\n    provider\n  });\n}\n\nexport async function setupRegistrar(registryAddress) {\n  const provider = await getProvider();\n  const ENS = getENSContract({\n    address: registryAddress,\n    provider\n  });\n  const Resolver = await getEthResolver(ENS);\n  let ethAddress = await ENS.owner(namehash('eth'));\n  let controllerAddress = await Resolver.interfaceImplementer(namehash('eth'), permanentRegistrarInterfaceId);\n  let legacyAuctionRegistrarAddress = await Resolver.interfaceImplementer(namehash('eth'), legacyRegistrarInterfaceId);\n  let bulkRenewalAddress = await Resolver.interfaceImplementer(namehash('eth'), bulkRenewalInterfaceId);\n  return new Registrar({\n    registryAddress,\n    legacyAuctionRegistrarAddress,\n    ethAddress,\n    controllerAddress,\n    bulkRenewalAddress,\n    provider\n  });\n}","map":{"version":3,"sources":["/Users/karel/Documents/eth/my-eth-app/node_modules/@ensdomains/ui/src/registrar.js"],"names":["DNSRegistrarJS","getENSContract","getResolverContract","getPermanentRegistrarContract","getDnsRegistrarContract","getOldDnsRegistrarContract","getPermanentRegistrarControllerContract","getLegacyAuctionContract","getDeedContract","getTestRegistrarContract","getBulkRenewalContract","getAccount","getBlock","getProvider","getSigner","getNetworkId","getWeb3Read","getLegacyProvider","namehash","interfaces","isEncodedLabelhash","labelhash","utils","legacyRegistrar","legacyRegistrarInterfaceId","permanentRegistrar","permanentRegistrarInterfaceId","bulkRenewal","bulkRenewalInterfaceId","dnsRegistrar","dnsRegistrarInterfaceId","dnssecClaimOld","dnssecClaimOldId","dnssecClaimNew","dnssecClaimNewId","transferGasCost","checkArguments","registryAddress","ethAddress","legacyAuctionRegistrarAddress","provider","getBufferedPrice","price","mul","div","Registrar","constructor","controllerAddress","bulkRenewalAddress","address","permanentRegistrarController","legacyAuctionRegistrar","ENS","getAddress","name","hash","resolverAddr","resolver","Resolver","getDeed","getLegacyEntry","label","legacyEntry","deedOwner","entry","entries","parseInt","deed","owner","state","registrationDate","revealDate","value","highestBid","e","expiryTime","error","message","getPermanentEntry","RegistrarController","getAvailable","ret","available","nameExpires","labelHash","gracePeriod","Promise","all","getGracePeriod","Date","ownerOf","console","log","getEntry","block","permEntry","currentBlockDate","timestamp","registrant","transferEndDate","isNewRegistrar","gracePeriodEndDate","currentTime","getTime","GRACE_PERIOD","transferOwner","to","overrides","nameArray","split","account","signer","connect","networkId","gas","estimateGas","gasLimit","toNumber","reclaim","getRentPrice","duration","rentPrice","getRentPrices","labels","pricesArray","map","reduce","a","c","add","getMinimumCommitmentAge","minCommitmentAge","getMaximumCommitmentAge","maxCommitmentAge","makeCommitment","secret","permanentRegistrarControllerWithoutSigner","makeCommitmentWithConfig","checkCommitment","commitment","commitments","commit","register","priceWithBuffer","estimateGasLimit","registerWithConfig","cb","matched","match","renew","renewAll","bulkRenewalWithoutSigner","prices","pricesWithBuffer","releaseDeed","legacyAuctionRegistrarWithSigner","isDNSRegistrar","parentOwner","registrar","isDNSSECSupported","isOld","isNew","selectDnsRegistrarContract","registrarContract","getDNSEntry","stateError","web3Provider","oracleAddress","oracle","registrarjs","givenProvider","claim","result","getResult","isFound","dnsOwner","getOwner","isAddress","toLowerCase","nsec","results","length","submitProof","registrarWithoutSigner","user","proofData","getProofData","data","rrsets","proof","encodedName","resolverAddress","proveAndClaimWithResolver","proveAndClaim","registerTestdomain","testAddress","expiryTimes","TestRegistrar","getEthResolver","setupRegistrar","interfaceImplementer"],"mappings":"AACA,OAAOA,cAAP,MAA2B,gBAA3B;AACA,SACEC,cADF,EAEEC,mBAFF,EAGEC,6BAHF,EAIEC,uBAJF,EAKEC,0BALF,EAMEC,uCANF,EAOEC,wBAPF,EAQEC,eARF,EASEC,wBATF,EAUEC,sBAVF,QAWO,aAXP;AAaA,SACEC,UADF,EAEEC,QAFF,EAGEC,WAHF,EAIEC,SAJF,EAKEC,YALF,EAMEC,WANF,EAOEC,iBAPF,QAQO,QARP;AAUA,SAASC,QAAT,QAAyB,kBAAzB;AAEA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,kBAAT,EAA6BC,SAA7B,QAA8C,mBAA9C;AACA,SAASC,KAAT,QAAsB,QAAtB;AAEA,MAAM;AACJC,EAAAA,eAAe,EAAEC,0BADb;AAEJC,EAAAA,kBAAkB,EAAEC,6BAFhB;AAGJC,EAAAA,WAAW,EAAEC,sBAHT;AAIJC,EAAAA,YAAY,EAAEC,uBAJV;AAKJC,EAAAA,cAAc,EAACC,gBALX;AAMJC,EAAAA,cAAc,EAACC;AANX,IAOFf,UAPJ,C,CASA;;AACA,MAAMgB,eAAe,GAAG,KAAxB;;AAEA,SAASC,cAAT,OAKG;AAAA,MALqB;AACtBC,IAAAA,eADsB;AAEtBC,IAAAA,UAFsB;AAGtBC,IAAAA,6BAHsB;AAItBC,IAAAA;AAJsB,GAKrB;AACD,MAAI,CAACH,eAAL,EAAsB,MAAM,8CAAN;AAEtB,MAAI,CAACE,6BAAL,EACE,MAAM,oDAAN;AAEF,MAAI,CAACD,UAAL,EAAiB,MAAM,0CAAN;AAEjB,MAAI,CAACE,QAAL,EAAe,MAAM,oCAAN;AAEf;AACD,C,CAED;AACA;;;AACA,SAASC,gBAAT,CAA0BC,KAA1B,EAAgC;AAC9B,SAAOA,KAAK,CAACC,GAAN,CAAU,GAAV,EAAeC,GAAf,CAAmB,GAAnB,CAAP;AACD;;AAED,eAAe,MAAMC,SAAN,CAAgB;AAC7BC,EAAAA,WAAW,QAOR;AAAA,QAPS;AACVT,MAAAA,eADU;AAEVC,MAAAA,UAFU;AAGVC,MAAAA,6BAHU;AAIVQ,MAAAA,iBAJU;AAKVC,MAAAA,kBALU;AAMVR,MAAAA;AANU,KAOT;AACDJ,IAAAA,cAAc,CAAC;AACbC,MAAAA,eADa;AAEbC,MAAAA,UAFa;AAGbC,MAAAA,6BAHa;AAIbC,MAAAA;AAJa,KAAD,CAAd;AAOA,UAAMf,kBAAkB,GAAGtB,6BAA6B,CAAC;AACvD8C,MAAAA,OAAO,EAAEX,UAD8C;AAEvDE,MAAAA;AAFuD,KAAD,CAAxD;AAIA,UAAMU,4BAA4B,GAAG5C,uCAAuC,CAC1E;AAAE2C,MAAAA,OAAO,EAAEF,iBAAX;AAA8BP,MAAAA;AAA9B,KAD0E,CAA5E;AAIA,UAAMW,sBAAsB,GAAG5C,wBAAwB,CAAC;AACtD0C,MAAAA,OAAO,EAAEV,6BAD6C;AAEtDC,MAAAA;AAFsD,KAAD,CAAvD;AAKA,UAAMb,WAAW,GAAGjB,sBAAsB,CAAC;AACzCuC,MAAAA,OAAO,EAAED,kBADgC;AAEzCR,MAAAA;AAFyC,KAAD,CAA1C;AAKA,UAAMY,GAAG,GAAGnD,cAAc,CAAC;AAAEgD,MAAAA,OAAO,EAAEZ,eAAX;AAA4BG,MAAAA;AAA5B,KAAD,CAA1B;AAEA,SAAKf,kBAAL,GAA0BA,kBAA1B;AACA,SAAKyB,4BAAL,GAAoCA,4BAApC;AACA,SAAKC,sBAAL,GAA8BA,sBAA9B;AACA,SAAKd,eAAL,GAAuBA,eAAvB;AACA,SAAKV,WAAL,GAAmBA,WAAnB;AACA,SAAKyB,GAAL,GAAWA,GAAX;AACD;;AAEe,QAAVC,UAAU,CAACC,IAAD,EAAO;AACrB,UAAMd,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,UAAM0C,IAAI,GAAGrC,QAAQ,CAACoC,IAAD,CAArB;AACA,UAAME,YAAY,GAAG,MAAM,KAAKJ,GAAL,CAASK,QAAT,CAAkBF,IAAlB,CAA3B;AACA,UAAMG,QAAQ,GAAGxD,mBAAmB,CAAC;AAAE+C,MAAAA,OAAO,EAAEO,YAAX;AAAyBhB,MAAAA;AAAzB,KAAD,CAApC;AACA,WAAOkB,QAAQ,CAAC,eAAD,CAAR,CAA0BH,IAA1B,CAAP;AACD;;AAEY,QAAPI,OAAO,CAACV,OAAD,EAAU;AACrB,UAAMT,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,WAAOL,eAAe,CAAC;AAAEyC,MAAAA,OAAF;AAAWT,MAAAA;AAAX,KAAD,CAAtB;AACD;;AAEmB,QAAdoB,cAAc,CAACC,KAAD,EAAQ;AAC1B,QAAIC,WAAJ;;AACA,QAAI;AACF,YAAMjB,SAAS,GAAG,KAAKM,sBAAvB;AACA,UAAIY,SAAS,GAAG,KAAhB;AACA,YAAMC,KAAK,GAAG,MAAMnB,SAAS,CAACoB,OAAV,CAAkB5C,SAAS,CAACwC,KAAD,CAA3B,CAApB;;AACA,UAAIK,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAR,KAA2B,CAA/B,EAAkC;AAChC,cAAMG,IAAI,GAAG,MAAM,KAAKR,OAAL,CAAaK,KAAK,CAAC,CAAD,CAAlB,CAAnB;AACAD,QAAAA,SAAS,GAAG,MAAMI,IAAI,CAACC,KAAL,EAAlB;AACD;;AACDN,MAAAA,WAAW,GAAG;AACZC,QAAAA,SADY;AACD;AACXM,QAAAA,KAAK,EAAEH,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAFH;AAGZM,QAAAA,gBAAgB,EAAEJ,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAAR,GAAqB,IAH3B;AAIZO,QAAAA,UAAU,EAAE,CAACL,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAAR,GAAqB,KAAK,CAAL,GAAS,EAAT,GAAc,EAApC,IAA0C,IAJ1C;AAKZQ,QAAAA,KAAK,EAAEN,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CALH;AAMZS,QAAAA,UAAU,EAAEP,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN;AANR,OAAd;AAQD,KAhBD,CAgBE,OAAOU,CAAP,EAAU;AACVZ,MAAAA,WAAW,GAAG;AACZC,QAAAA,SAAS,EAAE,KADC;AAEZM,QAAAA,KAAK,EAAE,CAFK;AAGZC,QAAAA,gBAAgB,EAAE,CAHN;AAIZC,QAAAA,UAAU,EAAE,CAJA;AAKZC,QAAAA,KAAK,EAAE,CALK;AAMZC,QAAAA,UAAU,EAAE,CANA;AAOZE,QAAAA,UAAU,EAAE,CAPA;AAQZC,QAAAA,KAAK,EAAEF,CAAC,CAACG;AARG,OAAd;AAUD;;AACD,WAAOf,WAAP;AACD;;AAEsB,QAAjBgB,iBAAiB,CAACjB,KAAD,EAAQ;AAC7B,UAAM;AACJpC,MAAAA,kBAAkB,EAAEoB,SADhB;AAEJK,MAAAA,4BAA4B,EAAE6B;AAF1B,QAGF,IAHJ;AAKA,QAAIC,YAAJ;AACA,QAAIC,GAAG,GAAG;AACRC,MAAAA,SAAS,EAAE,IADH;AAERC,MAAAA,WAAW,EAAE;AAFL,KAAV;;AAIA,QAAI;AACF,YAAMC,SAAS,GAAG/D,SAAS,CAACwC,KAAD,CAA3B,CADE,CAGF;;AACA,UAAIzC,kBAAkB,CAACyC,KAAD,CAAtB,EAA+B;AAC7BmB,QAAAA,YAAY,GAAGnC,SAAS,CAACqC,SAAV,CAAoBE,SAApB,CAAf;AACD,OAFD,MAEO;AACLJ,QAAAA,YAAY,GAAGD,mBAAmB,CAACG,SAApB,CAA8BrB,KAA9B,CAAf;AACD;;AAED,YAAM,CAACqB,SAAD,EAAYC,WAAZ,EAAyBE,WAAzB,IAAwC,MAAMC,OAAO,CAACC,GAAR,CAAY,CAC9DP,YAD8D,EAE9DnC,SAAS,CAACsC,WAAV,CAAsBC,SAAtB,CAF8D,EAG9D,KAAKI,cAAL,CAAoB3C,SAApB,CAH8D,CAAZ,CAApD;AAMAoC,MAAAA,GAAG,GAAG,EACJ,GAAGA,GADC;AAEJC,QAAAA,SAFI;AAGJG,QAAAA,WAHI;AAIJF,QAAAA,WAAW,EAAEA,WAAW,GAAG,CAAd,GAAkB,IAAIM,IAAJ,CAASN,WAAW,GAAG,IAAvB,CAAlB,GAAiD;AAJ1D,OAAN,CAhBE,CAsBF;AACA;;AACAF,MAAAA,GAAG,CAACS,OAAJ,GAAc,MAAM7C,SAAS,CAAC6C,OAAV,CAAkBN,SAAlB,CAApB;AACD,KAzBD,CAyBE,OAAOV,CAAP,EAAU;AACViB,MAAAA,OAAO,CAACC,GAAR,CAAY,yCAAZ,EAAuDlB,CAAvD;AACA,aAAO,KAAP;AACD,KA5BD,SA4BU;AACR,aAAOO,GAAP;AACD;AACF;;AAEa,QAARY,QAAQ,CAAChC,KAAD,EAAQ;AACpB,QAAI,CAACiC,KAAD,EAAQhC,WAAR,EAAqBiC,SAArB,IAAkC,MAAMT,OAAO,CAACC,GAAR,CAAY,CACtD3E,QAAQ,EAD8C,EAEtD,KAAKgD,cAAL,CAAoBC,KAApB,CAFsD,EAGtD,KAAKiB,iBAAL,CAAuBjB,KAAvB,CAHsD,CAAZ,CAA5C;AAMA,QAAIoB,GAAG,GAAG;AACRe,MAAAA,gBAAgB,EAAE,IAAIP,IAAJ,CAASK,KAAK,CAACG,SAAN,GAAkB,IAA3B,CADV;AAERC,MAAAA,UAAU,EAAE,CAFJ;AAGRC,MAAAA,eAAe,EAAE,IAHT;AAIRC,MAAAA,cAAc,EAAE,KAJR;AAKRC,MAAAA,kBAAkB,EAAE;AALZ,KAAV;;AAQA,QAAIN,SAAJ,EAAe;AACbd,MAAAA,GAAG,CAACC,SAAJ,GAAgBa,SAAS,CAACb,SAA1B;;AACA,UAAIa,SAAS,CAACZ,WAAd,EAA2B;AACzBF,QAAAA,GAAG,CAACN,UAAJ,GAAiBoB,SAAS,CAACZ,WAA3B;AACD;;AACD,UAAIY,SAAS,CAACL,OAAd,EAAuB;AACrBT,QAAAA,GAAG,CAACiB,UAAJ,GAAiBH,SAAS,CAACL,OAA3B;AACAT,QAAAA,GAAG,CAACmB,cAAJ,GAAqB,IAArB;AACD,OAHD,MAGO,IAAIL,SAAS,CAACZ,WAAd,EAA2B;AAChC,cAAMmB,WAAW,GAAG,IAAIb,IAAJ,CAASR,GAAG,CAACe,gBAAb,CAApB;AACA,cAAMK,kBAAkB,GAAG,IAAIZ,IAAJ,CACzBM,SAAS,CAACZ,WAAV,CAAsBoB,OAAtB,KAAkCR,SAAS,CAACV,WAAV,GAAwB,IADjC,CAA3B,CAFgC,CAKhC;;AACA,YAAIU,SAAS,CAACZ,WAAV,GAAwBmB,WAAxB,GAAsCD,kBAA1C,EAA8D;AAC5DpB,UAAAA,GAAG,CAACmB,cAAJ,GAAqB,IAArB;AACAnB,UAAAA,GAAG,CAACoB,kBAAJ,GAAyBA,kBAAzB;AACD;AACF;AACF;;AAED,WAAO,EACL,GAAGvC,WADE;AAEL,SAAGmB;AAFE,KAAP;AAID;;AAEmB,QAAdO,cAAc,CAAC3C,SAAD,EAAY;AAC9B,QAAI,CAAC,KAAKwC,WAAV,EAAuB;AACrB,WAAKA,WAAL,GAAmB,MAAMxC,SAAS,CAAC2D,YAAV,EAAzB;AACA,aAAO,KAAKnB,WAAZ;AACD;;AACD,WAAO,KAAKA,WAAZ;AACD;;AAEkB,QAAboB,aAAa,CAACnD,IAAD,EAAOoD,EAAP,EAA2B;AAAA,QAAhBC,SAAgB,uEAAJ,EAAI;;AAC5C,QAAI;AACF,YAAMC,SAAS,GAAGtD,IAAI,CAACuD,KAAL,CAAW,GAAX,CAAlB;AACA,YAAMzB,SAAS,GAAG/D,SAAS,CAACuF,SAAS,CAAC,CAAD,CAAV,CAA3B;AACA,YAAME,OAAO,GAAG,MAAMnG,UAAU,EAAhC;AACA,YAAMc,kBAAkB,GAAG,KAAKA,kBAAhC;AACA,YAAMsF,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,YAAM+B,SAAS,GAAGpB,kBAAkB,CAACuF,OAAnB,CAA2BD,MAA3B,CAAlB;AACA,YAAME,SAAS,GAAG,MAAMlG,YAAY,EAApC;;AACA,UAAImD,QAAQ,CAAC+C,SAAD,CAAR,GAAsB,IAA1B,EAAgC;AAC9B;AACA,cAAMC,GAAG,GAAG,MAAMrE,SAAS,CAACsE,WAAV,CAAsB,2CAAtB,EAChBL,OADgB,EAEhBJ,EAFgB,EAGhBtB,SAHgB,CAAlB;AAKAuB,QAAAA,SAAS,GAAG,EACV,GAAGA,SADO;AAEVS,UAAAA,QAAQ,EAAEF,GAAG,CAACG,QAAJ,KAAiB;AAFjB,SAAZ;AAID;;AACD,aAAOxE,SAAS,CAAC,2CAAD,CAAT,CAAuDiE,OAAvD,EAAgEJ,EAAhE,EAAoEtB,SAApE,EAA+EuB,SAA/E,CAAP;AACD,KArBD,CAqBE,OAAOjC,CAAP,EAAU;AACViB,MAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ,EAA2ClB,CAA3C;AACD;AACF;;AAEY,QAAP4C,OAAO,CAAChE,IAAD,EAAOL,OAAP,EAAgC;AAAA,QAAhB0D,SAAgB,uEAAJ,EAAI;;AAC3C,QAAI;AACF,YAAMC,SAAS,GAAGtD,IAAI,CAACuD,KAAL,CAAW,GAAX,CAAlB;AACA,YAAMzB,SAAS,GAAG/D,SAAS,CAACuF,SAAS,CAAC,CAAD,CAAV,CAA3B;AACA,YAAMnF,kBAAkB,GAAG,KAAKA,kBAAhC;AACA,YAAMsF,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,YAAM+B,SAAS,GAAGpB,kBAAkB,CAACuF,OAAnB,CAA2BD,MAA3B,CAAlB;AACA,YAAME,SAAS,GAAG,MAAMlG,YAAY,EAApC;;AACA,UAAImD,QAAQ,CAAC+C,SAAD,CAAR,GAAsB,IAA1B,EAAgC;AAC9B;AACA,cAAMC,GAAG,GAAG,MAAMrE,SAAS,CAACsE,WAAV,CAAsBG,OAAtB,CAA8BlC,SAA9B,EAAyCnC,OAAzC,CAAlB;AAEA0D,QAAAA,SAAS,GAAG,EACV,GAAGA,SADO;AAEVS,UAAAA,QAAQ,EAAEF,GAAG,CAACG,QAAJ,KAAiB;AAFjB,SAAZ;AAID;;AAED,aAAOxE,SAAS,CAACyE,OAAV,CAAkBlC,SAAlB,EAA6BnC,OAA7B,EAAsC,EAC3C,GAAG0D;AADwC,OAAtC,CAAP;AAGD,KApBD,CAoBE,OAAOjC,CAAP,EAAU;AACViB,MAAAA,OAAO,CAACC,GAAR,CAAY,uBAAZ,EAAqClB,CAArC;AACD;AACF;;AAEiB,QAAZ6C,YAAY,CAACjE,IAAD,EAAOkE,QAAP,EAAiB;AACjC,UAAMtE,4BAA4B,GAAG,KAAKA,4BAA1C;AACA,QAAIR,KAAK,GAAG,MAAMQ,4BAA4B,CAACuE,SAA7B,CAAuCnE,IAAvC,EAA6CkE,QAA7C,CAAlB;AACA,WAAO9E,KAAP;AACD;;AAEkB,QAAbgF,aAAa,CAACC,MAAD,EAASH,QAAT,EAAmB;AACpC,UAAMI,WAAW,GAAG,MAAMtC,OAAO,CAACC,GAAR,CACxBoC,MAAM,CAACE,GAAP,CAAWhE,KAAK,IAAI;AAClB,aAAO,KAAK0D,YAAL,CAAkB1D,KAAlB,EAAyB2D,QAAzB,CAAP;AACD,KAFD,CADwB,CAA1B;AAKA,WAAOI,WAAW,CAACE,MAAZ,CAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,GAAF,CAAMD,CAAN,CAA7B,CAAP;AACD;;AAE4B,QAAvBE,uBAAuB,GAAG;AAC9B,UAAMhF,4BAA4B,GAAG,KAAKA,4BAA1C;AACA,WAAOA,4BAA4B,CAACiF,gBAA7B,EAAP;AACD;;AAE4B,QAAvBC,uBAAuB,GAAE;AAC7B,UAAMlF,4BAA4B,GAAG,KAAKA,4BAA1C;AACA,WAAQA,4BAA4B,CAACmF,gBAA7B,EAAR;AACD;;AAEmB,QAAdC,cAAc,CAAChF,IAAD,EAAOc,KAAP,EAA2B;AAAA,QAAbmE,MAAa,uEAAJ,EAAI;AAC7C,UAAMC,yCAAyC,GAAG,KAC/CtF,4BADH;AAEA,UAAM6D,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMoC,4BAA4B,GAAGsF,yCAAyC,CAACxB,OAA1C,CACnCD,MADmC,CAArC;AAGA,UAAMD,OAAO,GAAG,MAAMnG,UAAU,EAAhC;AACA,UAAM6C,YAAY,GAAG,MAAM,KAAKH,UAAL,CAAgB,cAAhB,CAA3B;;AACA,QAAIa,QAAQ,CAACV,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC;AACpC,aAAON,4BAA4B,CAACoF,cAA7B,CAA4ChF,IAA5C,EAAkDc,KAAlD,EAAyDmE,MAAzD,CAAP;AACD,KAFD,MAEO;AACL,aAAOrF,4BAA4B,CAACuF,wBAA7B,CACLnF,IADK,EAELc,KAFK,EAGLmE,MAHK,EAIL/E,YAJK,EAKLsD,OALK,CAAP;AAOD;AACF;;AAEoB,QAAf4B,eAAe,CAAC7E,KAAD,EAAqB;AAAA,QAAb0E,MAAa,uEAAJ,EAAI;AACxC,UAAMC,yCAAyC,GAAG,KAC/CtF,4BADH;AAEA,UAAM6D,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMoC,4BAA4B,GAAGsF,yCAAyC,CAACxB,OAA1C,CACnCD,MADmC,CAArC;AAGA,UAAMD,OAAO,GAAG,MAAMnG,UAAU,EAAhC;AACA,UAAMgI,UAAU,GAAG,MAAM,KAAKL,cAAL,CAAoBzE,KAApB,EAA2BiD,OAA3B,EAAoCyB,MAApC,CAAzB;AACA,WAAO,MAAMrF,4BAA4B,CAAC0F,WAA7B,CAAyCD,UAAzC,CAAb;AACD;;AAEW,QAANE,MAAM,CAAChF,KAAD,EAAqB;AAAA,QAAb0E,MAAa,uEAAJ,EAAI;AAC/B,UAAMC,yCAAyC,GAAG,KAC/CtF,4BADH;AAEA,UAAM6D,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMoC,4BAA4B,GAAGsF,yCAAyC,CAACxB,OAA1C,CACnCD,MADmC,CAArC;AAGA,UAAMD,OAAO,GAAG,MAAMnG,UAAU,EAAhC;AACA,UAAMgI,UAAU,GAAG,MAAM,KAAKL,cAAL,CAAoBzE,KAApB,EAA2BiD,OAA3B,EAAoCyB,MAApC,CAAzB;AAEA,WAAOrF,4BAA4B,CAAC2F,MAA7B,CAAoCF,UAApC,CAAP;AACD;;AAEa,QAARG,QAAQ,CAACjF,KAAD,EAAQ2D,QAAR,EAAkBe,MAAlB,EAA0B;AACtC,UAAMC,yCAAyC,GAAG,KAC/CtF,4BADH;AAEA,UAAM6D,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMoC,4BAA4B,GAAGsF,yCAAyC,CAACxB,OAA1C,CACnCD,MADmC,CAArC;AAGA,UAAMD,OAAO,GAAG,MAAMnG,UAAU,EAAhC;AACA,UAAM+B,KAAK,GAAG,MAAM,KAAK6E,YAAL,CAAkB1D,KAAlB,EAAyB2D,QAAzB,CAApB;AACA,UAAMuB,eAAe,GAAGtG,gBAAgB,CAACC,KAAD,CAAxC;AACA,UAAMc,YAAY,GAAG,MAAM,KAAKH,UAAL,CAAgB,cAAhB,CAA3B;;AACA,QAAIa,QAAQ,CAACV,YAAD,EAAe,EAAf,CAAR,KAA+B,CAAnC,EAAsC;AACpC,YAAM4D,QAAQ,GAAG,MAAM,KAAK4B,gBAAL,CAAsB,MAAM;AACjD,eAAO9F,4BAA4B,CAACiE,WAA7B,CAAyC2B,QAAzC,CACLjF,KADK,EAELiD,OAFK,EAGLU,QAHK,EAILe,MAJK,EAKL;AAAE/D,UAAAA,KAAK,EAACuE;AAAR,SALK,CAAP;AAOD,OARsB,CAAvB;AAUA,aAAO7F,4BAA4B,CAAC4F,QAA7B,CACLjF,KADK,EAELiD,OAFK,EAGLU,QAHK,EAILe,MAJK,EAKL;AAAE/D,QAAAA,KAAK,EAAEuE,eAAT;AAA0B3B,QAAAA;AAA1B,OALK,CAAP;AAOD,KAlBD,MAkBO;AACL,YAAMA,QAAQ,GAAG,MAAM,KAAK4B,gBAAL,CAAsB,MAAM;AACjD,eAAO9F,4BAA4B,CAACiE,WAA7B,CAAyC8B,kBAAzC,CACLpF,KADK,EAELiD,OAFK,EAGLU,QAHK,EAILe,MAJK,EAKL/E,YALK,EAMLsD,OANK,EAOL;AAAEtC,UAAAA,KAAK,EAACuE;AAAR,SAPK,CAAP;AASD,OAVsB,CAAvB;AAYA,aAAO7F,4BAA4B,CAAC+F,kBAA7B,CACLpF,KADK,EAELiD,OAFK,EAGLU,QAHK,EAILe,MAJK,EAKL/E,YALK,EAMLsD,OANK,EAOL;AAAEtC,QAAAA,KAAK,EAAEuE,eAAT;AAA0B3B,QAAAA;AAA1B,OAPK,CAAP;AASD;AACF;;AAEqB,QAAhB4B,gBAAgB,CAAEE,EAAF,EAAM;AAC1B,QAAIhC,GAAG,GAAG,CAAV;;AACA,QAAG;AACDA,MAAAA,GAAG,GAAG,CAAC,MAAMgC,EAAE,EAAT,EAAa7B,QAAb,EAAN;AACD,KAFD,CAEC,OAAM3C,CAAN,EAAQ;AACP,UAAIyE,OAAO,GAAGzE,CAAC,CAACG,OAAF,CAAUuE,KAAV,CAAgB,uBAAhB,KAA4C1E,CAAC,CAACG,OAAF,CAAUuE,KAAV,CAAgB,yCAAhB,CAA1D;;AACA,UAAGD,OAAH,EAAW;AACTjC,QAAAA,GAAG,GAAGhD,QAAQ,CAACiF,OAAO,CAAC,CAAD,CAAR,CAAd;AACD;;AACDxD,MAAAA,OAAO,CAACC,GAAR,CAAY;AAACsB,QAAAA,GAAD;AAAMxC,QAAAA,CAAN;AAASyE,QAAAA;AAAT,OAAZ;AACD;;AACD,QAAGjC,GAAG,GAAG,CAAT,EAAW;AACT,aAAOA,GAAG,GAAG/E,eAAb;AACD,KAFD,MAEK;AACH,aAAO+E,GAAP;AACD;AACF;;AAEU,QAALmC,KAAK,CAACxF,KAAD,EAAQ2D,QAAR,EAAkB;AAC3B,UAAMgB,yCAAyC,GAAG,KAC/CtF,4BADH;AAEA,UAAM6D,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMoC,4BAA4B,GAAGsF,yCAAyC,CAACxB,OAA1C,CACnCD,MADmC,CAArC;AAGA,UAAMrE,KAAK,GAAG,MAAM,KAAK6E,YAAL,CAAkB1D,KAAlB,EAAyB2D,QAAzB,CAApB;AACA,UAAMuB,eAAe,GAAGtG,gBAAgB,CAACC,KAAD,CAAxC;AACA,UAAM0E,QAAQ,GAAG,MAAM,KAAK4B,gBAAL,CAAsB,MAAM;AACjD,aAAO9F,4BAA4B,CAACiE,WAA7B,CAAyCkC,KAAzC,CAA+CxF,KAA/C,EAAsD2D,QAAtD,EAAgE;AAAEhD,QAAAA,KAAK,EAACuE;AAAR,OAAhE,CAAP;AACD,KAFsB,CAAvB;AAGA,WAAO7F,4BAA4B,CAACmG,KAA7B,CAAmCxF,KAAnC,EAA0C2D,QAA1C,EAAoD;AAAEhD,MAAAA,KAAK,EAAEuE,eAAT;AAA0B3B,MAAAA;AAA1B,KAApD,CAAP;AACD;;AAEa,QAARkC,QAAQ,CAAC3B,MAAD,EAASH,QAAT,EAAmB;AAC/B,UAAM+B,wBAAwB,GAAG,KAC9B5H,WADH;AAEA,UAAMoF,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMa,WAAW,GAAG4H,wBAAwB,CAACvC,OAAzB,CAClBD,MADkB,CAApB;AAGA,UAAMyC,MAAM,GAAG,MAAM,KAAK9B,aAAL,CAAmBC,MAAnB,EAA2BH,QAA3B,CAArB;AACA,UAAMiC,gBAAgB,GAAGhH,gBAAgB,CAAC+G,MAAD,CAAzC;AACA,UAAMpC,QAAQ,GAAG,MAAM,KAAK4B,gBAAL,CAAsB,MAAM;AACjD,aAAOrH,WAAW,CAACwF,WAAZ,CAAwBmC,QAAxB,CAAiC3B,MAAjC,EAAyCH,QAAzC,EAAmD;AAAEhD,QAAAA,KAAK,EAACiF;AAAR,OAAnD,CAAP;AACD,KAFsB,CAAvB;AAGA,WAAO9H,WAAW,CAAC2H,QAAZ,CACL3B,MADK,EAELH,QAFK,EAGL;AAAEhD,MAAAA,KAAK,EAAEiF,gBAAT;AAA2BrC,MAAAA;AAA3B,KAHK,CAAP;AAKD;;AAEgB,QAAXsC,WAAW,CAAC7F,KAAD,EAAQ;AACvB,UAAMV,sBAAsB,GAAG,KAAKA,sBAApC;AACA,UAAM4D,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAM6I,gCAAgC,GAAGxG,sBAAsB,CAAC6D,OAAvB,CACvCD,MADuC,CAAzC;AAGA,UAAMxD,IAAI,GAAGlC,SAAS,CAACwC,KAAD,CAAtB;AACA,WAAO8F,gCAAgC,CAACD,WAAjC,CAA6CnG,IAA7C,CAAP;AACD;;AAEmB,QAAdqG,cAAc,CAACC,WAAD,EAAc;AAChC,UAAMrH,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,UAAMiJ,SAAS,GAAG,MAAM1J,uBAAuB,CAAC;AAAEyJ,MAAAA,WAAF;AAAerH,MAAAA;AAAf,KAAD,CAA/C;AACA,QAAIuH,iBAAiB,GAAG,KAAxB;AAAA,QAA+BC,KAAK,GAAG,KAAvC;AAAA,QAA8CC,KAAK,GAAG,KAAtD;;AACA,QAAI;AACFD,MAAAA,KAAK,GAAG,MAAMF,SAAS,CAAC,2BAAD,CAAT,CAAuC9H,gBAAvC,CAAd;AACAiI,MAAAA,KAAK,GAAG,MAAMH,SAAS,CAAC,2BAAD,CAAT,CAAuC5H,gBAAvC,CAAd;AACD,KAHD,CAGE,OAAOwC,CAAP,EAAU;AACViB,MAAAA,OAAO,CAACC,GAAR,CAAY;AAAClB,QAAAA;AAAD,OAAZ;AACD;;AACDqF,IAAAA,iBAAiB,GAAGC,KAAK,IAAIC,KAA7B;AACA,WAAOF,iBAAP;AACD;;AAE+B,QAA1BG,0BAA0B,QAAyB;AAAA,QAAxB;AAACL,MAAAA,WAAD;AAAcrH,MAAAA;AAAd,KAAwB;AACvD,QAAI2H,iBAAiB,GAAG,MAAM9J,0BAA0B,CAAC;AAACwJ,MAAAA,WAAD;AAAcrH,MAAAA;AAAd,KAAD,CAAxD;AACA,QAAIwH,KAAK,GAAG,KAAZ;AAAA,QAAmBC,KAAK,GAAG,KAA3B;;AACA,QAAI;AACFD,MAAAA,KAAK,GAAG,MAAMG,iBAAiB,CAAC,2BAAD,CAAjB,CAA+CnI,gBAA/C,CAAd;;AACA,UAAG,CAACgI,KAAJ,EAAU;AACRG,QAAAA,iBAAiB,GAAG,MAAM/J,uBAAuB,CAAC;AAACyJ,UAAAA,WAAD;AAAcrH,UAAAA;AAAd,SAAD,CAAjD;AACAyH,QAAAA,KAAK,GAAG,MAAME,iBAAiB,CAAC,2BAAD,CAAjB,CAA+CjI,gBAA/C,CAAd;AACD;AACF,KAND,CAME,OAAOwC,CAAP,EAAU;AACViB,MAAAA,OAAO,CAACC,GAAR,CAAY;AAAClB,QAAAA;AAAD,OAAZ;AACD;;AACD,WAAO;AAACyF,MAAAA,iBAAD;AAAoBH,MAAAA;AAApB,KAAP;AACD;;AAEgB,QAAXI,WAAW,CAAC9G,IAAD,EAAOuG,WAAP,EAAoBzF,KAApB,EAA2B;AAC1C;AACA,UAAMvC,YAAY,GAAG;AAACwI,MAAAA,UAAU,EAAC;AAAZ,KAArB;AACA,UAAMC,YAAY,GAAGrJ,iBAAiB,EAAtC;AACA,UAAMuB,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,UAAM;AAAEmJ,MAAAA,KAAF;AAASG,MAAAA;AAAT,QAA+B,MAAM,KAAKD,0BAAL,CAAgC;AAACL,MAAAA,WAAD;AAAcrH,MAAAA;AAAd,KAAhC,CAA3C;AACA,UAAM+H,aAAa,GAAG,MAAMJ,iBAAiB,CAACK,MAAlB,EAA5B;AACA,UAAMC,WAAW,GAAG,IAAIzK,cAAJ,CAAmBsK,YAAY,CAACI,aAAhC,EAA+CH,aAA/C,EAA8DP,KAA9D,CAApB;;AACA,QAAI;AACF,YAAMW,KAAK,GAAG,MAAMF,WAAW,CAACE,KAAZ,CAAkBrH,IAAlB,CAApB;AACA,YAAMsH,MAAM,GAAGD,KAAK,CAACE,SAAN,EAAf;AACAhJ,MAAAA,YAAY,CAAC8I,KAAb,GAAqBA,KAArB;AACA9I,MAAAA,YAAY,CAAC+I,MAAb,GAAsBA,MAAtB;;AACA,UAAID,KAAK,IAAIA,KAAK,CAACG,OAAnB,EAA4B;AAC1BjJ,QAAAA,YAAY,CAACkJ,QAAb,GAAwBJ,KAAK,CAACK,QAAN,EAAxB;;AACA,YAAI,CAACnJ,YAAY,CAACkJ,QAAd,IAA0B7G,QAAQ,CAACrC,YAAY,CAACkJ,QAAd,CAAR,KAAoC,CAAlE,EAAqE;AACnE;AACAlJ,UAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD,SAHD,MAGO,IAAG,CAAC/C,KAAK,CAAC2J,SAAN,CAAgBpJ,YAAY,CAACkJ,QAA7B,CAAJ,EAA2C;AAChD;AACAlJ,UAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD,SAHM,MAGA,IACL,CAACD,KAAD,IAAUvC,YAAY,CAACkJ,QAAb,CAAsBG,WAAtB,OAAwC9G,KAAK,CAAC8G,WAAN,EAD7C,EAEL;AACA;AACArJ,UAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD,SALM,MAKA;AACL;AACAxC,UAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD;AACF,OAjBD,MAiBO;AACL,YAAIsG,KAAK,IAAIA,KAAK,CAACQ,IAAnB,EAAyB;AACvB,cAAIP,MAAM,CAACQ,OAAP,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B;AACAxJ,YAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD,WAHD,MAGO,IAAIuG,MAAM,CAACQ,OAAP,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AACtC;AACAxJ,YAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD,WAHM,MAGA;AACL,kBAAO,4BAA2BuG,MAAM,CAACQ,OAAP,CAAeC,MAAO,EAAxD;AACD;AACF,SAVD,MAUO;AACL;AACAxJ,UAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD;AACF;AACF,KAtCD,CAsCE,OAAOK,CAAP,EAAU;AACViB,MAAAA,OAAO,CAACC,GAAR,CAAY,gCAAZ,EAA8ClB,CAA9C,EADU,CAEV;;AACA7C,MAAAA,YAAY,CAACwI,UAAb,GAA0B3F,CAAC,CAACG,OAA5B;AACAhD,MAAAA,YAAY,CAACwC,KAAb,GAAqB,CAArB;AACD;;AACD,WAAOxC,YAAP;AACD;;AAEgB,QAAXyJ,WAAW,CAAChI,IAAD,EAAOuG,WAAP,EAAoB;AACnC,UAAMrH,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,UAAM;AAAE8J,MAAAA,KAAF;AAASC,MAAAA;AAAT,QAAoB,MAAM,KAAKR,WAAL,CAAiB9G,IAAjB,EAAuBuG,WAAvB,CAAhC;AACA,UAAMzF,KAAK,GAAGuG,KAAK,CAACK,QAAN,EAAd;AACA,UAAM;AAAEb,MAAAA,iBAAiB,EAACoB,sBAApB;AAA4CvB,MAAAA;AAA5C,QAAsD,MAAM,KAAKE,0BAAL,CAAgC;AAACL,MAAAA,WAAD;AAAcrH,MAAAA;AAAd,KAAhC,CAAlE;AAEA,UAAMuE,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAM0K,IAAI,GAAG,MAAMzE,MAAM,CAAC1D,UAAP,EAAnB;AACA,UAAMyG,SAAS,GAAGyB,sBAAsB,CAACvE,OAAvB,CAA+BD,MAA/B,CAAlB;AACA,UAAM0E,SAAS,GAAG,MAAMd,KAAK,CAACe,YAAN,EAAxB;AACA,UAAMC,IAAI,GAAG3B,KAAK,GAAGyB,SAAS,CAACE,IAAb,GAAoBF,SAAS,CAACG,MAAhD;AACA,UAAMC,KAAK,GAAGJ,SAAS,CAACI,KAAxB;;AAEA,QAAGF,IAAI,CAACN,MAAL,KAAgB,CAAnB,EAAqB;AACnB,aAAOvB,SAAS,CAACa,KAAV,CAAgBA,KAAK,CAACmB,WAAtB,EAAmCD,KAAnC,CAAP;AACD,KAFD,MAEK;AACH;AACA,UAAG,CAAC7B,KAAD,IAAW5F,KAAK,KAAKoH,IAAxB,EAA8B;AAC5B,cAAMO,eAAe,GAAG,MAAM,KAAK1I,UAAL,CAAgB,cAAhB,CAA9B;AACA,eAAOyG,SAAS,CAACkC,yBAAV,CAAoCrB,KAAK,CAACmB,WAA1C,EAAuDH,IAAvD,EAA6DE,KAA7D,EAAoEE,eAApE,EAAqF3H,KAArF,CAAP;AACD,OAHD,MAGK;AACH,eAAO0F,SAAS,CAACmC,aAAV,CAAwBtB,KAAK,CAACmB,WAA9B,EAA2CH,IAA3C,EAAiDE,KAAjD,CAAP;AACD;AACF;AACF;;AAEuB,QAAlBK,kBAAkB,CAACrI,KAAD,EAAQ;AAC9B,UAAMrB,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,UAAMsL,WAAW,GAAG,MAAM,KAAK/I,GAAL,CAASgB,KAAT,CAAelD,QAAQ,CAAC,MAAD,CAAvB,CAA1B;AACA,UAAMqK,sBAAsB,GAAG9K,wBAAwB,CAAC;AACtDwC,MAAAA,OAAO,EAAEkJ,WAD6C;AAEtD3J,MAAAA;AAFsD,KAAD,CAAvD;AAIA,UAAMuE,MAAM,GAAG,MAAMjG,SAAS,EAA9B;AACA,UAAMyC,IAAI,GAAGlC,SAAS,CAACwC,KAAD,CAAtB;AACA,UAAMiD,OAAO,GAAG,MAAMnG,UAAU,EAAhC;AACA,UAAMmJ,SAAS,GAAGyB,sBAAsB,CAACvE,OAAvB,CAA+BD,MAA/B,CAAlB;AACA,WAAO+C,SAAS,CAAChB,QAAV,CAAmBvF,IAAnB,EAAyBuD,OAAzB,CAAP;AACD;;AAEgB,QAAXsF,WAAW,CAACvI,KAAD,EAAQ;AACvB,UAAMrB,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,UAAMsL,WAAW,GAAG,MAAM,KAAK/I,GAAL,CAASgB,KAAT,CAAelD,QAAQ,CAAC,MAAD,CAAvB,CAA1B;AACA,UAAMmL,aAAa,GAAG,MAAM5L,wBAAwB,CAAC;AACnDwC,MAAAA,OAAO,EAAEkJ,WAD0C;AAEnD3J,MAAAA;AAFmD,KAAD,CAApD;AAIA,UAAMe,IAAI,GAAGlC,SAAS,CAACwC,KAAD,CAAtB;AACA,UAAM+G,MAAM,GAAG,MAAMyB,aAAa,CAACD,WAAd,CAA0B7I,IAA1B,CAArB;;AACA,QAAIqH,MAAM,GAAG,CAAb,EAAgB;AACd,aAAO,IAAInF,IAAJ,CAASmF,MAAM,GAAG,IAAlB,CAAP;AACD;AACF;;AAjjB4B;;AAojB/B,eAAe0B,cAAf,CAA8BlJ,GAA9B,EAAmC;AACjC,QAAMI,YAAY,GAAG,MAAMJ,GAAG,CAACK,QAAJ,CAAavC,QAAQ,CAAC,KAAD,CAArB,CAA3B;AACA,QAAMsB,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,SAAOX,mBAAmB,CAAC;AAAE+C,IAAAA,OAAO,EAAEO,YAAX;AAAyBhB,IAAAA;AAAzB,GAAD,CAA1B;AACD;;AAED,OAAO,eAAe+J,cAAf,CAA8BlK,eAA9B,EAA+C;AACpD,QAAMG,QAAQ,GAAG,MAAM3B,WAAW,EAAlC;AACA,QAAMuC,GAAG,GAAGnD,cAAc,CAAC;AAAEgD,IAAAA,OAAO,EAAEZ,eAAX;AAA4BG,IAAAA;AAA5B,GAAD,CAA1B;AACA,QAAMkB,QAAQ,GAAG,MAAM4I,cAAc,CAAClJ,GAAD,CAArC;AAEA,MAAId,UAAU,GAAG,MAAMc,GAAG,CAACgB,KAAJ,CAAUlD,QAAQ,CAAC,KAAD,CAAlB,CAAvB;AAEA,MAAI6B,iBAAiB,GAAG,MAAMW,QAAQ,CAAC8I,oBAAT,CAC5BtL,QAAQ,CAAC,KAAD,CADoB,EAE5BQ,6BAF4B,CAA9B;AAIA,MAAIa,6BAA6B,GAAG,MAAMmB,QAAQ,CAAC8I,oBAAT,CACxCtL,QAAQ,CAAC,KAAD,CADgC,EAExCM,0BAFwC,CAA1C;AAKA,MAAIwB,kBAAkB,GAAG,MAAMU,QAAQ,CAAC8I,oBAAT,CAC7BtL,QAAQ,CAAC,KAAD,CADqB,EAE7BU,sBAF6B,CAA/B;AAKA,SAAO,IAAIiB,SAAJ,CAAc;AACnBR,IAAAA,eADmB;AAEnBE,IAAAA,6BAFmB;AAGnBD,IAAAA,UAHmB;AAInBS,IAAAA,iBAJmB;AAKnBC,IAAAA,kBALmB;AAMnBR,IAAAA;AANmB,GAAd,CAAP;AAQD","sourcesContent":["\nimport DNSRegistrarJS from './dnsregistrar'\nimport {\n  getENSContract,\n  getResolverContract,\n  getPermanentRegistrarContract,\n  getDnsRegistrarContract,\n  getOldDnsRegistrarContract,\n  getPermanentRegistrarControllerContract,\n  getLegacyAuctionContract,\n  getDeedContract,\n  getTestRegistrarContract,\n  getBulkRenewalContract\n} from './contracts'\n\nimport {\n  getAccount,\n  getBlock,\n  getProvider,\n  getSigner,\n  getNetworkId,\n  getWeb3Read,\n  getLegacyProvider\n} from './web3'\n\nimport { namehash } from './utils/namehash'\n\nimport { interfaces } from './constants/interfaces'\nimport { isEncodedLabelhash, labelhash } from './utils/labelhash'\nimport { utils } from 'ethers'\n\nconst {\n  legacyRegistrar: legacyRegistrarInterfaceId,\n  permanentRegistrar: permanentRegistrarInterfaceId,\n  bulkRenewal: bulkRenewalInterfaceId,\n  dnsRegistrar: dnsRegistrarInterfaceId,\n  dnssecClaimOld:dnssecClaimOldId,\n  dnssecClaimNew:dnssecClaimNewId\n} = interfaces\n\n// Renewal seem failing as it's not correctly estimating gas to return when buffer exceeds the renewal cost\nconst transferGasCost = 21000\n\nfunction checkArguments({\n  registryAddress,\n  ethAddress,\n  legacyAuctionRegistrarAddress,\n  provider\n}) {\n  if (!registryAddress) throw 'No registry address given to Registrar class'\n\n  if (!legacyAuctionRegistrarAddress)\n    throw 'No legacy auction address given to Registrar class'\n\n  if (!ethAddress) throw 'No .eth address given to Registrar class'\n\n  if (!provider) throw 'Provider is required for Registrar'\n\n  return\n}\n\n// Add 10% buffer to handle price fructuation.\n// Any unused value will be sent back by the smart contract.\nfunction getBufferedPrice(price){\n  return price.mul(110).div(100)\n}\n\nexport default class Registrar {\n  constructor({\n    registryAddress,\n    ethAddress,\n    legacyAuctionRegistrarAddress,\n    controllerAddress,\n    bulkRenewalAddress,\n    provider\n  }) {\n    checkArguments({\n      registryAddress,\n      ethAddress,\n      legacyAuctionRegistrarAddress,\n      provider\n    })\n\n    const permanentRegistrar = getPermanentRegistrarContract({\n      address: ethAddress,\n      provider\n    })\n    const permanentRegistrarController = getPermanentRegistrarControllerContract(\n      { address: controllerAddress, provider }\n    )\n\n    const legacyAuctionRegistrar = getLegacyAuctionContract({\n      address: legacyAuctionRegistrarAddress,\n      provider\n    })\n\n    const bulkRenewal = getBulkRenewalContract({\n      address: bulkRenewalAddress,\n      provider\n    })\n\n    const ENS = getENSContract({ address: registryAddress, provider })\n\n    this.permanentRegistrar = permanentRegistrar\n    this.permanentRegistrarController = permanentRegistrarController\n    this.legacyAuctionRegistrar = legacyAuctionRegistrar\n    this.registryAddress = registryAddress\n    this.bulkRenewal = bulkRenewal\n    this.ENS = ENS\n  }\n\n  async getAddress(name) {\n    const provider = await getProvider()\n    const hash = namehash(name)\n    const resolverAddr = await this.ENS.resolver(hash)\n    const Resolver = getResolverContract({ address: resolverAddr, provider })\n    return Resolver['addr(bytes32)'](hash)\n  }\n\n  async getDeed(address) {\n    const provider = await getProvider()\n    return getDeedContract({ address, provider })\n  }\n\n  async getLegacyEntry(label) {\n    let legacyEntry\n    try {\n      const Registrar = this.legacyAuctionRegistrar\n      let deedOwner = '0x0'\n      const entry = await Registrar.entries(labelhash(label))\n      if (parseInt(entry[1], 16) !== 0) {\n        const deed = await this.getDeed(entry[1])\n        deedOwner = await deed.owner()\n      }\n      legacyEntry = {\n        deedOwner, // TODO: Display \"Release\" button if deedOwner is not 0x0\n        state: parseInt(entry[0]),\n        registrationDate: parseInt(entry[2]) * 1000,\n        revealDate: (parseInt(entry[2]) - 24 * 2 * 60 * 60) * 1000,\n        value: parseInt(entry[3]),\n        highestBid: parseInt(entry[4])\n      }\n    } catch (e) {\n      legacyEntry = {\n        deedOwner: '0x0',\n        state: 0,\n        registrationDate: 0,\n        revealDate: 0,\n        value: 0,\n        highestBid: 0,\n        expiryTime: 0,\n        error: e.message\n      }\n    }\n    return legacyEntry\n  }\n\n  async getPermanentEntry(label) {\n    const {\n      permanentRegistrar: Registrar,\n      permanentRegistrarController: RegistrarController\n    } = this\n\n    let getAvailable\n    let ret = {\n      available: null,\n      nameExpires: null\n    }\n    try {\n      const labelHash = labelhash(label)\n\n      // Returns true if name is available\n      if (isEncodedLabelhash(label)) {\n        getAvailable = Registrar.available(labelHash)\n      } else {\n        getAvailable = RegistrarController.available(label)\n      }\n\n      const [available, nameExpires, gracePeriod] = await Promise.all([\n        getAvailable,\n        Registrar.nameExpires(labelHash),\n        this.getGracePeriod(Registrar)\n      ])\n\n      ret = {\n        ...ret,\n        available,\n        gracePeriod,\n        nameExpires: nameExpires > 0 ? new Date(nameExpires * 1000) : null\n      }\n      // Returns registrar address if owned by new registrar.\n      // Keep it as a separate call as this will throw exception for non existing domains\n      ret.ownerOf = await Registrar.ownerOf(labelHash)\n    } catch (e) {\n      console.log('Error getting permanent registrar entry', e)\n      return false\n    } finally {\n      return ret\n    }\n  }\n\n  async getEntry(label) {\n    let [block, legacyEntry, permEntry] = await Promise.all([\n      getBlock(),\n      this.getLegacyEntry(label),\n      this.getPermanentEntry(label)\n    ])\n\n    let ret = {\n      currentBlockDate: new Date(block.timestamp * 1000),\n      registrant: 0,\n      transferEndDate: null,\n      isNewRegistrar: false,\n      gracePeriodEndDate: null\n    }\n\n    if (permEntry) {\n      ret.available = permEntry.available\n      if (permEntry.nameExpires) {\n        ret.expiryTime = permEntry.nameExpires\n      }\n      if (permEntry.ownerOf) {\n        ret.registrant = permEntry.ownerOf\n        ret.isNewRegistrar = true\n      } else if (permEntry.nameExpires) {\n        const currentTime = new Date(ret.currentBlockDate)\n        const gracePeriodEndDate = new Date(\n          permEntry.nameExpires.getTime() + permEntry.gracePeriod * 1000\n        )\n        // It is within grace period\n        if (permEntry.nameExpires < currentTime < gracePeriodEndDate) {\n          ret.isNewRegistrar = true\n          ret.gracePeriodEndDate = gracePeriodEndDate\n        }\n      }\n    }\n\n    return {\n      ...legacyEntry,\n      ...ret\n    }\n  }\n\n  async getGracePeriod(Registrar) {\n    if (!this.gracePeriod) {\n      this.gracePeriod = await Registrar.GRACE_PERIOD()\n      return this.gracePeriod\n    }\n    return this.gracePeriod\n  }\n\n  async transferOwner(name, to, overrides = {}) {\n    try {\n      const nameArray = name.split('.')\n      const labelHash = labelhash(nameArray[0])\n      const account = await getAccount()\n      const permanentRegistrar = this.permanentRegistrar\n      const signer = await getSigner()\n      const Registrar = permanentRegistrar.connect(signer)\n      const networkId = await getNetworkId()\n      if (parseInt(networkId) > 1000) {\n        /* if private network */\n        const gas = await Registrar.estimateGas[\"safeTransferFrom(address,address,uint256)\"](\n          account,\n          to,\n          labelHash\n        )\n        overrides = {\n          ...overrides,\n          gasLimit: gas.toNumber() * 2\n        }\n      }\n      return Registrar[\"safeTransferFrom(address,address,uint256)\"](account, to, labelHash, overrides)\n    } catch (e) {\n      console.log('Error calling transferOwner', e)\n    }\n  }\n\n  async reclaim(name, address, overrides = {}) {\n    try {\n      const nameArray = name.split('.')\n      const labelHash = labelhash(nameArray[0])\n      const permanentRegistrar = this.permanentRegistrar\n      const signer = await getSigner()\n      const Registrar = permanentRegistrar.connect(signer)\n      const networkId = await getNetworkId()\n      if (parseInt(networkId) > 1000) {\n        /* if private network */\n        const gas = await Registrar.estimateGas.reclaim(labelHash, address)\n\n        overrides = {\n          ...overrides,\n          gasLimit: gas.toNumber() * 2\n        }\n      }\n\n      return Registrar.reclaim(labelHash, address, {\n        ...overrides\n      })\n    } catch (e) {\n      console.log('Error calling reclaim', e)\n    }\n  }\n\n  async getRentPrice(name, duration) {\n    const permanentRegistrarController = this.permanentRegistrarController\n    let price = await permanentRegistrarController.rentPrice(name, duration)\n    return price\n  }\n\n  async getRentPrices(labels, duration) {\n    const pricesArray = await Promise.all(\n      labels.map(label => {\n        return this.getRentPrice(label, duration)\n      })\n    )\n    return pricesArray.reduce((a, c) => a.add(c))\n  }\n\n  async getMinimumCommitmentAge() {\n    const permanentRegistrarController = this.permanentRegistrarController\n    return permanentRegistrarController.minCommitmentAge()\n  }\n\n  async getMaximumCommitmentAge(){\n    const permanentRegistrarController = this.permanentRegistrarController\n    return  permanentRegistrarController.maxCommitmentAge()\n  }\n\n  async makeCommitment(name, owner, secret = '') {\n    const permanentRegistrarControllerWithoutSigner = this\n      .permanentRegistrarController\n    const signer = await getSigner()\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(\n      signer\n    )\n    const account = await getAccount()\n    const resolverAddr = await this.getAddress('resolver.eth')\n    if (parseInt(resolverAddr, 16) === 0) {\n      return permanentRegistrarController.makeCommitment(name, owner, secret)\n    } else {\n      return permanentRegistrarController.makeCommitmentWithConfig(\n        name,\n        owner,\n        secret,\n        resolverAddr,\n        account\n      )\n    }\n  }\n\n  async checkCommitment(label, secret = '') {\n    const permanentRegistrarControllerWithoutSigner = this\n      .permanentRegistrarController\n    const signer = await getSigner()\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(\n      signer\n    )\n    const account = await getAccount()\n    const commitment = await this.makeCommitment(label, account, secret)\n    return await permanentRegistrarController.commitments(commitment)\n  }\n\n  async commit(label, secret = '') {\n    const permanentRegistrarControllerWithoutSigner = this\n      .permanentRegistrarController\n    const signer = await getSigner()\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(\n      signer\n    )\n    const account = await getAccount()\n    const commitment = await this.makeCommitment(label, account, secret)\n\n    return permanentRegistrarController.commit(commitment)\n  }\n\n  async register(label, duration, secret) {\n    const permanentRegistrarControllerWithoutSigner = this\n      .permanentRegistrarController\n    const signer = await getSigner()\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(\n      signer\n    )\n    const account = await getAccount()\n    const price = await this.getRentPrice(label, duration)\n    const priceWithBuffer = getBufferedPrice(price)\n    const resolverAddr = await this.getAddress('resolver.eth')\n    if (parseInt(resolverAddr, 16) === 0) {\n      const gasLimit = await this.estimateGasLimit(() => {\n        return permanentRegistrarController.estimateGas.register(\n          label,\n          account,\n          duration,\n          secret,\n          { value:priceWithBuffer}\n        )\n      })\n  \n      return permanentRegistrarController.register(\n        label,\n        account,\n        duration,\n        secret,\n        { value: priceWithBuffer, gasLimit }\n      )\n    } else {\n      const gasLimit = await this.estimateGasLimit(() => {\n        return permanentRegistrarController.estimateGas.registerWithConfig(\n          label,\n          account,\n          duration,\n          secret,\n          resolverAddr,\n          account,\n          { value:priceWithBuffer}\n        )\n      })\n\n      return permanentRegistrarController.registerWithConfig(\n        label,\n        account,\n        duration,\n        secret,\n        resolverAddr,\n        account,\n        { value: priceWithBuffer, gasLimit }\n      )\n    }\n  }\n\n  async estimateGasLimit( cb ){\n    let gas = 0\n    try{\n      gas = (await cb()).toNumber()\n    }catch(e){\n      let matched = e.message.match(/\\(supplied gas (.*)\\)/) || e.message.match(/\\(gas required exceeds allowance (.*)\\)/)\n      if(matched){\n        gas = parseInt(matched[1])\n      }\n      console.log({gas, e, matched})\n    }\n    if(gas > 0){\n      return gas + transferGasCost\n    }else{\n      return gas\n    }\n  }\n\n  async renew(label, duration) {\n    const permanentRegistrarControllerWithoutSigner = this\n      .permanentRegistrarController\n    const signer = await getSigner()\n    const permanentRegistrarController = permanentRegistrarControllerWithoutSigner.connect(\n      signer\n    )\n    const price = await this.getRentPrice(label, duration)\n    const priceWithBuffer = getBufferedPrice(price)\n    const gasLimit = await this.estimateGasLimit(() => {\n      return permanentRegistrarController.estimateGas.renew(label, duration, { value:priceWithBuffer})\n    })\n    return permanentRegistrarController.renew(label, duration, { value: priceWithBuffer, gasLimit })\n  }\n\n  async renewAll(labels, duration) {\n    const bulkRenewalWithoutSigner = this\n      .bulkRenewal\n    const signer = await getSigner()\n    const bulkRenewal = bulkRenewalWithoutSigner.connect(\n      signer\n    )\n    const prices = await this.getRentPrices(labels, duration)\n    const pricesWithBuffer = getBufferedPrice(prices)\n    const gasLimit = await this.estimateGasLimit(() => {\n      return bulkRenewal.estimateGas.renewAll(labels, duration, { value:pricesWithBuffer})\n    })\n    return bulkRenewal.renewAll(\n      labels,\n      duration,\n      { value: pricesWithBuffer, gasLimit }\n    )\n  }\n\n  async releaseDeed(label) {\n    const legacyAuctionRegistrar = this.legacyAuctionRegistrar\n    const signer = await getSigner()\n    const legacyAuctionRegistrarWithSigner = legacyAuctionRegistrar.connect(\n      signer\n    )\n    const hash = labelhash(label)\n    return legacyAuctionRegistrarWithSigner.releaseDeed(hash)\n  }\n\n  async isDNSRegistrar(parentOwner) {\n    const provider = await getProvider()\n    const registrar = await getDnsRegistrarContract({ parentOwner, provider })\n    let isDNSSECSupported = false, isOld = false, isNew = false\n    try {\n      isOld = await registrar['supportsInterface(bytes4)'](dnssecClaimOldId)\n      isNew = await registrar['supportsInterface(bytes4)'](dnssecClaimNewId)\n    } catch (e) {\n      console.log({e})\n    }\n    isDNSSECSupported = isOld || isNew\n    return isDNSSECSupported\n  }\n\n  async selectDnsRegistrarContract({parentOwner, provider}){\n    let registrarContract = await getOldDnsRegistrarContract({parentOwner, provider})\n    let isOld = false, isNew = false\n    try {\n      isOld = await registrarContract['supportsInterface(bytes4)'](dnssecClaimOldId)\n      if(!isOld){\n        registrarContract = await getDnsRegistrarContract({parentOwner, provider})\n        isNew = await registrarContract['supportsInterface(bytes4)'](dnssecClaimNewId)\n      }\n    } catch (e) {\n      console.log({e})\n    }\n    return({registrarContract, isOld})\n  }\n\n  async getDNSEntry(name, parentOwner, owner) {\n    // Do not cache as it needs to be refetched on \"Refresh\"\n    const dnsRegistrar = {stateError:null}\n    const web3Provider = getLegacyProvider()\n    const provider = await getProvider()\n    const { isOld, registrarContract } = await this.selectDnsRegistrarContract({parentOwner, provider})\n    const oracleAddress = await registrarContract.oracle()\n    const registrarjs = new DNSRegistrarJS(web3Provider.givenProvider, oracleAddress, isOld)\n    try {\n      const claim = await registrarjs.claim(name)\n      const result = claim.getResult()\n      dnsRegistrar.claim = claim\n      dnsRegistrar.result = result\n      if (claim && claim.isFound) {\n        dnsRegistrar.dnsOwner = claim.getOwner()\n        if (!dnsRegistrar.dnsOwner || parseInt(dnsRegistrar.dnsOwner) === 0) {\n          // Empty\n          dnsRegistrar.state = 8\n        } else if(!utils.isAddress(dnsRegistrar.dnsOwner)){\n          // Invalid record\n          dnsRegistrar.state = 4\n        } else if (\n          !owner || dnsRegistrar.dnsOwner.toLowerCase() === owner.toLowerCase()\n        ) {\n          // Ready to register\n          dnsRegistrar.state = 5\n        } else {\n          // Out of sync\n          dnsRegistrar.state = 6\n        }\n      } else {\n        if (claim && claim.nsec) {\n          if (result.results.length === 4) {\n            // DNS entry does not exist\n            dnsRegistrar.state = 1\n          } else if (result.results.length === 6) {\n            // DNS entry exists but _ens subdomain does not exist\n            dnsRegistrar.state = 3\n          } else {\n            throw `DNSSEC results cannot be ${result.results.length}`\n          }\n        } else {\n          // DNSSEC is not enabled\n          dnsRegistrar.state = 2\n        }\n      }\n    } catch (e) {\n      console.log('Problem fetching data from DNS', e)\n      // Problem fetching data from DNS\n      dnsRegistrar.stateError = e.message\n      dnsRegistrar.state = 0\n    }\n    return dnsRegistrar\n  }\n\n  async submitProof(name, parentOwner) {\n    const provider = await getProvider()\n    const { claim, result } = await this.getDNSEntry(name, parentOwner)\n    const owner = claim.getOwner()\n    const { registrarContract:registrarWithoutSigner, isOld } = await this.selectDnsRegistrarContract({parentOwner, provider})\n\n    const signer = await getSigner()\n    const user = await signer.getAddress()\n    const registrar = registrarWithoutSigner.connect(signer)\n    const proofData = await claim.getProofData()\n    const data = isOld ? proofData.data : proofData.rrsets\n    const proof = proofData.proof\n    \n    if(data.length === 0){\n      return registrar.claim(claim.encodedName, proof)\n    }else{\n      // Only available for the new DNSRegistrar\n      if(!isOld && (owner === user)){\n        const resolverAddress = await this.getAddress('resolver.eth')\n        return registrar.proveAndClaimWithResolver(claim.encodedName, data, proof, resolverAddress, owner);\n      }else{\n        return registrar.proveAndClaim(claim.encodedName, data, proof)\n      }\n    }\n  }\n\n  async registerTestdomain(label) {\n    const provider = await getProvider()\n    const testAddress = await this.ENS.owner(namehash('test'))\n    const registrarWithoutSigner = getTestRegistrarContract({\n      address: testAddress,\n      provider\n    })\n    const signer = await getSigner()\n    const hash = labelhash(label)\n    const account = await getAccount()\n    const registrar = registrarWithoutSigner.connect(signer)\n    return registrar.register(hash, account)\n  }\n\n  async expiryTimes(label) {\n    const provider = await getProvider()\n    const testAddress = await this.ENS.owner(namehash('test'))\n    const TestRegistrar = await getTestRegistrarContract({\n      address: testAddress,\n      provider\n    })\n    const hash = labelhash(label)\n    const result = await TestRegistrar.expiryTimes(hash)\n    if (result > 0) {\n      return new Date(result * 1000)\n    }\n  }\n}\n\nasync function getEthResolver(ENS) {\n  const resolverAddr = await ENS.resolver(namehash('eth'))\n  const provider = await getProvider()\n  return getResolverContract({ address: resolverAddr, provider })\n}\n\nexport async function setupRegistrar(registryAddress) {\n  const provider = await getProvider()\n  const ENS = getENSContract({ address: registryAddress, provider })\n  const Resolver = await getEthResolver(ENS)\n\n  let ethAddress = await ENS.owner(namehash('eth'))\n\n  let controllerAddress = await Resolver.interfaceImplementer(\n    namehash('eth'),\n    permanentRegistrarInterfaceId\n  )\n  let legacyAuctionRegistrarAddress = await Resolver.interfaceImplementer(\n    namehash('eth'),\n    legacyRegistrarInterfaceId\n  )\n\n  let bulkRenewalAddress = await Resolver.interfaceImplementer(\n    namehash('eth'),\n    bulkRenewalInterfaceId\n  )\n\n  return new Registrar({\n    registryAddress,\n    legacyAuctionRegistrarAddress,\n    ethAddress,\n    controllerAddress,\n    bulkRenewalAddress,\n    provider\n  })\n}\n"]},"metadata":{},"sourceType":"module"}