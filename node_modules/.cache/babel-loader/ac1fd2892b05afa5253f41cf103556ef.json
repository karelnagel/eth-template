{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\n/**\n * Default configuration, can be used to initially set a different default configuration\n * on the CategoryServiceFactory. This will be applied to all categories already registered (or\n * registered in the future). Can also be applied to one Category (and childs).\n */\n\n\nvar CategoryConfiguration = function () {\n  /**\n   * Create a new instance\n   * @param logLevel Log level for all loggers, default is LogLevel.Error\n   * @param loggerType Where to log, default is LoggerType.Console\n   * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.\n   * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.\n   *            It is recommended to extend AbstractCategoryLogger to make your custom logger.\n   */\n  function CategoryConfiguration(logLevel, loggerType, logFormat, callBackLogger) {\n    if (logLevel === void 0) {\n      logLevel = LoggerOptions_1.LogLevel.Error;\n    }\n\n    if (loggerType === void 0) {\n      loggerType = LoggerOptions_1.LoggerType.Console;\n    }\n\n    if (logFormat === void 0) {\n      logFormat = new LoggerOptions_1.CategoryLogFormat();\n    }\n\n    if (callBackLogger === void 0) {\n      callBackLogger = null;\n    }\n\n    this._formatterLogMessage = null;\n    this._logLevel = logLevel;\n    this._loggerType = loggerType;\n    this._logFormat = logFormat;\n    this._callBackLogger = callBackLogger;\n\n    if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {\n      throw new Error(\"If you specify loggerType to be Custom, you must provide the callBackLogger argument\");\n    }\n  }\n\n  Object.defineProperty(CategoryConfiguration.prototype, \"logLevel\", {\n    get: function () {\n      return this._logLevel;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryConfiguration.prototype, \"loggerType\", {\n    get: function () {\n      return this._loggerType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryConfiguration.prototype, \"logFormat\", {\n    get: function () {\n      return this._logFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryConfiguration.prototype, \"callBackLogger\", {\n    get: function () {\n      return this._callBackLogger;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryConfiguration.prototype, \"formatterLogMessage\", {\n    /**\n     * Get the formatterLogMessage function, see comment on the setter.\n     * @returns {((message:CategoryLogMessage)=>string)|null}\n     */\n    get: function () {\n      return this._formatterLogMessage;\n    },\n\n    /**\n     * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.\n     * By default this is null (not set). You can assign a function to allow custom formatting of a log message.\n     * Each log message will call this function then and expects your function to format the message and return a string.\n     * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.\n     * @param value The formatter function, or null to reset it.\n     */\n    set: function (value) {\n      if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {\n        throw new Error(\"You cannot specify a formatter for log messages if your loggerType is Custom\");\n      }\n\n      this._formatterLogMessage = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CategoryConfiguration.prototype.copy = function () {\n    var config = new CategoryConfiguration(this.logLevel, this.loggerType, this.logFormat.copy(), this.callBackLogger);\n    config.formatterLogMessage = this.formatterLogMessage;\n    return config;\n  };\n\n  return CategoryConfiguration;\n}();\n\nexports.CategoryConfiguration = CategoryConfiguration;","map":{"version":3,"sources":["../../../../src/logging/log/category/CategoryConfiguration.ts"],"names":[],"mappings":";;;;;;AAGA,IAAA,eAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAGA;;;;AAIG;;;AACH,IAAA,qBAAA,GAAA,YAAA;AASE;;;;;;;AAOG;AACH,WAAA,qBAAA,CAAY,QAAZ,EAAiD,UAAjD,EACY,SADZ,EAEY,cAFZ,EAEwH;AAF5G,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAqB,eAAA,CAAA,QAAA,CAAS,KAA9B;AAAmC;;AAAE,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAyB,eAAA,CAAA,UAAA,CAAW,OAApC;AAA2C;;AAChF,QAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,SAAA,GAAA,IAAmC,eAAA,CAAA,iBAAnC,EAAA;AAAsD;;AACtD,QAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,cAAA,GAAA,IAAA;AAA4G;;AAZhH,SAAA,oBAAA,GAAyE,IAAzE;AAaN,SAAK,SAAL,GAAiB,QAAjB;AACA,SAAK,WAAL,GAAmB,UAAnB;AACA,SAAK,UAAL,GAAkB,SAAlB;AACA,SAAK,eAAL,GAAuB,cAAvB;;AAEA,QAAI,KAAK,WAAL,KAAqB,eAAA,CAAA,UAAA,CAAW,MAAhC,IAA0C,KAAK,cAAL,KAAwB,IAAtE,EAA4E;AAC1E,YAAM,IAAI,KAAJ,CAAU,sFAAV,CAAN;AACD;AACF;;AAED,EAAA,MAAA,CAAA,cAAA,CAAI,qBAAA,CAAA,SAAJ,EAAI,UAAJ,EAAY;SAAZ,YAAA;AACE,aAAO,KAAK,SAAZ;AACD,KAFW;oBAAA;;AAAA,GAAZ;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,qBAAA,CAAA,SAAJ,EAAI,YAAJ,EAAc;SAAd,YAAA;AACE,aAAO,KAAK,WAAZ;AACD,KAFa;oBAAA;;AAAA,GAAd;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,qBAAA,CAAA,SAAJ,EAAI,WAAJ,EAAa;SAAb,YAAA;AACE,aAAO,KAAK,UAAZ;AACD,KAFY;oBAAA;;AAAA,GAAb;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,qBAAA,CAAA,SAAJ,EAAI,gBAAJ,EAAkB;SAAlB,YAAA;AACE,aAAO,KAAK,eAAZ;AACD,KAFiB;oBAAA;;AAAA,GAAlB;AAQA,EAAA,MAAA,CAAA,cAAA,CAAI,qBAAA,CAAA,SAAJ,EAAI,qBAAJ,EAAuB;AAJvB;;;AAGG;SACH,YAAA;AACE,aAAO,KAAK,oBAAZ;AACD,KAFsB;;AAIvB;;;;;;AAMG;SACH,UAAwB,KAAxB,EAA+E;AAC7E,UAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,WAAL,KAAqB,eAAA,CAAA,UAAA,CAAW,MAAtD,EAA8D;AAC5D,cAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACD;;AACD,WAAK,oBAAL,GAA4B,KAA5B;AACD,KAhBsB;oBAAA;;AAAA,GAAvB;;AAkBO,EAAA,qBAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AACE,QAAM,MAAM,GAAG,IAAI,qBAAJ,CAA0B,KAAK,QAA/B,EAAyC,KAAK,UAA9C,EAA0D,KAAK,SAAL,CAAe,IAAf,EAA1D,EAAiF,KAAK,cAAtF,CAAf;AACA,IAAA,MAAM,CAAC,mBAAP,GAA6B,KAAK,mBAAlC;AACA,WAAO,MAAP;AACD,GAJM;;AAKT,SAAA,qBAAA;AAAC,CAzED,EAAA;;AAAa,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\n/**\n * Default configuration, can be used to initially set a different default configuration\n * on the CategoryServiceFactory. This will be applied to all categories already registered (or\n * registered in the future). Can also be applied to one Category (and childs).\n */\nvar CategoryConfiguration = (function () {\n    /**\n     * Create a new instance\n     * @param logLevel Log level for all loggers, default is LogLevel.Error\n     * @param loggerType Where to log, default is LoggerType.Console\n     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.\n     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.\n     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.\n     */\n    function CategoryConfiguration(logLevel, loggerType, logFormat, callBackLogger) {\n        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }\n        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }\n        if (callBackLogger === void 0) { callBackLogger = null; }\n        this._formatterLogMessage = null;\n        this._logLevel = logLevel;\n        this._loggerType = loggerType;\n        this._logFormat = logFormat;\n        this._callBackLogger = callBackLogger;\n        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {\n            throw new Error(\"If you specify loggerType to be Custom, you must provide the callBackLogger argument\");\n        }\n    }\n    Object.defineProperty(CategoryConfiguration.prototype, \"logLevel\", {\n        get: function () {\n            return this._logLevel;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryConfiguration.prototype, \"loggerType\", {\n        get: function () {\n            return this._loggerType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryConfiguration.prototype, \"logFormat\", {\n        get: function () {\n            return this._logFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryConfiguration.prototype, \"callBackLogger\", {\n        get: function () {\n            return this._callBackLogger;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryConfiguration.prototype, \"formatterLogMessage\", {\n        /**\n         * Get the formatterLogMessage function, see comment on the setter.\n         * @returns {((message:CategoryLogMessage)=>string)|null}\n         */\n        get: function () {\n            return this._formatterLogMessage;\n        },\n        /**\n         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.\n         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.\n         * Each log message will call this function then and expects your function to format the message and return a string.\n         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.\n         * @param value The formatter function, or null to reset it.\n         */\n        set: function (value) {\n            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {\n                throw new Error(\"You cannot specify a formatter for log messages if your loggerType is Custom\");\n            }\n            this._formatterLogMessage = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CategoryConfiguration.prototype.copy = function () {\n        var config = new CategoryConfiguration(this.logLevel, this.loggerType, this.logFormat.copy(), this.callBackLogger);\n        config.formatterLogMessage = this.formatterLogMessage;\n        return config;\n    };\n    return CategoryConfiguration;\n}());\nexports.CategoryConfiguration = CategoryConfiguration;\n//# sourceMappingURL=CategoryConfiguration.js.map"]},"metadata":{},"sourceType":"script"}