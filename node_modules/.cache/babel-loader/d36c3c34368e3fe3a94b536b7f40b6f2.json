{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\n/**\n * Defines a LogGroupRule, this allows you to either have everything configured the same way\n * or for example loggers that start with name model. It allows you to group loggers together\n * to have a certain loglevel and other settings. You can configure this when creating the\n * LoggerFactory (which accepts multiple LogGroupRules).\n */\n\n\nvar LogGroupRule = function () {\n  /**\n   * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)\n   * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.\n   * @param regExp Regular expression, what matches for your logger names for this group\n   * @param level LogLevel\n   * @param logFormat LogFormat\n   * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.\n   * @param callBackLogger Callback function to return a new clean custom logger (yours!)\n   */\n  function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {\n    if (logFormat === void 0) {\n      logFormat = new LoggerOptions_1.LogFormat();\n    }\n\n    if (loggerType === void 0) {\n      loggerType = LoggerOptions_1.LoggerType.Console;\n    }\n\n    if (callBackLogger === void 0) {\n      callBackLogger = null;\n    }\n\n    this._formatterLogMessage = null;\n    this._regExp = regExp;\n    this._level = level;\n    this._logFormat = logFormat;\n    this._loggerType = loggerType;\n    this._callBackLogger = callBackLogger;\n  }\n\n  Object.defineProperty(LogGroupRule.prototype, \"regExp\", {\n    get: function () {\n      return this._regExp;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LogGroupRule.prototype, \"level\", {\n    get: function () {\n      return this._level;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LogGroupRule.prototype, \"loggerType\", {\n    get: function () {\n      return this._loggerType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LogGroupRule.prototype, \"logFormat\", {\n    get: function () {\n      return this._logFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LogGroupRule.prototype, \"callBackLogger\", {\n    get: function () {\n      return this._callBackLogger;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LogGroupRule.prototype, \"formatterLogMessage\", {\n    /**\n     * Get the formatterLogMessage function, see comment on the setter.\n     * @returns {((message:LogMessage)=>string)|null}\n     */\n    get: function () {\n      return this._formatterLogMessage;\n    },\n\n    /**\n     * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.\n     * By default this is null (not set). You can assign a function to allow custom formatting of a log message.\n     * Each log message will call this function then and expects your function to format the message and return a string.\n     * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.\n     * @param value The formatter function, or null to reset it.\n     */\n    set: function (value) {\n      if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {\n        throw new Error(\"You cannot specify a formatter for log messages if your loggerType is Custom\");\n      }\n\n      this._formatterLogMessage = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LogGroupRule;\n}();\n\nexports.LogGroupRule = LogGroupRule;","map":{"version":3,"sources":["../../../../src/logging/log/standard/LogGroupRule.ts"],"names":[],"mappings":";;;;;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAIA;;;;;AAKG;;;AACH,IAAA,YAAA,GAAA,YAAA;AASE;;;;;;;;AAQG;AACH,WAAA,YAAA,CAAY,MAAZ,EAA4B,KAA5B,EAA6C,SAA7C,EACY,UADZ,EAEY,cAFZ,EAEuG;AAF1D,QAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,SAAA,GAAA,IAA2B,eAAA,CAAA,SAA3B,EAAA;AAAsC;;AACvE,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAyB,eAAA,CAAA,UAAA,CAAW,OAApC;AAA2C;;AAC3C,QAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,cAAA,GAAA,IAAA;AAA2F;;AAb/F,SAAA,oBAAA,GAAiE,IAAjE;AAcN,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,UAAL,GAAkB,SAAlB;AACA,SAAK,WAAL,GAAmB,UAAnB;AACA,SAAK,eAAL,GAAuB,cAAvB;AACD;;AAED,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,QAAJ,EAAU;SAAV,YAAA;AACE,aAAO,KAAK,OAAZ;AACD,KAFS;oBAAA;;AAAA,GAAV;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;SAAT,YAAA;AACE,aAAO,KAAK,MAAZ;AACD,KAFQ;oBAAA;;AAAA,GAAT;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,YAAJ,EAAc;SAAd,YAAA;AACE,aAAO,KAAK,WAAZ;AACD,KAFa;oBAAA;;AAAA,GAAd;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,WAAJ,EAAa;SAAb,YAAA;AACE,aAAO,KAAK,UAAZ;AACD,KAFY;oBAAA;;AAAA,GAAb;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,gBAAJ,EAAkB;SAAlB,YAAA;AACE,aAAO,KAAK,eAAZ;AACD,KAFiB;oBAAA;;AAAA,GAAlB;AAQA,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,qBAAJ,EAAuB;AAJvB;;;AAGG;SACH,YAAA;AACE,aAAO,KAAK,oBAAZ;AACD,KAFsB;;AAIvB;;;;;;AAMG;SACH,UAAwB,KAAxB,EAAuE;AACrE,UAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,WAAL,KAAqB,eAAA,CAAA,UAAA,CAAW,MAAtD,EAA8D;AAC5D,cAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACD;;AACD,WAAK,oBAAL,GAA4B,KAA5B;AACD,KAhBsB;oBAAA;;AAAA,GAAvB;AAiBF,SAAA,YAAA;AAAC,CArED,EAAA;;AAAa,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\n/**\n * Defines a LogGroupRule, this allows you to either have everything configured the same way\n * or for example loggers that start with name model. It allows you to group loggers together\n * to have a certain loglevel and other settings. You can configure this when creating the\n * LoggerFactory (which accepts multiple LogGroupRules).\n */\nvar LogGroupRule = (function () {\n    /**\n     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)\n     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.\n     * @param regExp Regular expression, what matches for your logger names for this group\n     * @param level LogLevel\n     * @param logFormat LogFormat\n     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.\n     * @param callBackLogger Callback function to return a new clean custom logger (yours!)\n     */\n    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {\n        if (logFormat === void 0) { logFormat = new LoggerOptions_1.LogFormat(); }\n        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n        if (callBackLogger === void 0) { callBackLogger = null; }\n        this._formatterLogMessage = null;\n        this._regExp = regExp;\n        this._level = level;\n        this._logFormat = logFormat;\n        this._loggerType = loggerType;\n        this._callBackLogger = callBackLogger;\n    }\n    Object.defineProperty(LogGroupRule.prototype, \"regExp\", {\n        get: function () {\n            return this._regExp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"level\", {\n        get: function () {\n            return this._level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"loggerType\", {\n        get: function () {\n            return this._loggerType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"logFormat\", {\n        get: function () {\n            return this._logFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"callBackLogger\", {\n        get: function () {\n            return this._callBackLogger;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"formatterLogMessage\", {\n        /**\n         * Get the formatterLogMessage function, see comment on the setter.\n         * @returns {((message:LogMessage)=>string)|null}\n         */\n        get: function () {\n            return this._formatterLogMessage;\n        },\n        /**\n         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.\n         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.\n         * Each log message will call this function then and expects your function to format the message and return a string.\n         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.\n         * @param value The formatter function, or null to reset it.\n         */\n        set: function (value) {\n            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {\n                throw new Error(\"You cannot specify a formatter for log messages if your loggerType is Custom\");\n            }\n            this._formatterLogMessage = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LogGroupRule;\n}());\nexports.LogGroupRule = LogGroupRule;\n//# sourceMappingURL=LogGroupRule.js.map"]},"metadata":{},"sourceType":"script"}