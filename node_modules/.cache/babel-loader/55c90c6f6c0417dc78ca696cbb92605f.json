{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DataStructures_1 = require(\"../../utils/DataStructures\");\n\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\n\nvar LoggerFactoryImpl_1 = require(\"./LoggerFactoryImpl\");\n\nvar ExtensionHelper_1 = require(\"../../extension/ExtensionHelper\");\n\nvar LogGroupRule_1 = require(\"./LogGroupRule\");\n\nvar LoggerFactoryOptions_1 = require(\"./LoggerFactoryOptions\");\n\nvar LFServiceImpl = function () {\n  function LFServiceImpl() {\n    // Private constructor.\n    this._nameCounter = 1;\n    this._mapFactories = new DataStructures_1.SimpleMap();\n    ExtensionHelper_1.ExtensionHelper.register();\n  }\n\n  LFServiceImpl.getInstance = function () {\n    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.\n    if (LFServiceImpl._INSTANCE === null) {\n      LFServiceImpl._INSTANCE = new LFServiceImpl();\n    }\n\n    return LFServiceImpl._INSTANCE;\n  };\n  /**\n   * Create a new LoggerFactory with given options (if any). If no options\n   * are specified, the LoggerFactory, will accept any named logger and will\n   * log on info level by default for, to the console.\n   * @param options Options, optional.\n   * @returns {LoggerFactory}\n   */\n\n\n  LFServiceImpl.prototype.createLoggerFactory = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    var name = \"LoggerFactory\" + this._nameCounter++;\n    return this.createNamedLoggerFactory(name, options);\n  };\n  /**\n   * Create a new LoggerFactory using given name (used for console api/extension).\n   * @param name Name Pick something short but distinguishable.\n   * @param options Options, optional\n   * @return {LoggerFactory}\n   */\n\n\n  LFServiceImpl.prototype.createNamedLoggerFactory = function (name, options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (this._mapFactories.exists(name)) {\n      throw new Error(\"LoggerFactory with name \" + name + \" already exists.\");\n    }\n\n    var factory;\n\n    if (options !== null) {\n      factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, options);\n    } else {\n      factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, LFServiceImpl.createDefaultOptions());\n    }\n\n    this._mapFactories.put(name, factory);\n\n    return factory;\n  };\n  /**\n   * Closes all Loggers for LoggerFactories that were created.\n   * After this call, all previously fetched Loggers (from their\n   * factories) are unusable. The factories remain as they were.\n   */\n\n\n  LFServiceImpl.prototype.closeLoggers = function () {\n    this._mapFactories.values().forEach(function (factory) {\n      factory.closeLoggers();\n    });\n\n    this._mapFactories.clear();\n\n    this._nameCounter = 1;\n  };\n\n  LFServiceImpl.prototype.getRuntimeSettingsForLoggerFactories = function () {\n    var result = [];\n\n    this._mapFactories.forEachValue(function (factory) {\n      return result.push(factory);\n    });\n\n    return result;\n  };\n\n  LFServiceImpl.prototype.getLogGroupSettings = function (nameLoggerFactory, idLogGroupRule) {\n    var factory = this._mapFactories.get(nameLoggerFactory);\n\n    if (typeof factory === \"undefined\") {\n      return null;\n    }\n\n    return factory.getLogGroupRuntimeSettingsByIndex(idLogGroupRule);\n  };\n\n  LFServiceImpl.prototype.getLoggerFactoryRuntimeSettingsByName = function (nameLoggerFactory) {\n    var result = this._mapFactories.get(nameLoggerFactory);\n\n    if (typeof result === \"undefined\") {\n      return null;\n    }\n\n    return result;\n  };\n\n  LFServiceImpl.createDefaultOptions = function () {\n    return new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(\".+\"), LoggerOptions_1.LogLevel.Info));\n  }; // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.\n\n\n  LFServiceImpl._INSTANCE = null;\n  return LFServiceImpl;\n}();\n/**\n * Create and configure your LoggerFactory from here.\n */\n\n\nvar LFService = function () {\n  function LFService() {}\n  /**\n   * Create a new LoggerFactory with given options (if any). If no options\n   * are specified, the LoggerFactory, will accept any named logger and will\n   * log on info level by default for, to the console.\n   * @param options Options, optional.\n   * @returns {LoggerFactory}\n   */\n\n\n  LFService.createLoggerFactory = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    return LFService.INSTANCE_SERVICE.createLoggerFactory(options);\n  };\n  /**\n   * Create a new LoggerFactory using given name (used for console api/extension).\n   * @param name Name Pick something short but distinguishable. The word \"DEFAULT\" is reserved and cannot be taken, it is used\n   * for the default LoggerFactory.\n   * @param options Options, optional\n   * @return {LoggerFactory}\n   */\n\n\n  LFService.createNamedLoggerFactory = function (name, options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (name === LFService.DEFAULT_LOGGER_FACTORY_NAME) {\n      throw new Error(\"LoggerFactory name: \" + LFService.DEFAULT_LOGGER_FACTORY_NAME + \" is reserved and cannot be used.\");\n    }\n\n    return LFService.INSTANCE_SERVICE.createNamedLoggerFactory(name, options);\n  };\n  /**\n   * Closes all Loggers for LoggerFactories that were created.\n   * After this call, all previously fetched Loggers (from their\n   * factories) are unusable. The factories remain as they were.\n   */\n\n\n  LFService.closeLoggers = function () {\n    return LFService.INSTANCE_SERVICE.closeLoggers();\n  };\n  /**\n   * Return LFServiceRuntimeSettings to retrieve information loggerfactories\n   * and their runtime settings.\n   * @returns {LFServiceRuntimeSettings}\n   */\n\n\n  LFService.getRuntimeSettings = function () {\n    return LFService.INSTANCE_SERVICE;\n  };\n\n  Object.defineProperty(LFService, \"DEFAULT\", {\n    /**\n     * This property returns the default LoggerFactory (if not yet initialized it is initialized).\n     * This LoggerFactory can be used to share among multiple\n     * applications/libraries - that way you can enable/change logging over everything from\n     * your own application when required.\n     * It is recommended to be used by library developers to make logging easily available for the\n     * consumers of their libraries.\n     * It is highly recommended to use Loggers from the LoggerFactory with unique grouping/names to prevent\n     * clashes of Loggers between multiple projects.\n     * @returns {LoggerFactory} Returns the default LoggerFactory\n     */\n    get: function () {\n      return LFService.getDefault();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  LFService.getDefault = function () {\n    if (LFService.DEFAULT_LOGGER_FACTORY === null) {\n      LFService.DEFAULT_LOGGER_FACTORY = LFService.DEFAULT_LOGGER_FACTORY = LFService.INSTANCE_SERVICE.createNamedLoggerFactory(LFService.DEFAULT_LOGGER_FACTORY_NAME, new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(\".+\"), LoggerOptions_1.LogLevel.Error)));\n    }\n\n    return LFService.DEFAULT_LOGGER_FACTORY;\n  };\n\n  LFService.DEFAULT_LOGGER_FACTORY_NAME = \"DEFAULT\";\n  LFService.INSTANCE_SERVICE = LFServiceImpl.getInstance();\n  LFService.DEFAULT_LOGGER_FACTORY = null;\n  return LFService;\n}();\n\nexports.LFService = LFService;","map":{"version":3,"sources":["../../../../src/logging/log/standard/LFService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DataStructures_1 = require(\"../../utils/DataStructures\");\nvar LoggerOptions_1 = require(\"../LoggerOptions\");\nvar LoggerFactoryImpl_1 = require(\"./LoggerFactoryImpl\");\nvar ExtensionHelper_1 = require(\"../../extension/ExtensionHelper\");\nvar LogGroupRule_1 = require(\"./LogGroupRule\");\nvar LoggerFactoryOptions_1 = require(\"./LoggerFactoryOptions\");\nvar LFServiceImpl = (function () {\n    function LFServiceImpl() {\n        // Private constructor.\n        this._nameCounter = 1;\n        this._mapFactories = new DataStructures_1.SimpleMap();\n        ExtensionHelper_1.ExtensionHelper.register();\n    }\n    LFServiceImpl.getInstance = function () {\n        // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.\n        if (LFServiceImpl._INSTANCE === null) {\n            LFServiceImpl._INSTANCE = new LFServiceImpl();\n        }\n        return LFServiceImpl._INSTANCE;\n    };\n    /**\n     * Create a new LoggerFactory with given options (if any). If no options\n     * are specified, the LoggerFactory, will accept any named logger and will\n     * log on info level by default for, to the console.\n     * @param options Options, optional.\n     * @returns {LoggerFactory}\n     */\n    LFServiceImpl.prototype.createLoggerFactory = function (options) {\n        if (options === void 0) { options = null; }\n        var name = \"LoggerFactory\" + this._nameCounter++;\n        return this.createNamedLoggerFactory(name, options);\n    };\n    /**\n     * Create a new LoggerFactory using given name (used for console api/extension).\n     * @param name Name Pick something short but distinguishable.\n     * @param options Options, optional\n     * @return {LoggerFactory}\n     */\n    LFServiceImpl.prototype.createNamedLoggerFactory = function (name, options) {\n        if (options === void 0) { options = null; }\n        if (this._mapFactories.exists(name)) {\n            throw new Error(\"LoggerFactory with name \" + name + \" already exists.\");\n        }\n        var factory;\n        if (options !== null) {\n            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, options);\n        }\n        else {\n            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, LFServiceImpl.createDefaultOptions());\n        }\n        this._mapFactories.put(name, factory);\n        return factory;\n    };\n    /**\n     * Closes all Loggers for LoggerFactories that were created.\n     * After this call, all previously fetched Loggers (from their\n     * factories) are unusable. The factories remain as they were.\n     */\n    LFServiceImpl.prototype.closeLoggers = function () {\n        this._mapFactories.values().forEach(function (factory) {\n            factory.closeLoggers();\n        });\n        this._mapFactories.clear();\n        this._nameCounter = 1;\n    };\n    LFServiceImpl.prototype.getRuntimeSettingsForLoggerFactories = function () {\n        var result = [];\n        this._mapFactories.forEachValue(function (factory) { return result.push(factory); });\n        return result;\n    };\n    LFServiceImpl.prototype.getLogGroupSettings = function (nameLoggerFactory, idLogGroupRule) {\n        var factory = this._mapFactories.get(nameLoggerFactory);\n        if (typeof factory === \"undefined\") {\n            return null;\n        }\n        return factory.getLogGroupRuntimeSettingsByIndex(idLogGroupRule);\n    };\n    LFServiceImpl.prototype.getLoggerFactoryRuntimeSettingsByName = function (nameLoggerFactory) {\n        var result = this._mapFactories.get(nameLoggerFactory);\n        if (typeof result === \"undefined\") {\n            return null;\n        }\n        return result;\n    };\n    LFServiceImpl.createDefaultOptions = function () {\n        return new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(\".+\"), LoggerOptions_1.LogLevel.Info));\n    };\n    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.\n    LFServiceImpl._INSTANCE = null;\n    return LFServiceImpl;\n}());\n/**\n * Create and configure your LoggerFactory from here.\n */\nvar LFService = (function () {\n    function LFService() {\n    }\n    /**\n     * Create a new LoggerFactory with given options (if any). If no options\n     * are specified, the LoggerFactory, will accept any named logger and will\n     * log on info level by default for, to the console.\n     * @param options Options, optional.\n     * @returns {LoggerFactory}\n     */\n    LFService.createLoggerFactory = function (options) {\n        if (options === void 0) { options = null; }\n        return LFService.INSTANCE_SERVICE.createLoggerFactory(options);\n    };\n    /**\n     * Create a new LoggerFactory using given name (used for console api/extension).\n     * @param name Name Pick something short but distinguishable. The word \"DEFAULT\" is reserved and cannot be taken, it is used\n     * for the default LoggerFactory.\n     * @param options Options, optional\n     * @return {LoggerFactory}\n     */\n    LFService.createNamedLoggerFactory = function (name, options) {\n        if (options === void 0) { options = null; }\n        if (name === LFService.DEFAULT_LOGGER_FACTORY_NAME) {\n            throw new Error(\"LoggerFactory name: \" + LFService.DEFAULT_LOGGER_FACTORY_NAME + \" is reserved and cannot be used.\");\n        }\n        return LFService.INSTANCE_SERVICE.createNamedLoggerFactory(name, options);\n    };\n    /**\n     * Closes all Loggers for LoggerFactories that were created.\n     * After this call, all previously fetched Loggers (from their\n     * factories) are unusable. The factories remain as they were.\n     */\n    LFService.closeLoggers = function () {\n        return LFService.INSTANCE_SERVICE.closeLoggers();\n    };\n    /**\n     * Return LFServiceRuntimeSettings to retrieve information loggerfactories\n     * and their runtime settings.\n     * @returns {LFServiceRuntimeSettings}\n     */\n    LFService.getRuntimeSettings = function () {\n        return LFService.INSTANCE_SERVICE;\n    };\n    Object.defineProperty(LFService, \"DEFAULT\", {\n        /**\n         * This property returns the default LoggerFactory (if not yet initialized it is initialized).\n         * This LoggerFactory can be used to share among multiple\n         * applications/libraries - that way you can enable/change logging over everything from\n         * your own application when required.\n         * It is recommended to be used by library developers to make logging easily available for the\n         * consumers of their libraries.\n         * It is highly recommended to use Loggers from the LoggerFactory with unique grouping/names to prevent\n         * clashes of Loggers between multiple projects.\n         * @returns {LoggerFactory} Returns the default LoggerFactory\n         */\n        get: function () {\n            return LFService.getDefault();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LFService.getDefault = function () {\n        if (LFService.DEFAULT_LOGGER_FACTORY === null) {\n            LFService.DEFAULT_LOGGER_FACTORY = LFService.DEFAULT_LOGGER_FACTORY = LFService.INSTANCE_SERVICE.createNamedLoggerFactory(LFService.DEFAULT_LOGGER_FACTORY_NAME, new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(\".+\"), LoggerOptions_1.LogLevel.Error)));\n        }\n        return LFService.DEFAULT_LOGGER_FACTORY;\n    };\n    LFService.DEFAULT_LOGGER_FACTORY_NAME = \"DEFAULT\";\n    LFService.INSTANCE_SERVICE = LFServiceImpl.getInstance();\n    LFService.DEFAULT_LOGGER_FACTORY = null;\n    return LFService;\n}());\nexports.LFService = LFService;\n//# sourceMappingURL=LFService.js.map"]},"metadata":{},"sourceType":"script"}